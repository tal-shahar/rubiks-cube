{"ast":null,"code":"var _jsxFileName = \"C:\\\\Repo\\\\GitHub\\\\rubiks-cube\\\\src\\\\components\\\\IdentifyIncorrectShapes.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport styled from 'styled-components';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst IdentifyContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 20px;\n  padding: 20px;\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 15px;\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);\n  max-height: 500px;\n  overflow-y: auto;\n`;\n_c = IdentifyContainer;\nconst SectionTitle = styled.h3`\n  color: white;\n  text-align: center;\n  margin: 0 0 15px 0;\n  font-size: 1.3rem;\n  font-weight: 600;\n  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\n`;\n_c2 = SectionTitle;\nconst ButtonGrid = styled.div`\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  gap: 15px;\n  margin-bottom: 20px;\n`;\n_c3 = ButtonGrid;\nconst IdentifyButton = styled.button`\n  padding: 12px 16px;\n  border: 2px solid ${props => {\n  if (props.$isActive) return '#4CAF50';\n  if (props.$hasIncorrect) return '#ff4757';\n  return 'rgba(255, 255, 255, 0.3)';\n}};\n  border-radius: 10px;\n  font-size: 14px;\n  font-weight: 600;\n  cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};\n  transition: all 0.3s ease;\n  background: ${props => {\n  if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\n  if (props.$isActive) return 'rgba(76, 175, 80, 0.2)';\n  if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.2)';\n  return 'rgba(255, 255, 255, 0.1)';\n}};\n  color: ${props => {\n  if (props.disabled) return '#666';\n  if (props.$isActive) return '#4CAF50';\n  if (props.$hasIncorrect) return '#ff4757';\n  return 'white';\n}};\n  opacity: ${props => props.disabled ? 0.5 : 1};\n  \n  &:hover {\n    transform: ${props => props.disabled ? 'none' : 'translateY(-2px)'};\n    box-shadow: ${props => props.disabled ? 'none' : '0 4px 12px rgba(0, 0, 0, 0.3)'};\n    background: ${props => {\n  if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\n  if (props.$isActive) return 'rgba(76, 175, 80, 0.3)';\n  if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.3)';\n  return 'rgba(255, 255, 255, 0.2)';\n}};\n  }\n  \n  &:active {\n    transform: ${props => props.disabled ? 'none' : 'translateY(0)'};\n  }\n`;\n_c4 = IdentifyButton;\nconst ButtonContent = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 4px;\n  width: 100%;\n  height: 100%;\n  position: relative;\n`;\n_c5 = ButtonContent;\nconst ShapeContainer = styled.div`\n  width: 60px;\n  height: 60px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n  margin: 8px 0;\n`;\n_c6 = ShapeContainer;\nconst ShapeVisual = styled.div`\n  width: 50px;\n  height: 50px;\n  background: ${props => props.$shapeColor};\n  border: 3px solid ${props => props.$borderColor};\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  \n  /* Shape-specific styling */\n  border-radius: ${props => {\n  if (props.$shapeType === 'Circle') return '50%';\n  if (props.$shapeType === 'Diamond') return '0';\n  return '0';\n}};\n  \n  transform: ${props => {\n  if (props.$shapeType === 'Diamond') return 'rotate(45deg)';\n  return 'none';\n}};\n  \n  /* Triangle shape using CSS */\n  ${props => props.$shapeType === 'Triangle' && `\n    width: 0;\n    height: 0;\n    background: transparent;\n    border: none;\n    border-left: 25px solid transparent;\n    border-right: 25px solid transparent;\n    border-bottom: 43px solid ${props.$shapeColor};\n    position: relative;\n  `}\n`;\n_c7 = ShapeVisual;\nconst CountBadge = styled.span`\n  background: ${props => props.$hasIncorrect ? '#ff4757' : '#4CAF50'};\n  color: white;\n  border-radius: 50%;\n  width: 20px;\n  height: 20px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 10px;\n  font-weight: bold;\n  position: absolute;\n  top: -5px;\n  right: -5px;\n  z-index: 10;\n`;\n_c8 = CountBadge;\nconst ButtonTitle = styled.span`\n  font-size: 12px;\n  font-weight: 600;\n  color: white;\n  text-align: center;\n  margin-top: 4px;\n`;\n_c9 = ButtonTitle;\nconst ButtonSubtitle = styled.div`\n  font-size: 10px;\n  color: rgba(255, 255, 255, 0.8);\n  text-align: center;\n  margin-top: 2px;\n  line-height: 1.2;\n`;\n_c0 = ButtonSubtitle;\nconst Instructions = styled.p`\n  color: rgba(255, 255, 255, 0.8);\n  font-size: 13px;\n  text-align: center;\n  margin: 0 0 15px 0;\n  line-height: 1.4;\n`;\n_c1 = Instructions;\nconst StatusMessage = styled.div`\n  padding: 10px;\n  border-radius: 8px;\n  text-align: center;\n  font-size: 12px;\n  font-weight: 600;\n  background: ${props => {\n  if (props.$type === 'success') return 'rgba(76, 175, 80, 0.2)';\n  if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.2)';\n  if (props.$type === 'error') return 'rgba(244, 67, 54, 0.2)';\n  return 'rgba(33, 150, 243, 0.2)';\n}};\n  color: ${props => {\n  if (props.$type === 'success') return '#4CAF50';\n  if (props.$type === 'warning') return '#FFC107';\n  if (props.$type === 'error') return '#f44336';\n  return '#2196F3';\n}};\n  border: 1px solid ${props => {\n  if (props.$type === 'success') return 'rgba(76, 175, 80, 0.3)';\n  if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.3)';\n  if (props.$type === 'error') return 'rgba(244, 67, 54, 0.3)';\n  return 'rgba(33, 150, 243, 0.3)';\n}};\n`;\n\n// Custom logging function\n_c10 = StatusMessage;\nconst logToTerminal = (message, data = null) => {\n  console.log(`\\nðŸŽ¯ ${message}`);\n  if (data) {\n    console.log(JSON.stringify(data, null, 2));\n  }\n  console.log('='.repeat(80) + '\\n');\n\n  // Try to send to log server, but don't fail if it's not available\n  const sendToLogServer = async () => {\n    try {\n      const response = await fetch('http://localhost:3001/log', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message: message,\n          data: data\n        }),\n        // Add timeout to prevent hanging\n        signal: AbortSignal.timeout(1000)\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      console.log('âœ… Log sent to terminal successfully');\n    } catch (error) {\n      // Silently fail - logging server is optional\n      console.log('ðŸ’¡ Log server not available - logging to console only');\n    }\n  };\n\n  // Execute without blocking\n  sendToLogServer();\n};\nfunction IdentifyIncorrectShapes({\n  isScrambling,\n  cubeState,\n  onIdentification,\n  setCubeState\n}) {\n  _s();\n  const [activeIdentification, setActiveIdentification] = useState(null);\n  const [identificationResults, setIdentificationResults] = useState({});\n  if (!cubeState) {\n    console.log('ðŸš¨ SHOWING LOADING MESSAGE - no cubeState');\n    return /*#__PURE__*/_jsxDEV(IdentifyContainer, {\n      children: [/*#__PURE__*/_jsxDEV(SectionTitle, {\n        children: \"Identify Incorrect Shapes\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 244,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(StatusMessage, {\n        $type: \"warning\",\n        children: \"Loading cube state... Please scramble the cube first to identify incorrect shapes.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 245,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 243,\n      columnNumber: 7\n    }, this);\n  }\n\n  // Helper functions\n  const getShapeType = pieceId => {\n    const shapeTypes = ['Square', 'Square', 'Square', 'Square', 'Square', 'Circle', 'Circle', 'Circle', 'Circle', 'Circle', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle'];\n    return shapeTypes[pieceId] || 'Unknown';\n  };\n  const getShapeColor = pieceId => {\n    const shapeColors = ['Red', 'Blue', 'Green', 'Orange', 'Purple', 'Red', 'Blue', 'Green', 'Orange', 'Yellow', 'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple', 'Red', 'Blue', 'Green', 'Orange', 'Purple', 'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple', 'Yellow'];\n    return shapeColors[pieceId] || 'Unknown';\n  };\n  const getExpectedPosition = pieceId => {\n    const positions = [];\n    for (let x = -1; x <= 1; x++) {\n      for (let y = -1; y <= 1; y++) {\n        for (let z = -1; z <= 1; z++) {\n          if (x === 0 && y === 0 && z === 0) continue;\n          positions.push([x, y, z]);\n        }\n      }\n    }\n    return positions[pieceId];\n  };\n  const isPieceInCorrectPosition = (piece, pieceId) => {\n    if (!piece || !piece.position) return false;\n    const expectedPosition = getExpectedPosition(pieceId);\n    return JSON.stringify(piece.position) === JSON.stringify(expectedPosition);\n  };\n  const getExpectedBorderColor = faceIndex => {\n    const borderColors = ['#FFFFFF',\n    // Face 0 (front) - White\n    '#FF8C00',\n    // Face 1 (back) - Orange  \n    '#00FF00',\n    // Face 2 (right) - Green\n    '#DC143C',\n    // Face 3 (left) - Red\n    '#0000FF',\n    // Face 4 (top) - Blue\n    '#FFD700' // Face 5 (bottom) - Yellow\n    ];\n    return borderColors[faceIndex] || '#000000';\n  };\n  const getBorderColorName = faceIndex => {\n    const colorNames = ['White', 'Orange', 'Green', 'Red', 'Blue', 'Yellow'];\n    return colorNames[faceIndex] || 'Unknown';\n  };\n  const getShapeColorHex = shapeColor => {\n    const colorMap = {\n      'Red': '#DC143C',\n      'Blue': '#0000FF',\n      'Green': '#00FF00',\n      'Orange': '#FF8C00',\n      'Purple': '#800080',\n      'Yellow': '#FFD700',\n      'Cyan': '#00FFFF',\n      'Magenta': '#FF00FF',\n      'Lime': '#00FF00',\n      'Pink': '#FFC0CB'\n    };\n    return colorMap[shapeColor] || '#000000';\n  };\n\n  // Function to validate that starting colors are properly outward-facing\n  const validateColorOrientation = () => {\n    logToTerminal('ðŸŽ¨ ========== STARTING COLOR ORIENTATION VALIDATION ==========');\n    if (!cubeState || cubeState.length === 0) {\n      logToTerminal('ðŸŽ¨ âŒ No cube state available for color orientation validation');\n      return {\n        type: 'colorOrientation',\n        incorrectPieces: [],\n        count: 0,\n        totalIncorrectFaces: 0\n      };\n    }\n    logToTerminal('ðŸŽ¨ âœ… Cube state available, validating starting colors are outward-facing for', cubeState.length, 'pieces...');\n    const incorrectPieces = [];\n    let totalIncorrectFaces = 0;\n    let piecesChecked = 0;\n    cubeState.forEach((piece, index) => {\n      piecesChecked++;\n      const pieceId = piece.pieceId || index;\n      if (!Array.isArray(piece.position) || !piece.colors || typeof piece.colors !== 'object') {\n        logToTerminal(`ðŸŽ¨ âŒ Piece ${pieceId} has invalid position or colors`);\n        return;\n      }\n      const [x, y, z] = piece.position;\n\n      // Determine which faces should be visible based on current position\n      const shouldBeVisible = {\n        front: z === 1,\n        back: z === -1,\n        right: x === 1,\n        left: x === -1,\n        top: y === 1,\n        bottom: y === -1\n      };\n      const incorrectFaces = [];\n\n      // Check if visible faces have proper colors (not black/gray)\n      Object.keys(shouldBeVisible).forEach(face => {\n        if (shouldBeVisible[face]) {\n          const faceColor = piece.colors[face];\n\n          // Check if the visible face has a proper color (not black/gray)\n          if (faceColor === '#444444' || faceColor === 'black' || faceColor === '#000000') {\n            incorrectFaces.push({\n              face: face,\n              currentColor: faceColor,\n              issue: 'Visible face is black/gray - starting color should be outward-facing'\n            });\n            totalIncorrectFaces++;\n            logToTerminal(`ðŸŽ¨ âŒ Piece ${pieceId} has black/gray ${face} face: ${faceColor} (should have starting color outward-facing)`);\n          } else {\n            logToTerminal(`ðŸŽ¨ âœ… Piece ${pieceId} ${face} face has proper color: ${faceColor}`);\n          }\n        }\n      });\n      if (incorrectFaces.length > 0) {\n        incorrectPieces.push({\n          pieceId: pieceId,\n          currentPosition: piece.position,\n          startingColors: piece.startingColors,\n          incorrectFaces: incorrectFaces\n        });\n        logToTerminal(`ðŸŽ¨ âœ… Added piece ${pieceId} to incorrect pieces with ${incorrectFaces.length} incorrect faces`);\n      }\n    });\n    logToTerminal('ðŸŽ¨ ========== STARTING COLOR ORIENTATION VALIDATION SUMMARY ==========');\n    logToTerminal('ðŸŽ¨ Total pieces checked:', piecesChecked);\n    logToTerminal('ðŸŽ¨ Pieces with incorrect color orientation:', incorrectPieces.length);\n    logToTerminal('ðŸŽ¨ Total incorrect faces found:', totalIncorrectFaces);\n    const result = {\n      type: 'colorOrientation',\n      incorrectPieces: incorrectPieces,\n      count: incorrectPieces.length,\n      totalIncorrectFaces: totalIncorrectFaces\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      'colorOrientation': result\n    }));\n    return result;\n  };\n\n  // Function to get expected color for a face\n  const getExpectedColorForFace = face => {\n    const colorMap = {\n      front: 'white',\n      back: 'yellow',\n      right: 'red',\n      left: 'orange',\n      top: 'blue',\n      bottom: 'green'\n    };\n    return colorMap[face] || '#444444';\n  };\n\n  // Get pieces data\n  const getPieces = () => {\n    if (Array.isArray(cubeState)) {\n      return cubeState.map((piece, index) => ({\n        pieceId: index,\n        position: piece.position,\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory || []\n      }));\n    } else if (cubeState !== null && cubeState !== void 0 && cubeState.pieces) {\n      return cubeState.pieces;\n    }\n    return [];\n  };\n  const pieces = getPieces();\n\n  // Identify incorrect shapes by type\n  const identifyIncorrectShapesByType = shapeType => {\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const actualShapeType = getShapeType(pieceId);\n      return actualShapeType === shapeType && !isPieceInCorrectPosition(piece, pieceId);\n    });\n    const result = {\n      type: 'shape',\n      shapeType,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`shape-${shapeType}`]: result\n    }));\n    logToTerminal(`ðŸ” IDENTIFIED INCORRECT ${shapeType.toUpperCase()} SHAPES`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n\n  // Identify incorrect shapes by color\n  const identifyIncorrectShapesByColor = shapeColor => {\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const actualShapeColor = getShapeColor(pieceId);\n      return actualShapeColor === shapeColor && !isPieceInCorrectPosition(piece, pieceId);\n    });\n    const result = {\n      type: 'color',\n      shapeColor,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`color-${shapeColor}`]: result\n    }));\n    logToTerminal(`ðŸŽ¨ IDENTIFIED INCORRECT ${shapeColor.toUpperCase()} SHAPES`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n\n  // Identify incorrect border colors\n  const identifyIncorrectBorderColors = faceIndex => {\n    const borderColorName = getBorderColorName(faceIndex);\n    const borderColorHex = getExpectedBorderColor(faceIndex);\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\n\n      // Check if this piece should have this border color in its current position\n      const [x, y, z] = piece.position;\n      let shouldHaveBorderColor = false;\n      switch (faceIndex) {\n        case 0:\n          // Front face (Z+) - White\n          shouldHaveBorderColor = z === 1;\n          break;\n        case 1:\n          // Back face (Z-) - Orange\n          shouldHaveBorderColor = z === -1;\n          break;\n        case 2:\n          // Right face (X+) - Green\n          shouldHaveBorderColor = x === 1;\n          break;\n        case 3:\n          // Left face (X-) - Red\n          shouldHaveBorderColor = x === -1;\n          break;\n        case 4:\n          // Top face (Y+) - Blue\n          shouldHaveBorderColor = y === 1;\n          break;\n        case 5:\n          // Bottom face (Y-) - Yellow\n          shouldHaveBorderColor = y === -1;\n          break;\n      }\n\n      // Piece is incorrect if it should have this border color but is not in correct position\n      return shouldHaveBorderColor && !isInCorrectPosition;\n    });\n    const result = {\n      type: 'border',\n      faceIndex,\n      borderColorName,\n      borderColorHex,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`border-${faceIndex}`]: result\n    }));\n    logToTerminal(`ðŸŽ­ IDENTIFIED INCORRECT ${borderColorName.toUpperCase()} BORDER COLORS`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n\n  // Identify pieces with black faces that should be visible\n  const identifyPiecesWithBlackFaces = () => {\n    logToTerminal('ðŸ” ========== STARTING BLACK FACES IDENTIFICATION ==========');\n    logToTerminal('ðŸ” cubeState type:', typeof cubeState);\n    logToTerminal('ðŸ” cubeState length:', cubeState ? cubeState.length : 'null');\n    logToTerminal('ðŸ” cubeState is null:', cubeState === null);\n    logToTerminal('ðŸ” cubeState is undefined:', cubeState === undefined);\n    if (!cubeState || cubeState.length === 0) {\n      logToTerminal('ðŸ” âŒ No cube state available for identification');\n      return {\n        type: 'blackFaces',\n        incorrectPieces: [],\n        count: 0,\n        totalBlackFaces: 0\n      };\n    }\n    logToTerminal('ðŸ” âœ… Cube state available, checking', cubeState.length, 'pieces...');\n    const incorrectPieces = [];\n    let totalBlackFaces = 0;\n    let piecesChecked = 0;\n    let piecesWithColors = 0;\n    let piecesWithPosition = 0;\n\n    // Log detailed structure of first few pieces\n    logToTerminal('ðŸ” ========== PIECE STRUCTURE ANALYSIS ==========');\n    cubeState.slice(0, 5).forEach((piece, index) => {\n      logToTerminal(`ðŸ” Piece ${index}:`, {\n        pieceId: piece.pieceId,\n        hasPosition: Array.isArray(piece.position),\n        position: piece.position,\n        hasColors: typeof piece.colors === 'object' && piece.colors !== null,\n        colors: piece.colors,\n        allKeys: Object.keys(piece)\n      });\n    });\n    logToTerminal('ðŸ” ========== CHECKING ALL PIECES ==========');\n    cubeState.forEach((piece, index) => {\n      piecesChecked++;\n      const pieceId = piece.pieceId || index;\n\n      // Check if piece has position\n      if (!Array.isArray(piece.position)) {\n        logToTerminal(`ðŸ” âŒ Piece ${pieceId} has invalid position:`, piece.position);\n        return;\n      }\n      piecesWithPosition++;\n\n      // Check if piece has colors\n      if (!piece.colors || typeof piece.colors !== 'object') {\n        logToTerminal(`ðŸ” âŒ Piece ${pieceId} has invalid colors:`, piece.colors);\n        return;\n      }\n      piecesWithColors++;\n      const [x, y, z] = piece.position;\n      logToTerminal(`ðŸ” Checking piece ${pieceId} at position [${x}, ${y}, ${z}]`);\n      logToTerminal(`ðŸ” Piece colors object:`, piece.colors);\n      logToTerminal(`ðŸ” Color keys:`, Object.keys(piece.colors));\n\n      // Determine which faces should be visible based on current position\n      const visibleFaces = [];\n      if (x === 1) visibleFaces.push('right');\n      if (x === -1) visibleFaces.push('left');\n      if (y === 1) visibleFaces.push('top');\n      if (y === -1) visibleFaces.push('bottom');\n      if (z === 1) visibleFaces.push('front');\n      if (z === -1) visibleFaces.push('back');\n      logToTerminal(`ðŸ” Visible faces for piece ${pieceId}:`, visibleFaces);\n\n      // Check if any visible faces are black/gray\n      const blackVisibleFaces = [];\n      visibleFaces.forEach(face => {\n        const faceColor = piece.colors[face];\n        logToTerminal(`ðŸ” Face ${face} color: \"${faceColor}\" (type: ${typeof faceColor})`);\n\n        // Check for both #444444 and 'black' values\n        if (faceColor === '#444444' || faceColor === 'black' || faceColor === '#000000') {\n          blackVisibleFaces.push(face);\n          totalBlackFaces++;\n          logToTerminal(`ðŸ” âœ… FOUND BLACK/GRAY FACE: ${face} on piece ${pieceId} with color \"${faceColor}\"`);\n        } else {\n          logToTerminal(`ðŸ” Face ${face} is not black/gray (color: \"${faceColor}\")`);\n        }\n      });\n      if (blackVisibleFaces.length > 0) {\n        incorrectPieces.push({\n          pieceId: pieceId,\n          currentPosition: piece.position,\n          blackVisibleFaces: blackVisibleFaces\n        });\n        logToTerminal(`ðŸ” âœ… Added piece ${pieceId} to incorrect pieces with ${blackVisibleFaces.length} black faces:`, blackVisibleFaces);\n      } else {\n        logToTerminal(`ðŸ” Piece ${pieceId} has no black visible faces`);\n      }\n    });\n    logToTerminal('ðŸ” ========== IDENTIFICATION SUMMARY ==========');\n    logToTerminal('ðŸ” Total pieces checked:', piecesChecked);\n    logToTerminal('ðŸ” Pieces with valid position:', piecesWithPosition);\n    logToTerminal('ðŸ” Pieces with valid colors:', piecesWithColors);\n    logToTerminal('ðŸ” Pieces with black faces:', incorrectPieces.length);\n    logToTerminal('ðŸ” Total black faces found:', totalBlackFaces);\n    logToTerminal('ðŸ” Incorrect pieces details:', incorrectPieces);\n    const result = {\n      type: 'blackFaces',\n      incorrectPieces: incorrectPieces,\n      count: incorrectPieces.length,\n      totalBlackFaces: totalBlackFaces\n    };\n    logToTerminal('ðŸ” ========== RETURNING RESULT ==========');\n    logToTerminal('ðŸ” Result:', result);\n    setIdentificationResults(prev => {\n      const newResults = {\n        ...prev,\n        'blackFaces': result\n      };\n      logToTerminal('ðŸ”§ UPDATING identificationResults:', newResults);\n      return newResults;\n    });\n    return result;\n  };\n  const handleButtonClick = (type, identifier) => {\n    if (isScrambling) return;\n    setActiveIdentification(`${type}-${identifier}`);\n    let result;\n    switch (type) {\n      case 'shape':\n        result = identifyIncorrectShapesByType(identifier);\n        break;\n      case 'color':\n        result = identifyIncorrectShapesByColor(identifier);\n        break;\n      case 'border':\n        result = identifyIncorrectBorderColors(identifier);\n        break;\n      case 'blackFaces':\n        result = identifyPiecesWithBlackFaces();\n        break;\n      case 'colorOrientation':\n        result = validateColorOrientation();\n        break;\n    }\n\n    // Reset active state after a short delay\n    setTimeout(() => {\n      setActiveIdentification(null);\n    }, 2000);\n  };\n  const handleFindAndFixGrayFaces = () => {\n    logToTerminal('ðŸ”§ FIND AND FIX GRAY FACES BUTTON CLICKED!');\n    logToTerminal('ðŸ”§ isScrambling:', isScrambling);\n    if (isScrambling) {\n      logToTerminal('ðŸ”§ Button disabled - cube is scrambling');\n      return;\n    }\n\n    // First identify the pieces with black faces\n    const blackFacesResult = identifyPiecesWithBlackFaces();\n    if (blackFacesResult.count === 0) {\n      logToTerminal('No gray faces to fix');\n      return;\n    }\n    logToTerminal('ðŸ”§ FOUND AND FIXING GRAY FACES:', blackFacesResult.incorrectPieces.length, 'pieces');\n    logToTerminal('ðŸ”§ Pieces to fix:', blackFacesResult.incorrectPieces.map(p => `${p.pieceId} at [${p.currentPosition.join(', ')}]`));\n\n    // Update the cube state to fix the colors using CubeStateManager\n    if (typeof window !== 'undefined' && window.CubeStateManager) {\n      logToTerminal('ðŸ”§ Using CubeStateManager to update cube state');\n      // Get current state without triggering reinitialization\n      const currentState = window.CubeStateManager.state || cubeState;\n      logToTerminal('ðŸ”§ Current state length:', currentState.length);\n      window.CubeStateManager.setState(prevState => {\n        logToTerminal('ðŸ”§ CubeStateManager setState called with prevState length:', prevState.length);\n        const newState = [...prevState];\n        blackFacesResult.incorrectPieces.forEach(incorrectPiece => {\n          logToTerminal(`ðŸ”§ Processing piece ${incorrectPiece.pieceId}...`);\n          const pieceIndex = newState.findIndex(p => p.pieceId === incorrectPiece.pieceId);\n          logToTerminal(`ðŸ”§ Found piece at index ${pieceIndex}`);\n          if (pieceIndex !== -1) {\n            const piece = newState[pieceIndex];\n            const [x, y, z] = piece.position;\n            logToTerminal(`ðŸ”§ Piece ${piece.pieceId} at position [${x}, ${y}, ${z}]`);\n            logToTerminal(`ðŸ”§ Current colors:`, piece.colors);\n\n            // Determine which faces should be visible based on current position\n            const visibleFaces = [];\n            if (x === 1) visibleFaces.push('right');\n            if (x === -1) visibleFaces.push('left');\n            if (y === 1) visibleFaces.push('top');\n            if (y === -1) visibleFaces.push('bottom');\n            if (z === 1) visibleFaces.push('front');\n            if (z === -1) visibleFaces.push('back');\n            logToTerminal(`ðŸ”§ Visible faces:`, visibleFaces);\n\n            // Fix the colors for visible faces that are currently black/gray\n            const updatedColors = {\n              ...piece.colors\n            };\n            let fixedAny = false;\n            visibleFaces.forEach(face => {\n              logToTerminal(`ðŸ”§ Checking face ${face}: current color = ${updatedColors[face]}`);\n              if (updatedColors[face] === '#444444' || updatedColors[face] === 'black' || updatedColors[face] === '#000000') {\n                // Set the correct color based on the face\n                switch (face) {\n                  case 'front':\n                    updatedColors[face] = '#FFFFFF'; // White\n                    break;\n                  case 'back':\n                    updatedColors[face] = '#FFD700'; // Yellow\n                    break;\n                  case 'right':\n                    updatedColors[face] = '#DC143C'; // Red\n                    break;\n                  case 'left':\n                    updatedColors[face] = '#FF8C00'; // Orange\n                    break;\n                  case 'top':\n                    updatedColors[face] = '#0000FF'; // Blue\n                    break;\n                  case 'bottom':\n                    updatedColors[face] = '#00FF00'; // Green\n                    break;\n                }\n                logToTerminal(`ðŸ”§ Fixed face ${face} to ${updatedColors[face]}`);\n                fixedAny = true;\n              }\n            });\n            if (fixedAny) {\n              newState[pieceIndex] = {\n                ...piece,\n                colors: updatedColors\n              };\n              logToTerminal(`ðŸ”§ Updated piece ${piece.pieceId} with new colors:`, updatedColors);\n            } else {\n              logToTerminal(`ðŸ”§ No changes needed for piece ${piece.pieceId}`);\n            }\n          } else {\n            logToTerminal(`ðŸ”§ ERROR: Could not find piece ${incorrectPiece.pieceId} in cube state`);\n          }\n        });\n        logToTerminal('âœ… Gray faces find and fix completed!');\n        logToTerminal('ðŸ”§ New state length:', newState.length);\n        return newState;\n      });\n    } else {\n      // Fallback to the passed setCubeState function\n      logToTerminal('ðŸ”§ Using fallback setCubeState method');\n      setCubeState(prevState => {\n        logToTerminal('ðŸ”§ setCubeState called with prevState length:', prevState.length);\n        const newState = [...prevState];\n        blackFacesResult.incorrectPieces.forEach(incorrectPiece => {\n          logToTerminal(`ðŸ”§ Processing piece ${incorrectPiece.pieceId}...`);\n          const pieceIndex = newState.findIndex(p => p.pieceId === incorrectPiece.pieceId);\n          logToTerminal(`ðŸ”§ Found piece at index ${pieceIndex}`);\n          if (pieceIndex !== -1) {\n            const piece = newState[pieceIndex];\n            const [x, y, z] = piece.position;\n            logToTerminal(`ðŸ”§ Piece ${piece.pieceId} at position [${x}, ${y}, ${z}]`);\n            logToTerminal(`ðŸ”§ Current colors:`, piece.colors);\n\n            // Determine which faces should be visible based on current position\n            const visibleFaces = [];\n            if (x === 1) visibleFaces.push('right');\n            if (x === -1) visibleFaces.push('left');\n            if (y === 1) visibleFaces.push('top');\n            if (y === -1) visibleFaces.push('bottom');\n            if (z === 1) visibleFaces.push('front');\n            if (z === -1) visibleFaces.push('back');\n            logToTerminal(`ðŸ”§ Visible faces:`, visibleFaces);\n\n            // Fix the colors for visible faces that are currently black/gray\n            const updatedColors = {\n              ...piece.colors\n            };\n            let fixedAny = false;\n            visibleFaces.forEach(face => {\n              logToTerminal(`ðŸ”§ Checking face ${face}: current color = ${updatedColors[face]}`);\n              if (updatedColors[face] === '#444444' || updatedColors[face] === 'black' || updatedColors[face] === '#000000') {\n                // Set the correct color based on the face\n                switch (face) {\n                  case 'front':\n                    updatedColors[face] = '#FFFFFF'; // White\n                    break;\n                  case 'back':\n                    updatedColors[face] = '#FFD700'; // Yellow\n                    break;\n                  case 'right':\n                    updatedColors[face] = '#DC143C'; // Red\n                    break;\n                  case 'left':\n                    updatedColors[face] = '#FF8C00'; // Orange\n                    break;\n                  case 'top':\n                    updatedColors[face] = '#0000FF'; // Blue\n                    break;\n                  case 'bottom':\n                    updatedColors[face] = '#00FF00'; // Green\n                    break;\n                }\n                logToTerminal(`ðŸ”§ Fixed face ${face} to ${updatedColors[face]}`);\n                fixedAny = true;\n              }\n            });\n            if (fixedAny) {\n              newState[pieceIndex] = {\n                ...piece,\n                colors: updatedColors\n              };\n              logToTerminal(`ðŸ”§ Updated piece ${piece.pieceId} with new colors:`, updatedColors);\n            } else {\n              logToTerminal(`ðŸ”§ No changes needed for piece ${piece.pieceId}`);\n            }\n          } else {\n            logToTerminal(`ðŸ”§ ERROR: Could not find piece ${incorrectPiece.pieceId} in cube state`);\n          }\n        });\n        logToTerminal('âœ… Gray faces find and fix completed!');\n        logToTerminal('ðŸ”§ New state length:', newState.length);\n        return newState;\n      });\n    }\n\n    // Clear the identification results since we've fixed the issue\n    setIdentificationResults(prev => ({\n      ...prev,\n      blackFaces: null\n    }));\n\n    // Clear the highlighting by calling onIdentification with empty result\n    if (onIdentification) {\n      onIdentification({\n        type: 'blackFaces',\n        count: 0,\n        totalBlackFaces: 0,\n        incorrectPieces: []\n      });\n    }\n  };\n  const getButtonState = (type, identifier) => {\n    const key = `${type}-${identifier}`;\n    const result = identificationResults[key];\n    const isActive = activeIdentification === key;\n    return {\n      isActive,\n      hasIncorrect: result && result.count > 0,\n      count: result ? result.count : 0\n    };\n  };\n\n  // Generate all possible combinations of shape+color+border\n  const generateCombinations = () => {\n    const shapeTypes = ['Square', 'Circle', 'Triangle', 'Diamond'];\n    const shapeColors = ['Red', 'Blue', 'Green', 'Orange', 'Purple', 'Yellow', 'Cyan', 'Magenta', 'Lime', 'Pink'];\n    const borderColors = [{\n      name: 'White',\n      hex: '#FFFFFF',\n      faceIndex: 0\n    }, {\n      name: 'Orange',\n      hex: '#FF8C00',\n      faceIndex: 1\n    }, {\n      name: 'Green',\n      hex: '#00FF00',\n      faceIndex: 2\n    }, {\n      name: 'Red',\n      hex: '#DC143C',\n      faceIndex: 3\n    }, {\n      name: 'Blue',\n      hex: '#0000FF',\n      faceIndex: 4\n    }, {\n      name: 'Yellow',\n      hex: '#FFD700',\n      faceIndex: 5\n    }];\n    const combinations = [];\n    shapeTypes.forEach(shapeType => {\n      shapeColors.forEach(shapeColor => {\n        borderColors.forEach(borderColor => {\n          combinations.push({\n            id: `${shapeType}-${shapeColor}-${borderColor.name}`,\n            shapeType,\n            shapeColor,\n            borderColor: borderColor.name,\n            borderColorHex: borderColor.hex,\n            faceIndex: borderColor.faceIndex\n          });\n        });\n      });\n    });\n    return combinations;\n  };\n\n  // Identify incorrect pieces by combination\n  const identifyIncorrectCombination = combination => {\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const actualShapeType = getShapeType(pieceId);\n      const actualShapeColor = getShapeColor(pieceId);\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\n\n      // Check if this piece matches the combination\n      const matchesShape = actualShapeType === combination.shapeType;\n      const matchesColor = actualShapeColor === combination.shapeColor;\n\n      // Check if this piece should have this border color in its current position\n      const [x, y, z] = piece.position;\n      let shouldHaveBorderColor = false;\n      switch (combination.faceIndex) {\n        case 0:\n          // Front face (Z+) - White\n          shouldHaveBorderColor = z === 1;\n          break;\n        case 1:\n          // Back face (Z-) - Orange\n          shouldHaveBorderColor = z === -1;\n          break;\n        case 2:\n          // Right face (X+) - Green\n          shouldHaveBorderColor = x === 1;\n          break;\n        case 3:\n          // Left face (X-) - Red\n          shouldHaveBorderColor = x === -1;\n          break;\n        case 4:\n          // Top face (Y+) - Blue\n          shouldHaveBorderColor = y === 1;\n          break;\n        case 5:\n          // Bottom face (Y-) - Yellow\n          shouldHaveBorderColor = y === -1;\n          break;\n      }\n\n      // Piece is incorrect if it matches the combination but is not in correct position\n      return matchesShape && matchesColor && shouldHaveBorderColor && !isInCorrectPosition;\n    });\n    const result = {\n      type: 'combination',\n      combination,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`combination-${combination.id}`]: result\n    }));\n    logToTerminal(`ðŸŽ¯ IDENTIFIED INCORRECT ${combination.shapeColor} ${combination.shapeType} with ${combination.borderColor} border`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n  const handleCombinationClick = combination => {\n    if (isScrambling) return;\n    setActiveIdentification(`combination-${combination.id}`);\n    const result = identifyIncorrectCombination(combination);\n\n    // Reset active state after a short delay\n    setTimeout(() => {\n      setActiveIdentification(null);\n    }, 2000);\n  };\n  const getCombinationButtonState = combination => {\n    const key = `combination-${combination.id}`;\n    const result = identificationResults[key];\n    const isActive = activeIdentification === key;\n    return {\n      isActive,\n      hasIncorrect: result && result.count > 0,\n      count: result ? result.count : 0\n    };\n  };\n  const combinations = generateCombinations();\n  return /*#__PURE__*/_jsxDEV(IdentifyContainer, {\n    children: [/*#__PURE__*/_jsxDEV(SectionTitle, {\n      children: \"Identify Incorrect Shapes\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1102,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Instructions, {\n      children: \"Click any button below to identify pieces with that specific combination of shape+color+border that are in incorrect positions. Buttons show the count of incorrect pieces found for each combination.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1103,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n        style: {\n          color: 'white',\n          marginBottom: '10px',\n          fontSize: '16px'\n        },\n        children: \"Color Orientation & Special Issues\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1110,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ButtonGrid, {\n        style: {\n          gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',\n          marginBottom: '20px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(IdentifyButton, {\n          onClick: () => handleButtonClick('colorOrientation', 'all'),\n          disabled: isScrambling,\n          $isActive: activeIdentification === 'colorOrientation-all',\n          $hasIncorrect: identificationResults['colorOrientation'] && identificationResults['colorOrientation'].count > 0,\n          style: {\n            borderColor: '#9C27B0',\n            borderWidth: '3px',\n            background: 'rgba(156, 39, 176, 0.2)'\n          },\n          children: /*#__PURE__*/_jsxDEV(ButtonContent, {\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              style: {\n                fontSize: '24px',\n                marginBottom: '8px'\n              },\n              children: \"\\uD83C\\uDFA8\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1125,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonTitle, {\n              style: {\n                color: '#9C27B0',\n                fontWeight: 'bold'\n              },\n              children: \"Color Orientation\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1126,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonSubtitle, {\n              children: \"Validate that all visible faces have correct colors\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1129,\n              columnNumber: 15\n            }, this), identificationResults['colorOrientation'] && identificationResults['colorOrientation'].count > 0 && /*#__PURE__*/_jsxDEV(CountBadge, {\n              $hasIncorrect: true,\n              children: [identificationResults['colorOrientation'].count, \" pieces\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1135,\n                columnNumber: 19\n              }, this), identificationResults['colorOrientation'].totalIncorrectFaces, \" faces\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1133,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1124,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1113,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(IdentifyButton, {\n          onClick: () => handleButtonClick('blackFaces', 'all'),\n          disabled: isScrambling,\n          $isActive: activeIdentification === 'blackFaces-all',\n          $hasIncorrect: identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0,\n          style: {\n            background: 'rgba(255, 0, 0, 0.2)',\n            borderColor: '#ff0000',\n            borderWidth: '3px',\n            display: 'none' // Hide the button but keep functionality\n          },\n          children: /*#__PURE__*/_jsxDEV(ButtonContent, {\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              style: {\n                fontSize: '24px',\n                marginBottom: '8px'\n              },\n              children: \"\\u26AB\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1154,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonTitle, {\n              style: {\n                color: '#ff0000',\n                fontWeight: 'bold'\n              },\n              children: \"Dark Gray Faces\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1155,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonSubtitle, {\n              children: \"Find pieces with dark gray faces (highlighted in pink)\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1158,\n              columnNumber: 15\n            }, this), identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0 && /*#__PURE__*/_jsxDEV(CountBadge, {\n              $hasIncorrect: true,\n              children: [identificationResults['blackFaces'].count, \" pieces\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1164,\n                columnNumber: 19\n              }, this), identificationResults['blackFaces'].totalBlackFaces, \" faces\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1162,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1153,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1141,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(IdentifyButton, {\n          onClick: () => {\n            logToTerminal('ðŸ”§ BUTTON CLICKED - onClick handler triggered');\n            logToTerminal('ðŸ”§ isScrambling:', isScrambling);\n            handleFindAndFixGrayFaces();\n          },\n          disabled: isScrambling,\n          $isActive: false,\n          $hasIncorrect: false,\n          style: {\n            borderColor: '#FF6B6B',\n            borderWidth: '3px',\n            background: 'rgba(255, 107, 107, 0.2)'\n          },\n          children: /*#__PURE__*/_jsxDEV(ButtonContent, {\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              style: {\n                fontSize: '24px',\n                marginBottom: '8px'\n              },\n              children: \"\\uD83D\\uDD27\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1188,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonTitle, {\n              style: {\n                color: '#FF6B6B',\n                fontWeight: 'bold'\n              },\n              children: \"Find & Fix Gray Faces\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1189,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonSubtitle, {\n              children: \"Identify and automatically correct dark gray faces to proper colors\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1192,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1187,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1172,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1111,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1109,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n        style: {\n          color: 'white',\n          marginBottom: '15px',\n          fontSize: '16px'\n        },\n        children: \"By Shape + Color + Border Combinations\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1202,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ButtonGrid, {\n        style: {\n          gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))'\n        },\n        children: combinations.map(combination => {\n          const state = getCombinationButtonState(combination);\n          return /*#__PURE__*/_jsxDEV(IdentifyButton, {\n            onClick: () => handleCombinationClick(combination),\n            disabled: isScrambling,\n            $isActive: state.isActive,\n            $hasIncorrect: state.hasIncorrect,\n            style: {\n              borderColor: state.hasIncorrect ? '#ff4757' : combination.borderColorHex,\n              borderWidth: '3px'\n            },\n            children: /*#__PURE__*/_jsxDEV(ButtonContent, {\n              children: [/*#__PURE__*/_jsxDEV(ShapeContainer, {\n                children: [combination.shapeType === 'Triangle' ? /*#__PURE__*/_jsxDEV(\"svg\", {\n                  width: \"50\",\n                  height: \"50\",\n                  viewBox: \"0 0 50 50\",\n                  children: /*#__PURE__*/_jsxDEV(\"polygon\", {\n                    points: \"25,5 45,40 5,40\",\n                    fill: getShapeColorHex(combination.shapeColor),\n                    stroke: combination.borderColorHex,\n                    strokeWidth: \"3\"\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 1223,\n                    columnNumber: 25\n                  }, this)\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1222,\n                  columnNumber: 23\n                }, this) : /*#__PURE__*/_jsxDEV(ShapeVisual, {\n                  $shapeType: combination.shapeType,\n                  $shapeColor: getShapeColorHex(combination.shapeColor),\n                  $borderColor: combination.borderColorHex\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1231,\n                  columnNumber: 23\n                }, this), state.count > 0 && /*#__PURE__*/_jsxDEV(CountBadge, {\n                  $hasIncorrect: state.hasIncorrect,\n                  children: state.count\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1238,\n                  columnNumber: 23\n                }, this)]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 1220,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(ButtonTitle, {\n                children: [combination.shapeColor, \" \", combination.shapeType]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 1243,\n                columnNumber: 19\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1219,\n              columnNumber: 17\n            }, this)\n          }, `combination-${combination.id}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1208,\n            columnNumber: 15\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1203,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1201,\n      columnNumber: 7\n    }, this), activeIdentification && /*#__PURE__*/_jsxDEV(StatusMessage, {\n      $type: \"success\",\n      children: \"Combination identification complete! Check the terminal for detailed results.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1255,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1101,\n    columnNumber: 5\n  }, this);\n}\n_s(IdentifyIncorrectShapes, \"ii/H1hjjocRwhM9agB/LU82OhuE=\");\n_c11 = IdentifyIncorrectShapes;\nexport default IdentifyIncorrectShapes;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c0, _c1, _c10, _c11;\n$RefreshReg$(_c, \"IdentifyContainer\");\n$RefreshReg$(_c2, \"SectionTitle\");\n$RefreshReg$(_c3, \"ButtonGrid\");\n$RefreshReg$(_c4, \"IdentifyButton\");\n$RefreshReg$(_c5, \"ButtonContent\");\n$RefreshReg$(_c6, \"ShapeContainer\");\n$RefreshReg$(_c7, \"ShapeVisual\");\n$RefreshReg$(_c8, \"CountBadge\");\n$RefreshReg$(_c9, \"ButtonTitle\");\n$RefreshReg$(_c0, \"ButtonSubtitle\");\n$RefreshReg$(_c1, \"Instructions\");\n$RefreshReg$(_c10, \"StatusMessage\");\n$RefreshReg$(_c11, \"IdentifyIncorrectShapes\");","map":{"version":3,"names":["React","useState","styled","jsxDEV","_jsxDEV","IdentifyContainer","div","_c","SectionTitle","h3","_c2","ButtonGrid","_c3","IdentifyButton","button","props","$isActive","$hasIncorrect","disabled","_c4","ButtonContent","_c5","ShapeContainer","_c6","ShapeVisual","$shapeColor","$borderColor","$shapeType","_c7","CountBadge","span","_c8","ButtonTitle","_c9","ButtonSubtitle","_c0","Instructions","p","_c1","StatusMessage","$type","_c10","logToTerminal","message","data","console","log","JSON","stringify","repeat","sendToLogServer","response","fetch","method","headers","body","signal","AbortSignal","timeout","ok","Error","status","error","IdentifyIncorrectShapes","isScrambling","cubeState","onIdentification","setCubeState","_s","activeIdentification","setActiveIdentification","identificationResults","setIdentificationResults","children","fileName","_jsxFileName","lineNumber","columnNumber","getShapeType","pieceId","shapeTypes","getShapeColor","shapeColors","getExpectedPosition","positions","x","y","z","push","isPieceInCorrectPosition","piece","position","expectedPosition","getExpectedBorderColor","faceIndex","borderColors","getBorderColorName","colorNames","getShapeColorHex","shapeColor","colorMap","validateColorOrientation","length","type","incorrectPieces","count","totalIncorrectFaces","piecesChecked","forEach","index","Array","isArray","colors","shouldBeVisible","front","back","right","left","top","bottom","incorrectFaces","Object","keys","face","faceColor","currentColor","issue","currentPosition","startingColors","result","prev","getExpectedColorForFace","getPieces","map","rotationHistory","pieces","identifyIncorrectShapesByType","shapeType","filter","actualShapeType","toUpperCase","identifyIncorrectShapesByColor","actualShapeColor","identifyIncorrectBorderColors","borderColorName","borderColorHex","isInCorrectPosition","shouldHaveBorderColor","identifyPiecesWithBlackFaces","undefined","totalBlackFaces","piecesWithColors","piecesWithPosition","slice","hasPosition","hasColors","allKeys","visibleFaces","blackVisibleFaces","newResults","handleButtonClick","identifier","setTimeout","handleFindAndFixGrayFaces","blackFacesResult","join","window","CubeStateManager","currentState","state","setState","prevState","newState","incorrectPiece","pieceIndex","findIndex","updatedColors","fixedAny","blackFaces","getButtonState","key","isActive","hasIncorrect","generateCombinations","name","hex","combinations","borderColor","id","identifyIncorrectCombination","combination","matchesShape","matchesColor","handleCombinationClick","getCombinationButtonState","style","color","marginBottom","fontSize","gridTemplateColumns","onClick","borderWidth","background","fontWeight","display","width","height","viewBox","points","fill","stroke","strokeWidth","_c11","$RefreshReg$"],"sources":["C:/Repo/GitHub/rubiks-cube/src/components/IdentifyIncorrectShapes.js"],"sourcesContent":["import React, { useState } from 'react';\r\nimport styled from 'styled-components';\r\n\r\nconst IdentifyContainer = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 20px;\r\n  padding: 20px;\r\n  background: rgba(255, 255, 255, 0.1);\r\n  border-radius: 15px;\r\n  backdrop-filter: blur(10px);\r\n  border: 1px solid rgba(255, 255, 255, 0.2);\r\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);\r\n  max-height: 500px;\r\n  overflow-y: auto;\r\n`;\r\n\r\nconst SectionTitle = styled.h3`\r\n  color: white;\r\n  text-align: center;\r\n  margin: 0 0 15px 0;\r\n  font-size: 1.3rem;\r\n  font-weight: 600;\r\n  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\r\n`;\r\n\r\nconst ButtonGrid = styled.div`\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\r\n  gap: 15px;\r\n  margin-bottom: 20px;\r\n`;\r\n\r\nconst IdentifyButton = styled.button`\r\n  padding: 12px 16px;\r\n  border: 2px solid ${props => {\r\n    if (props.$isActive) return '#4CAF50';\r\n    if (props.$hasIncorrect) return '#ff4757';\r\n    return 'rgba(255, 255, 255, 0.3)';\r\n  }};\r\n  border-radius: 10px;\r\n  font-size: 14px;\r\n  font-weight: 600;\r\n  cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};\r\n  transition: all 0.3s ease;\r\n  background: ${props => {\r\n    if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\r\n    if (props.$isActive) return 'rgba(76, 175, 80, 0.2)';\r\n    if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.2)';\r\n    return 'rgba(255, 255, 255, 0.1)';\r\n  }};\r\n  color: ${props => {\r\n    if (props.disabled) return '#666';\r\n    if (props.$isActive) return '#4CAF50';\r\n    if (props.$hasIncorrect) return '#ff4757';\r\n    return 'white';\r\n  }};\r\n  opacity: ${props => props.disabled ? 0.5 : 1};\r\n  \r\n  &:hover {\r\n    transform: ${props => props.disabled ? 'none' : 'translateY(-2px)'};\r\n    box-shadow: ${props => props.disabled ? 'none' : '0 4px 12px rgba(0, 0, 0, 0.3)'};\r\n    background: ${props => {\r\n      if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\r\n      if (props.$isActive) return 'rgba(76, 175, 80, 0.3)';\r\n      if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.3)';\r\n      return 'rgba(255, 255, 255, 0.2)';\r\n    }};\r\n  }\r\n  \r\n  &:active {\r\n    transform: ${props => props.disabled ? 'none' : 'translateY(0)'};\r\n  }\r\n`;\r\n\r\nconst ButtonContent = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  gap: 4px;\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n`;\r\n\r\nconst ShapeContainer = styled.div`\r\n  width: 60px;\r\n  height: 60px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  position: relative;\r\n  margin: 8px 0;\r\n`;\r\n\r\nconst ShapeVisual = styled.div`\r\n  width: 50px;\r\n  height: 50px;\r\n  background: ${props => props.$shapeColor};\r\n  border: 3px solid ${props => props.$borderColor};\r\n  position: relative;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  \r\n  /* Shape-specific styling */\r\n  border-radius: ${props => {\r\n    if (props.$shapeType === 'Circle') return '50%';\r\n    if (props.$shapeType === 'Diamond') return '0';\r\n    return '0';\r\n  }};\r\n  \r\n  transform: ${props => {\r\n    if (props.$shapeType === 'Diamond') return 'rotate(45deg)';\r\n    return 'none';\r\n  }};\r\n  \r\n  /* Triangle shape using CSS */\r\n  ${props => props.$shapeType === 'Triangle' && `\r\n    width: 0;\r\n    height: 0;\r\n    background: transparent;\r\n    border: none;\r\n    border-left: 25px solid transparent;\r\n    border-right: 25px solid transparent;\r\n    border-bottom: 43px solid ${props.$shapeColor};\r\n    position: relative;\r\n  `}\r\n`;\r\n\r\nconst CountBadge = styled.span`\r\n  background: ${props => props.$hasIncorrect ? '#ff4757' : '#4CAF50'};\r\n  color: white;\r\n  border-radius: 50%;\r\n  width: 20px;\r\n  height: 20px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  font-size: 10px;\r\n  font-weight: bold;\r\n  position: absolute;\r\n  top: -5px;\r\n  right: -5px;\r\n  z-index: 10;\r\n`;\r\n\r\nconst ButtonTitle = styled.span`\r\n  font-size: 12px;\r\n  font-weight: 600;\r\n  color: white;\r\n  text-align: center;\r\n  margin-top: 4px;\r\n`;\r\n\r\nconst ButtonSubtitle = styled.div`\r\n  font-size: 10px;\r\n  color: rgba(255, 255, 255, 0.8);\r\n  text-align: center;\r\n  margin-top: 2px;\r\n  line-height: 1.2;\r\n`;\r\n\r\nconst Instructions = styled.p`\r\n  color: rgba(255, 255, 255, 0.8);\r\n  font-size: 13px;\r\n  text-align: center;\r\n  margin: 0 0 15px 0;\r\n  line-height: 1.4;\r\n`;\r\n\r\nconst StatusMessage = styled.div`\r\n  padding: 10px;\r\n  border-radius: 8px;\r\n  text-align: center;\r\n  font-size: 12px;\r\n  font-weight: 600;\r\n  background: ${props => {\r\n    if (props.$type === 'success') return 'rgba(76, 175, 80, 0.2)';\r\n    if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.2)';\r\n    if (props.$type === 'error') return 'rgba(244, 67, 54, 0.2)';\r\n    return 'rgba(33, 150, 243, 0.2)';\r\n  }};\r\n  color: ${props => {\r\n    if (props.$type === 'success') return '#4CAF50';\r\n    if (props.$type === 'warning') return '#FFC107';\r\n    if (props.$type === 'error') return '#f44336';\r\n    return '#2196F3';\r\n  }};\r\n  border: 1px solid ${props => {\r\n    if (props.$type === 'success') return 'rgba(76, 175, 80, 0.3)';\r\n    if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.3)';\r\n    if (props.$type === 'error') return 'rgba(244, 67, 54, 0.3)';\r\n    return 'rgba(33, 150, 243, 0.3)';\r\n  }};\r\n`;\r\n\r\n// Custom logging function\r\nconst logToTerminal = (message, data = null) => {\r\n  console.log(`\\nðŸŽ¯ ${message}`);\r\n  if (data) {\r\n    console.log(JSON.stringify(data, null, 2));\r\n  }\r\n  console.log('='.repeat(80) + '\\n');\r\n  \r\n  // Try to send to log server, but don't fail if it's not available\r\n  const sendToLogServer = async () => {\r\n    try {\r\n      const response = await fetch('http://localhost:3001/log', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          message: message,\r\n          data: data\r\n        }),\r\n        // Add timeout to prevent hanging\r\n        signal: AbortSignal.timeout(1000)\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      console.log('âœ… Log sent to terminal successfully');\r\n    } catch (error) {\r\n      // Silently fail - logging server is optional\r\n      console.log('ðŸ’¡ Log server not available - logging to console only');\r\n    }\r\n  };\r\n  \r\n  // Execute without blocking\r\n  sendToLogServer();\r\n};\r\n\r\nfunction IdentifyIncorrectShapes({ isScrambling, cubeState, onIdentification, setCubeState }) {\r\n  const [activeIdentification, setActiveIdentification] = useState(null);\r\n  const [identificationResults, setIdentificationResults] = useState({});\r\n\r\n  if (!cubeState) {\r\n    console.log('ðŸš¨ SHOWING LOADING MESSAGE - no cubeState');\r\n    return (\r\n      <IdentifyContainer>\r\n        <SectionTitle>Identify Incorrect Shapes</SectionTitle>\r\n        <StatusMessage $type=\"warning\">\r\n          Loading cube state... Please scramble the cube first to identify incorrect shapes.\r\n        </StatusMessage>\r\n      </IdentifyContainer>\r\n    );\r\n  }\r\n\r\n  // Helper functions\r\n  const getShapeType = (pieceId) => {\r\n    const shapeTypes = [\r\n      'Square', 'Square', 'Square', 'Square', 'Square',\r\n      'Circle', 'Circle', 'Circle', 'Circle', 'Circle',\r\n      'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Diamond',\r\n      'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Diamond',\r\n      'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle'\r\n    ];\r\n    return shapeTypes[pieceId] || 'Unknown';\r\n  };\r\n\r\n  const getShapeColor = (pieceId) => {\r\n    const shapeColors = [\r\n      'Red', 'Blue', 'Green', 'Orange', 'Purple',\r\n      'Red', 'Blue', 'Green', 'Orange', 'Yellow',\r\n      'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple',\r\n      'Red', 'Blue', 'Green', 'Orange', 'Purple',\r\n      'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple', 'Yellow'\r\n    ];\r\n    return shapeColors[pieceId] || 'Unknown';\r\n  };\r\n\r\n  const getExpectedPosition = (pieceId) => {\r\n    const positions = [];\r\n    for (let x = -1; x <= 1; x++) {\r\n      for (let y = -1; y <= 1; y++) {\r\n        for (let z = -1; z <= 1; z++) {\r\n          if (x === 0 && y === 0 && z === 0) continue;\r\n          positions.push([x, y, z]);\r\n        }\r\n      }\r\n    }\r\n    return positions[pieceId];\r\n  };\r\n\r\n  const isPieceInCorrectPosition = (piece, pieceId) => {\r\n    if (!piece || !piece.position) return false;\r\n    const expectedPosition = getExpectedPosition(pieceId);\r\n    return JSON.stringify(piece.position) === JSON.stringify(expectedPosition);\r\n  };\r\n\r\n  const getExpectedBorderColor = (faceIndex) => {\r\n    const borderColors = [\r\n      '#FFFFFF', // Face 0 (front) - White\r\n      '#FF8C00', // Face 1 (back) - Orange  \r\n      '#00FF00', // Face 2 (right) - Green\r\n      '#DC143C', // Face 3 (left) - Red\r\n      '#0000FF', // Face 4 (top) - Blue\r\n      '#FFD700'  // Face 5 (bottom) - Yellow\r\n    ];\r\n    return borderColors[faceIndex] || '#000000';\r\n  };\r\n\r\n  const getBorderColorName = (faceIndex) => {\r\n    const colorNames = ['White', 'Orange', 'Green', 'Red', 'Blue', 'Yellow'];\r\n    return colorNames[faceIndex] || 'Unknown';\r\n  };\r\n\r\n  const getShapeColorHex = (shapeColor) => {\r\n    const colorMap = {\r\n      'Red': '#DC143C',\r\n      'Blue': '#0000FF',\r\n      'Green': '#00FF00',\r\n      'Orange': '#FF8C00',\r\n      'Purple': '#800080',\r\n      'Yellow': '#FFD700',\r\n      'Cyan': '#00FFFF',\r\n      'Magenta': '#FF00FF',\r\n      'Lime': '#00FF00',\r\n      'Pink': '#FFC0CB'\r\n    };\r\n    return colorMap[shapeColor] || '#000000';\r\n  };\r\n\r\n  // Function to validate that starting colors are properly outward-facing\r\n  const validateColorOrientation = () => {\r\n    logToTerminal('ðŸŽ¨ ========== STARTING COLOR ORIENTATION VALIDATION ==========');\r\n    \r\n    if (!cubeState || cubeState.length === 0) {\r\n      logToTerminal('ðŸŽ¨ âŒ No cube state available for color orientation validation');\r\n      return {\r\n        type: 'colorOrientation',\r\n        incorrectPieces: [],\r\n        count: 0,\r\n        totalIncorrectFaces: 0\r\n      };\r\n    }\r\n\r\n    logToTerminal('ðŸŽ¨ âœ… Cube state available, validating starting colors are outward-facing for', cubeState.length, 'pieces...');\r\n    \r\n    const incorrectPieces = [];\r\n    let totalIncorrectFaces = 0;\r\n    let piecesChecked = 0;\r\n\r\n    cubeState.forEach((piece, index) => {\r\n      piecesChecked++;\r\n      const pieceId = piece.pieceId || index;\r\n      \r\n      if (!Array.isArray(piece.position) || !piece.colors || typeof piece.colors !== 'object') {\r\n        logToTerminal(`ðŸŽ¨ âŒ Piece ${pieceId} has invalid position or colors`);\r\n        return;\r\n      }\r\n      \r\n      const [x, y, z] = piece.position;\r\n      \r\n      // Determine which faces should be visible based on current position\r\n      const shouldBeVisible = {\r\n        front: z === 1,\r\n        back: z === -1,\r\n        right: x === 1,\r\n        left: x === -1,\r\n        top: y === 1,\r\n        bottom: y === -1\r\n      };\r\n      \r\n      const incorrectFaces = [];\r\n      \r\n      // Check if visible faces have proper colors (not black/gray)\r\n      Object.keys(shouldBeVisible).forEach(face => {\r\n        if (shouldBeVisible[face]) {\r\n          const faceColor = piece.colors[face];\r\n          \r\n          // Check if the visible face has a proper color (not black/gray)\r\n          if (faceColor === '#444444' || faceColor === 'black' || faceColor === '#000000') {\r\n            incorrectFaces.push({\r\n              face: face,\r\n              currentColor: faceColor,\r\n              issue: 'Visible face is black/gray - starting color should be outward-facing'\r\n            });\r\n            totalIncorrectFaces++;\r\n            logToTerminal(`ðŸŽ¨ âŒ Piece ${pieceId} has black/gray ${face} face: ${faceColor} (should have starting color outward-facing)`);\r\n          } else {\r\n            logToTerminal(`ðŸŽ¨ âœ… Piece ${pieceId} ${face} face has proper color: ${faceColor}`);\r\n          }\r\n        }\r\n      });\r\n      \r\n      if (incorrectFaces.length > 0) {\r\n        incorrectPieces.push({\r\n          pieceId: pieceId,\r\n          currentPosition: piece.position,\r\n          startingColors: piece.startingColors,\r\n          incorrectFaces: incorrectFaces\r\n        });\r\n        logToTerminal(`ðŸŽ¨ âœ… Added piece ${pieceId} to incorrect pieces with ${incorrectFaces.length} incorrect faces`);\r\n      }\r\n    });\r\n\r\n    logToTerminal('ðŸŽ¨ ========== STARTING COLOR ORIENTATION VALIDATION SUMMARY ==========');\r\n    logToTerminal('ðŸŽ¨ Total pieces checked:', piecesChecked);\r\n    logToTerminal('ðŸŽ¨ Pieces with incorrect color orientation:', incorrectPieces.length);\r\n    logToTerminal('ðŸŽ¨ Total incorrect faces found:', totalIncorrectFaces);\r\n\r\n    const result = {\r\n      type: 'colorOrientation',\r\n      incorrectPieces: incorrectPieces,\r\n      count: incorrectPieces.length,\r\n      totalIncorrectFaces: totalIncorrectFaces\r\n    };\r\n    \r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      'colorOrientation': result\r\n    }));\r\n\r\n    return result;\r\n  };\r\n\r\n  // Function to get expected color for a face\r\n  const getExpectedColorForFace = (face) => {\r\n    const colorMap = {\r\n      front: 'white',\r\n      back: 'yellow',\r\n      right: 'red',\r\n      left: 'orange',\r\n      top: 'blue',\r\n      bottom: 'green'\r\n    };\r\n    return colorMap[face] || '#444444';\r\n  };\r\n\r\n  // Get pieces data\r\n  const getPieces = () => {\r\n    if (Array.isArray(cubeState)) {\r\n      return cubeState.map((piece, index) => ({\r\n        pieceId: index,\r\n        position: piece.position,\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory || []\r\n      }));\r\n    } else if (cubeState?.pieces) {\r\n      return cubeState.pieces;\r\n    }\r\n    return [];\r\n  };\r\n\r\n  const pieces = getPieces();\r\n\r\n  // Identify incorrect shapes by type\r\n  const identifyIncorrectShapesByType = (shapeType) => {\r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const actualShapeType = getShapeType(pieceId);\r\n      return actualShapeType === shapeType && !isPieceInCorrectPosition(piece, pieceId);\r\n    });\r\n\r\n    const result = {\r\n      type: 'shape',\r\n      shapeType,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`shape-${shapeType}`]: result\r\n    }));\r\n\r\n    logToTerminal(`ðŸ” IDENTIFIED INCORRECT ${shapeType.toUpperCase()} SHAPES`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  // Identify incorrect shapes by color\r\n  const identifyIncorrectShapesByColor = (shapeColor) => {\r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const actualShapeColor = getShapeColor(pieceId);\r\n      return actualShapeColor === shapeColor && !isPieceInCorrectPosition(piece, pieceId);\r\n    });\r\n\r\n    const result = {\r\n      type: 'color',\r\n      shapeColor,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`color-${shapeColor}`]: result\r\n    }));\r\n\r\n    logToTerminal(`ðŸŽ¨ IDENTIFIED INCORRECT ${shapeColor.toUpperCase()} SHAPES`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  // Identify incorrect border colors\r\n  const identifyIncorrectBorderColors = (faceIndex) => {\r\n    const borderColorName = getBorderColorName(faceIndex);\r\n    const borderColorHex = getExpectedBorderColor(faceIndex);\r\n    \r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\r\n      \r\n      // Check if this piece should have this border color in its current position\r\n      const [x, y, z] = piece.position;\r\n      let shouldHaveBorderColor = false;\r\n      \r\n      switch (faceIndex) {\r\n        case 0: // Front face (Z+) - White\r\n          shouldHaveBorderColor = z === 1;\r\n          break;\r\n        case 1: // Back face (Z-) - Orange\r\n          shouldHaveBorderColor = z === -1;\r\n          break;\r\n        case 2: // Right face (X+) - Green\r\n          shouldHaveBorderColor = x === 1;\r\n          break;\r\n        case 3: // Left face (X-) - Red\r\n          shouldHaveBorderColor = x === -1;\r\n          break;\r\n        case 4: // Top face (Y+) - Blue\r\n          shouldHaveBorderColor = y === 1;\r\n          break;\r\n        case 5: // Bottom face (Y-) - Yellow\r\n          shouldHaveBorderColor = y === -1;\r\n          break;\r\n      }\r\n      \r\n      // Piece is incorrect if it should have this border color but is not in correct position\r\n      return shouldHaveBorderColor && !isInCorrectPosition;\r\n    });\r\n\r\n    const result = {\r\n      type: 'border',\r\n      faceIndex,\r\n      borderColorName,\r\n      borderColorHex,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`border-${faceIndex}`]: result\r\n    }));\r\n\r\n    logToTerminal(`ðŸŽ­ IDENTIFIED INCORRECT ${borderColorName.toUpperCase()} BORDER COLORS`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  // Identify pieces with black faces that should be visible\r\n  const identifyPiecesWithBlackFaces = () => {\r\n    logToTerminal('ðŸ” ========== STARTING BLACK FACES IDENTIFICATION ==========');\r\n    logToTerminal('ðŸ” cubeState type:', typeof cubeState);\r\n    logToTerminal('ðŸ” cubeState length:', cubeState ? cubeState.length : 'null');\r\n    logToTerminal('ðŸ” cubeState is null:', cubeState === null);\r\n    logToTerminal('ðŸ” cubeState is undefined:', cubeState === undefined);\r\n    \r\n    if (!cubeState || cubeState.length === 0) {\r\n      logToTerminal('ðŸ” âŒ No cube state available for identification');\r\n      return {\r\n        type: 'blackFaces',\r\n        incorrectPieces: [],\r\n        count: 0,\r\n        totalBlackFaces: 0\r\n      };\r\n    }\r\n\r\n    logToTerminal('ðŸ” âœ… Cube state available, checking', cubeState.length, 'pieces...');\r\n    \r\n    const incorrectPieces = [];\r\n    let totalBlackFaces = 0;\r\n    let piecesChecked = 0;\r\n    let piecesWithColors = 0;\r\n    let piecesWithPosition = 0;\r\n\r\n    // Log detailed structure of first few pieces\r\n    logToTerminal('ðŸ” ========== PIECE STRUCTURE ANALYSIS ==========');\r\n    cubeState.slice(0, 5).forEach((piece, index) => {\r\n      logToTerminal(`ðŸ” Piece ${index}:`, {\r\n        pieceId: piece.pieceId,\r\n        hasPosition: Array.isArray(piece.position),\r\n        position: piece.position,\r\n        hasColors: typeof piece.colors === 'object' && piece.colors !== null,\r\n        colors: piece.colors,\r\n        allKeys: Object.keys(piece)\r\n      });\r\n    });\r\n\r\n    logToTerminal('ðŸ” ========== CHECKING ALL PIECES ==========');\r\n    \r\n    cubeState.forEach((piece, index) => {\r\n      piecesChecked++;\r\n      const pieceId = piece.pieceId || index;\r\n      \r\n      // Check if piece has position\r\n      if (!Array.isArray(piece.position)) {\r\n        logToTerminal(`ðŸ” âŒ Piece ${pieceId} has invalid position:`, piece.position);\r\n        return;\r\n      }\r\n      piecesWithPosition++;\r\n      \r\n      // Check if piece has colors\r\n      if (!piece.colors || typeof piece.colors !== 'object') {\r\n        logToTerminal(`ðŸ” âŒ Piece ${pieceId} has invalid colors:`, piece.colors);\r\n        return;\r\n      }\r\n      piecesWithColors++;\r\n      \r\n      const [x, y, z] = piece.position;\r\n      \r\n      logToTerminal(`ðŸ” Checking piece ${pieceId} at position [${x}, ${y}, ${z}]`);\r\n      logToTerminal(`ðŸ” Piece colors object:`, piece.colors);\r\n      logToTerminal(`ðŸ” Color keys:`, Object.keys(piece.colors));\r\n      \r\n      // Determine which faces should be visible based on current position\r\n      const visibleFaces = [];\r\n      if (x === 1) visibleFaces.push('right');\r\n      if (x === -1) visibleFaces.push('left');\r\n      if (y === 1) visibleFaces.push('top');\r\n      if (y === -1) visibleFaces.push('bottom');\r\n      if (z === 1) visibleFaces.push('front');\r\n      if (z === -1) visibleFaces.push('back');\r\n      \r\n      logToTerminal(`ðŸ” Visible faces for piece ${pieceId}:`, visibleFaces);\r\n      \r\n      // Check if any visible faces are black/gray\r\n      const blackVisibleFaces = [];\r\n      visibleFaces.forEach(face => {\r\n        const faceColor = piece.colors[face];\r\n        logToTerminal(`ðŸ” Face ${face} color: \"${faceColor}\" (type: ${typeof faceColor})`);\r\n        \r\n        // Check for both #444444 and 'black' values\r\n        if (faceColor === '#444444' || faceColor === 'black' || faceColor === '#000000') {\r\n          blackVisibleFaces.push(face);\r\n          totalBlackFaces++;\r\n          logToTerminal(`ðŸ” âœ… FOUND BLACK/GRAY FACE: ${face} on piece ${pieceId} with color \"${faceColor}\"`);\r\n        } else {\r\n          logToTerminal(`ðŸ” Face ${face} is not black/gray (color: \"${faceColor}\")`);\r\n        }\r\n      });\r\n      \r\n      if (blackVisibleFaces.length > 0) {\r\n        incorrectPieces.push({\r\n          pieceId: pieceId,\r\n          currentPosition: piece.position,\r\n          blackVisibleFaces: blackVisibleFaces\r\n        });\r\n        logToTerminal(`ðŸ” âœ… Added piece ${pieceId} to incorrect pieces with ${blackVisibleFaces.length} black faces:`, blackVisibleFaces);\r\n      } else {\r\n        logToTerminal(`ðŸ” Piece ${pieceId} has no black visible faces`);\r\n      }\r\n    });\r\n\r\n    logToTerminal('ðŸ” ========== IDENTIFICATION SUMMARY ==========');\r\n    logToTerminal('ðŸ” Total pieces checked:', piecesChecked);\r\n    logToTerminal('ðŸ” Pieces with valid position:', piecesWithPosition);\r\n    logToTerminal('ðŸ” Pieces with valid colors:', piecesWithColors);\r\n    logToTerminal('ðŸ” Pieces with black faces:', incorrectPieces.length);\r\n    logToTerminal('ðŸ” Total black faces found:', totalBlackFaces);\r\n    logToTerminal('ðŸ” Incorrect pieces details:', incorrectPieces);\r\n\r\n    const result = {\r\n      type: 'blackFaces',\r\n      incorrectPieces: incorrectPieces,\r\n      count: incorrectPieces.length,\r\n      totalBlackFaces: totalBlackFaces\r\n    };\r\n    \r\n    logToTerminal('ðŸ” ========== RETURNING RESULT ==========');\r\n    logToTerminal('ðŸ” Result:', result);\r\n    \r\n    setIdentificationResults(prev => {\r\n      const newResults = {\r\n        ...prev,\r\n        'blackFaces': result\r\n      };\r\n      logToTerminal('ðŸ”§ UPDATING identificationResults:', newResults);\r\n      return newResults;\r\n    });\r\n\r\n    return result;\r\n  };\r\n\r\n  const handleButtonClick = (type, identifier) => {\r\n    if (isScrambling) return;\r\n\r\n    setActiveIdentification(`${type}-${identifier}`);\r\n\r\n    let result;\r\n    switch (type) {\r\n      case 'shape':\r\n        result = identifyIncorrectShapesByType(identifier);\r\n        break;\r\n      case 'color':\r\n        result = identifyIncorrectShapesByColor(identifier);\r\n        break;\r\n      case 'border':\r\n        result = identifyIncorrectBorderColors(identifier);\r\n        break;\r\n      case 'blackFaces':\r\n        result = identifyPiecesWithBlackFaces();\r\n        break;\r\n      case 'colorOrientation':\r\n        result = validateColorOrientation();\r\n        break;\r\n    }\r\n\r\n    // Reset active state after a short delay\r\n    setTimeout(() => {\r\n      setActiveIdentification(null);\r\n    }, 2000);\r\n  };\r\n\r\n  const handleFindAndFixGrayFaces = () => {\r\n    logToTerminal('ðŸ”§ FIND AND FIX GRAY FACES BUTTON CLICKED!');\r\n    logToTerminal('ðŸ”§ isScrambling:', isScrambling);\r\n    \r\n    if (isScrambling) {\r\n      logToTerminal('ðŸ”§ Button disabled - cube is scrambling');\r\n      return;\r\n    }\r\n\r\n    // First identify the pieces with black faces\r\n    const blackFacesResult = identifyPiecesWithBlackFaces();\r\n    \r\n    if (blackFacesResult.count === 0) {\r\n      logToTerminal('No gray faces to fix');\r\n      return;\r\n    }\r\n\r\n    logToTerminal('ðŸ”§ FOUND AND FIXING GRAY FACES:', blackFacesResult.incorrectPieces.length, 'pieces');\r\n    logToTerminal('ðŸ”§ Pieces to fix:', blackFacesResult.incorrectPieces.map(p => `${p.pieceId} at [${p.currentPosition.join(', ')}]`));\r\n\r\n    // Update the cube state to fix the colors using CubeStateManager\r\n    if (typeof window !== 'undefined' && window.CubeStateManager) {\r\n      logToTerminal('ðŸ”§ Using CubeStateManager to update cube state');\r\n      // Get current state without triggering reinitialization\r\n      const currentState = window.CubeStateManager.state || cubeState;\r\n      logToTerminal('ðŸ”§ Current state length:', currentState.length);\r\n      \r\n      window.CubeStateManager.setState(prevState => {\r\n        logToTerminal('ðŸ”§ CubeStateManager setState called with prevState length:', prevState.length);\r\n        const newState = [...prevState];\r\n        \r\n        blackFacesResult.incorrectPieces.forEach(incorrectPiece => {\r\n          logToTerminal(`ðŸ”§ Processing piece ${incorrectPiece.pieceId}...`);\r\n          const pieceIndex = newState.findIndex(p => p.pieceId === incorrectPiece.pieceId);\r\n          logToTerminal(`ðŸ”§ Found piece at index ${pieceIndex}`);\r\n          \r\n          if (pieceIndex !== -1) {\r\n            const piece = newState[pieceIndex];\r\n            const [x, y, z] = piece.position;\r\n            logToTerminal(`ðŸ”§ Piece ${piece.pieceId} at position [${x}, ${y}, ${z}]`);\r\n            logToTerminal(`ðŸ”§ Current colors:`, piece.colors);\r\n            \r\n            // Determine which faces should be visible based on current position\r\n            const visibleFaces = [];\r\n            if (x === 1) visibleFaces.push('right');\r\n            if (x === -1) visibleFaces.push('left');\r\n            if (y === 1) visibleFaces.push('top');\r\n            if (y === -1) visibleFaces.push('bottom');\r\n            if (z === 1) visibleFaces.push('front');\r\n            if (z === -1) visibleFaces.push('back');\r\n            \r\n            logToTerminal(`ðŸ”§ Visible faces:`, visibleFaces);\r\n            \r\n            // Fix the colors for visible faces that are currently black/gray\r\n            const updatedColors = { ...piece.colors };\r\n            let fixedAny = false;\r\n            \r\n            visibleFaces.forEach(face => {\r\n              logToTerminal(`ðŸ”§ Checking face ${face}: current color = ${updatedColors[face]}`);\r\n              if (updatedColors[face] === '#444444' || updatedColors[face] === 'black' || updatedColors[face] === '#000000') {\r\n                // Set the correct color based on the face\r\n                switch (face) {\r\n                  case 'front':\r\n                    updatedColors[face] = '#FFFFFF'; // White\r\n                    break;\r\n                  case 'back':\r\n                    updatedColors[face] = '#FFD700'; // Yellow\r\n                    break;\r\n                  case 'right':\r\n                    updatedColors[face] = '#DC143C'; // Red\r\n                    break;\r\n                  case 'left':\r\n                    updatedColors[face] = '#FF8C00'; // Orange\r\n                    break;\r\n                  case 'top':\r\n                    updatedColors[face] = '#0000FF'; // Blue\r\n                    break;\r\n                  case 'bottom':\r\n                    updatedColors[face] = '#00FF00'; // Green\r\n                    break;\r\n                }\r\n                logToTerminal(`ðŸ”§ Fixed face ${face} to ${updatedColors[face]}`);\r\n                fixedAny = true;\r\n              }\r\n            });\r\n            \r\n            if (fixedAny) {\r\n              newState[pieceIndex] = {\r\n                ...piece,\r\n                colors: updatedColors\r\n              };\r\n              logToTerminal(`ðŸ”§ Updated piece ${piece.pieceId} with new colors:`, updatedColors);\r\n            } else {\r\n              logToTerminal(`ðŸ”§ No changes needed for piece ${piece.pieceId}`);\r\n            }\r\n          } else {\r\n            logToTerminal(`ðŸ”§ ERROR: Could not find piece ${incorrectPiece.pieceId} in cube state`);\r\n          }\r\n        });\r\n        \r\n        logToTerminal('âœ… Gray faces find and fix completed!');\r\n        logToTerminal('ðŸ”§ New state length:', newState.length);\r\n        return newState;\r\n      });\r\n    } else {\r\n      // Fallback to the passed setCubeState function\r\n      logToTerminal('ðŸ”§ Using fallback setCubeState method');\r\n      setCubeState(prevState => {\r\n        logToTerminal('ðŸ”§ setCubeState called with prevState length:', prevState.length);\r\n        const newState = [...prevState];\r\n        \r\n        blackFacesResult.incorrectPieces.forEach(incorrectPiece => {\r\n          logToTerminal(`ðŸ”§ Processing piece ${incorrectPiece.pieceId}...`);\r\n          const pieceIndex = newState.findIndex(p => p.pieceId === incorrectPiece.pieceId);\r\n          logToTerminal(`ðŸ”§ Found piece at index ${pieceIndex}`);\r\n          \r\n          if (pieceIndex !== -1) {\r\n            const piece = newState[pieceIndex];\r\n            const [x, y, z] = piece.position;\r\n            logToTerminal(`ðŸ”§ Piece ${piece.pieceId} at position [${x}, ${y}, ${z}]`);\r\n            logToTerminal(`ðŸ”§ Current colors:`, piece.colors);\r\n            \r\n            // Determine which faces should be visible based on current position\r\n            const visibleFaces = [];\r\n            if (x === 1) visibleFaces.push('right');\r\n            if (x === -1) visibleFaces.push('left');\r\n            if (y === 1) visibleFaces.push('top');\r\n            if (y === -1) visibleFaces.push('bottom');\r\n            if (z === 1) visibleFaces.push('front');\r\n            if (z === -1) visibleFaces.push('back');\r\n            \r\n            logToTerminal(`ðŸ”§ Visible faces:`, visibleFaces);\r\n            \r\n            // Fix the colors for visible faces that are currently black/gray\r\n            const updatedColors = { ...piece.colors };\r\n            let fixedAny = false;\r\n            \r\n            visibleFaces.forEach(face => {\r\n              logToTerminal(`ðŸ”§ Checking face ${face}: current color = ${updatedColors[face]}`);\r\n              if (updatedColors[face] === '#444444' || updatedColors[face] === 'black' || updatedColors[face] === '#000000') {\r\n                // Set the correct color based on the face\r\n                switch (face) {\r\n                  case 'front':\r\n                    updatedColors[face] = '#FFFFFF'; // White\r\n                    break;\r\n                  case 'back':\r\n                    updatedColors[face] = '#FFD700'; // Yellow\r\n                    break;\r\n                  case 'right':\r\n                    updatedColors[face] = '#DC143C'; // Red\r\n                    break;\r\n                  case 'left':\r\n                    updatedColors[face] = '#FF8C00'; // Orange\r\n                    break;\r\n                  case 'top':\r\n                    updatedColors[face] = '#0000FF'; // Blue\r\n                    break;\r\n                  case 'bottom':\r\n                    updatedColors[face] = '#00FF00'; // Green\r\n                    break;\r\n                }\r\n                logToTerminal(`ðŸ”§ Fixed face ${face} to ${updatedColors[face]}`);\r\n                fixedAny = true;\r\n              }\r\n            });\r\n            \r\n            if (fixedAny) {\r\n              newState[pieceIndex] = {\r\n                ...piece,\r\n                colors: updatedColors\r\n              };\r\n              logToTerminal(`ðŸ”§ Updated piece ${piece.pieceId} with new colors:`, updatedColors);\r\n            } else {\r\n              logToTerminal(`ðŸ”§ No changes needed for piece ${piece.pieceId}`);\r\n            }\r\n          } else {\r\n            logToTerminal(`ðŸ”§ ERROR: Could not find piece ${incorrectPiece.pieceId} in cube state`);\r\n          }\r\n        });\r\n        \r\n        logToTerminal('âœ… Gray faces find and fix completed!');\r\n        logToTerminal('ðŸ”§ New state length:', newState.length);\r\n        return newState;\r\n      });\r\n    }\r\n\r\n    // Clear the identification results since we've fixed the issue\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      blackFaces: null\r\n    }));\r\n\r\n    // Clear the highlighting by calling onIdentification with empty result\r\n    if (onIdentification) {\r\n      onIdentification({\r\n        type: 'blackFaces',\r\n        count: 0,\r\n        totalBlackFaces: 0,\r\n        incorrectPieces: []\r\n      });\r\n    }\r\n  };\r\n\r\n  const getButtonState = (type, identifier) => {\r\n    const key = `${type}-${identifier}`;\r\n    const result = identificationResults[key];\r\n    const isActive = activeIdentification === key;\r\n    \r\n    return {\r\n      isActive,\r\n      hasIncorrect: result && result.count > 0,\r\n      count: result ? result.count : 0\r\n    };\r\n  };\r\n\r\n  // Generate all possible combinations of shape+color+border\r\n  const generateCombinations = () => {\r\n    const shapeTypes = ['Square', 'Circle', 'Triangle', 'Diamond'];\r\n    const shapeColors = ['Red', 'Blue', 'Green', 'Orange', 'Purple', 'Yellow', 'Cyan', 'Magenta', 'Lime', 'Pink'];\r\n    const borderColors = [\r\n      { name: 'White', hex: '#FFFFFF', faceIndex: 0 },\r\n      { name: 'Orange', hex: '#FF8C00', faceIndex: 1 },\r\n      { name: 'Green', hex: '#00FF00', faceIndex: 2 },\r\n      { name: 'Red', hex: '#DC143C', faceIndex: 3 },\r\n      { name: 'Blue', hex: '#0000FF', faceIndex: 4 },\r\n      { name: 'Yellow', hex: '#FFD700', faceIndex: 5 }\r\n    ];\r\n\r\n    const combinations = [];\r\n    shapeTypes.forEach(shapeType => {\r\n      shapeColors.forEach(shapeColor => {\r\n        borderColors.forEach(borderColor => {\r\n          combinations.push({\r\n            id: `${shapeType}-${shapeColor}-${borderColor.name}`,\r\n            shapeType,\r\n            shapeColor,\r\n            borderColor: borderColor.name,\r\n            borderColorHex: borderColor.hex,\r\n            faceIndex: borderColor.faceIndex\r\n          });\r\n        });\r\n      });\r\n    });\r\n    return combinations;\r\n  };\r\n\r\n  // Identify incorrect pieces by combination\r\n  const identifyIncorrectCombination = (combination) => {\r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const actualShapeType = getShapeType(pieceId);\r\n      const actualShapeColor = getShapeColor(pieceId);\r\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\r\n      \r\n      // Check if this piece matches the combination\r\n      const matchesShape = actualShapeType === combination.shapeType;\r\n      const matchesColor = actualShapeColor === combination.shapeColor;\r\n      \r\n      // Check if this piece should have this border color in its current position\r\n      const [x, y, z] = piece.position;\r\n      let shouldHaveBorderColor = false;\r\n      \r\n      switch (combination.faceIndex) {\r\n        case 0: // Front face (Z+) - White\r\n          shouldHaveBorderColor = z === 1;\r\n          break;\r\n        case 1: // Back face (Z-) - Orange\r\n          shouldHaveBorderColor = z === -1;\r\n          break;\r\n        case 2: // Right face (X+) - Green\r\n          shouldHaveBorderColor = x === 1;\r\n          break;\r\n        case 3: // Left face (X-) - Red\r\n          shouldHaveBorderColor = x === -1;\r\n          break;\r\n        case 4: // Top face (Y+) - Blue\r\n          shouldHaveBorderColor = y === 1;\r\n          break;\r\n        case 5: // Bottom face (Y-) - Yellow\r\n          shouldHaveBorderColor = y === -1;\r\n          break;\r\n      }\r\n      \r\n      // Piece is incorrect if it matches the combination but is not in correct position\r\n      return matchesShape && matchesColor && shouldHaveBorderColor && !isInCorrectPosition;\r\n    });\r\n\r\n    const result = {\r\n      type: 'combination',\r\n      combination,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`combination-${combination.id}`]: result\r\n    }));\r\n\r\n    logToTerminal(`ðŸŽ¯ IDENTIFIED INCORRECT ${combination.shapeColor} ${combination.shapeType} with ${combination.borderColor} border`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  const handleCombinationClick = (combination) => {\r\n    if (isScrambling) return;\r\n\r\n    setActiveIdentification(`combination-${combination.id}`);\r\n    const result = identifyIncorrectCombination(combination);\r\n\r\n    // Reset active state after a short delay\r\n    setTimeout(() => {\r\n      setActiveIdentification(null);\r\n    }, 2000);\r\n  };\r\n\r\n  const getCombinationButtonState = (combination) => {\r\n    const key = `combination-${combination.id}`;\r\n    const result = identificationResults[key];\r\n    const isActive = activeIdentification === key;\r\n    \r\n    return {\r\n      isActive,\r\n      hasIncorrect: result && result.count > 0,\r\n      count: result ? result.count : 0\r\n    };\r\n  };\r\n\r\n  const combinations = generateCombinations();\r\n\r\n  return (\r\n    <IdentifyContainer>\r\n      <SectionTitle>Identify Incorrect Shapes</SectionTitle>\r\n      <Instructions>\r\n        Click any button below to identify pieces with that specific combination of shape+color+border that are in incorrect positions.\r\n        Buttons show the count of incorrect pieces found for each combination.\r\n      </Instructions>\r\n\r\n      {/* Color Orientation and Special Issues */}\r\n      <div>\r\n        <h4 style={{ color: 'white', marginBottom: '10px', fontSize: '16px' }}>Color Orientation & Special Issues</h4>\r\n        <ButtonGrid style={{ gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', marginBottom: '20px' }}>\r\n          {/* Color Orientation Validation Button */}\r\n          <IdentifyButton\r\n            onClick={() => handleButtonClick('colorOrientation', 'all')}\r\n            disabled={isScrambling}\r\n            $isActive={activeIdentification === 'colorOrientation-all'}\r\n            $hasIncorrect={identificationResults['colorOrientation'] && identificationResults['colorOrientation'].count > 0}\r\n            style={{\r\n              borderColor: '#9C27B0',\r\n              borderWidth: '3px',\r\n              background: 'rgba(156, 39, 176, 0.2)'\r\n            }}\r\n          >\r\n            <ButtonContent>\r\n              <div style={{ fontSize: '24px', marginBottom: '8px' }}>ðŸŽ¨</div>\r\n              <ButtonTitle style={{ color: '#9C27B0', fontWeight: 'bold' }}>\r\n                Color Orientation\r\n              </ButtonTitle>\r\n              <ButtonSubtitle>\r\n                Validate that all visible faces have correct colors\r\n              </ButtonSubtitle>\r\n              {identificationResults['colorOrientation'] && identificationResults['colorOrientation'].count > 0 && (\r\n                <CountBadge $hasIncorrect={true}>\r\n                  {identificationResults['colorOrientation'].count} pieces\r\n                  <br />\r\n                  {identificationResults['colorOrientation'].totalIncorrectFaces} faces\r\n                </CountBadge>\r\n              )}\r\n            </ButtonContent>\r\n          </IdentifyButton>\r\n          <IdentifyButton\r\n            onClick={() => handleButtonClick('blackFaces', 'all')}\r\n            disabled={isScrambling}\r\n            $isActive={activeIdentification === 'blackFaces-all'}\r\n            $hasIncorrect={identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0}\r\n            style={{\r\n              background: 'rgba(255, 0, 0, 0.2)',\r\n              borderColor: '#ff0000',\r\n              borderWidth: '3px',\r\n              display: 'none' // Hide the button but keep functionality\r\n            }}\r\n          >\r\n            <ButtonContent>\r\n              <div style={{ fontSize: '24px', marginBottom: '8px' }}>âš«</div>\r\n              <ButtonTitle style={{ color: '#ff0000', fontWeight: 'bold' }}>\r\n                Dark Gray Faces\r\n              </ButtonTitle>\r\n              <ButtonSubtitle>\r\n                Find pieces with dark gray faces (highlighted in pink)\r\n              </ButtonSubtitle>\r\n              {identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0 && (\r\n                <CountBadge $hasIncorrect={true}>\r\n                  {identificationResults['blackFaces'].count} pieces\r\n                  <br />\r\n                  {identificationResults['blackFaces'].totalBlackFaces} faces\r\n                </CountBadge>\r\n              )}\r\n            </ButtonContent>\r\n          </IdentifyButton>\r\n          \r\n          {/* Find and Fix Gray Faces Button */}\r\n          <IdentifyButton\r\n            onClick={() => {\r\n              logToTerminal('ðŸ”§ BUTTON CLICKED - onClick handler triggered');\r\n              logToTerminal('ðŸ”§ isScrambling:', isScrambling);\r\n              handleFindAndFixGrayFaces();\r\n            }}\r\n            disabled={isScrambling}\r\n            $isActive={false}\r\n            $hasIncorrect={false}\r\n            style={{\r\n              borderColor: '#FF6B6B',\r\n              borderWidth: '3px',\r\n              background: 'rgba(255, 107, 107, 0.2)'\r\n            }}\r\n          >\r\n            <ButtonContent>\r\n              <div style={{ fontSize: '24px', marginBottom: '8px' }}>ðŸ”§</div>\r\n              <ButtonTitle style={{ color: '#FF6B6B', fontWeight: 'bold' }}>\r\n                Find & Fix Gray Faces\r\n              </ButtonTitle>\r\n              <ButtonSubtitle>\r\n                Identify and automatically correct dark gray faces to proper colors\r\n              </ButtonSubtitle>\r\n            </ButtonContent>\r\n          </IdentifyButton>\r\n        </ButtonGrid>\r\n      </div>\r\n\r\n      {/* Combination Identification */}\r\n      <div>\r\n        <h4 style={{ color: 'white', marginBottom: '15px', fontSize: '16px' }}>By Shape + Color + Border Combinations</h4>\r\n        <ButtonGrid style={{ gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))' }}>\r\n          {combinations.map(combination => {\r\n            const state = getCombinationButtonState(combination);\r\n            \r\n            return (\r\n              <IdentifyButton\r\n                key={`combination-${combination.id}`}\r\n                onClick={() => handleCombinationClick(combination)}\r\n                disabled={isScrambling}\r\n                $isActive={state.isActive}\r\n                $hasIncorrect={state.hasIncorrect}\r\n                style={{\r\n                  borderColor: state.hasIncorrect ? '#ff4757' : combination.borderColorHex,\r\n                  borderWidth: '3px'\r\n                }}\r\n              >\r\n                <ButtonContent>\r\n                  <ShapeContainer>\r\n                    {combination.shapeType === 'Triangle' ? (\r\n                      <svg width=\"50\" height=\"50\" viewBox=\"0 0 50 50\">\r\n                        <polygon \r\n                          points=\"25,5 45,40 5,40\" \r\n                          fill={getShapeColorHex(combination.shapeColor)}\r\n                          stroke={combination.borderColorHex}\r\n                          strokeWidth=\"3\"\r\n                        />\r\n                      </svg>\r\n                    ) : (\r\n                      <ShapeVisual\r\n                        $shapeType={combination.shapeType}\r\n                        $shapeColor={getShapeColorHex(combination.shapeColor)}\r\n                        $borderColor={combination.borderColorHex}\r\n                      />\r\n                    )}\r\n                    {state.count > 0 && (\r\n                      <CountBadge $hasIncorrect={state.hasIncorrect}>\r\n                        {state.count}\r\n                      </CountBadge>\r\n                    )}\r\n                  </ShapeContainer>\r\n                  <ButtonTitle>\r\n                    {combination.shapeColor} {combination.shapeType}\r\n                  </ButtonTitle>\r\n                </ButtonContent>\r\n              </IdentifyButton>\r\n            );\r\n          })}\r\n        </ButtonGrid>\r\n      </div>\r\n\r\n      {/* Status Message */}\r\n      {activeIdentification && (\r\n        <StatusMessage $type=\"success\">\r\n          Combination identification complete! Check the terminal for detailed results.\r\n        </StatusMessage>\r\n      )}\r\n    </IdentifyContainer>\r\n  );\r\n}\r\n\r\nexport default IdentifyIncorrectShapes;\r\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,QAAQ,OAAO;AACvC,OAAOC,MAAM,MAAM,mBAAmB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEvC,MAAMC,iBAAiB,GAAGH,MAAM,CAACI,GAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACC,EAAA,GAZIF,iBAAiB;AAcvB,MAAMG,YAAY,GAAGN,MAAM,CAACO,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACC,GAAA,GAPIF,YAAY;AASlB,MAAMG,UAAU,GAAGT,MAAM,CAACI,GAAG;AAC7B;AACA;AACA;AACA;AACA,CAAC;AAACM,GAAA,GALID,UAAU;AAOhB,MAAME,cAAc,GAAGX,MAAM,CAACY,MAAM;AACpC;AACA,sBAAsBC,KAAK,IAAI;EAC3B,IAAIA,KAAK,CAACC,SAAS,EAAE,OAAO,SAAS;EACrC,IAAID,KAAK,CAACE,aAAa,EAAE,OAAO,SAAS;EACzC,OAAO,0BAA0B;AACnC,CAAC;AACH;AACA;AACA;AACA,YAAYF,KAAK,IAAIA,KAAK,CAACG,QAAQ,GAAG,aAAa,GAAG,SAAS;AAC/D;AACA,gBAAgBH,KAAK,IAAI;EACrB,IAAIA,KAAK,CAACG,QAAQ,EAAE,OAAO,0BAA0B;EACrD,IAAIH,KAAK,CAACC,SAAS,EAAE,OAAO,wBAAwB;EACpD,IAAID,KAAK,CAACE,aAAa,EAAE,OAAO,wBAAwB;EACxD,OAAO,0BAA0B;AACnC,CAAC;AACH,WAAWF,KAAK,IAAI;EAChB,IAAIA,KAAK,CAACG,QAAQ,EAAE,OAAO,MAAM;EACjC,IAAIH,KAAK,CAACC,SAAS,EAAE,OAAO,SAAS;EACrC,IAAID,KAAK,CAACE,aAAa,EAAE,OAAO,SAAS;EACzC,OAAO,OAAO;AAChB,CAAC;AACH,aAAaF,KAAK,IAAIA,KAAK,CAACG,QAAQ,GAAG,GAAG,GAAG,CAAC;AAC9C;AACA;AACA,iBAAiBH,KAAK,IAAIA,KAAK,CAACG,QAAQ,GAAG,MAAM,GAAG,kBAAkB;AACtE,kBAAkBH,KAAK,IAAIA,KAAK,CAACG,QAAQ,GAAG,MAAM,GAAG,+BAA+B;AACpF,kBAAkBH,KAAK,IAAI;EACrB,IAAIA,KAAK,CAACG,QAAQ,EAAE,OAAO,0BAA0B;EACrD,IAAIH,KAAK,CAACC,SAAS,EAAE,OAAO,wBAAwB;EACpD,IAAID,KAAK,CAACE,aAAa,EAAE,OAAO,wBAAwB;EACxD,OAAO,0BAA0B;AACnC,CAAC;AACL;AACA;AACA;AACA,iBAAiBF,KAAK,IAAIA,KAAK,CAACG,QAAQ,GAAG,MAAM,GAAG,eAAe;AACnE;AACA,CAAC;AAACC,GAAA,GAxCIN,cAAc;AA0CpB,MAAMO,aAAa,GAAGlB,MAAM,CAACI,GAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACe,GAAA,GARID,aAAa;AAUnB,MAAME,cAAc,GAAGpB,MAAM,CAACI,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACiB,GAAA,GARID,cAAc;AAUpB,MAAME,WAAW,GAAGtB,MAAM,CAACI,GAAG;AAC9B;AACA;AACA,gBAAgBS,KAAK,IAAIA,KAAK,CAACU,WAAW;AAC1C,sBAAsBV,KAAK,IAAIA,KAAK,CAACW,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmBX,KAAK,IAAI;EACxB,IAAIA,KAAK,CAACY,UAAU,KAAK,QAAQ,EAAE,OAAO,KAAK;EAC/C,IAAIZ,KAAK,CAACY,UAAU,KAAK,SAAS,EAAE,OAAO,GAAG;EAC9C,OAAO,GAAG;AACZ,CAAC;AACH;AACA,eAAeZ,KAAK,IAAI;EACpB,IAAIA,KAAK,CAACY,UAAU,KAAK,SAAS,EAAE,OAAO,eAAe;EAC1D,OAAO,MAAM;AACf,CAAC;AACH;AACA;AACA,IAAIZ,KAAK,IAAIA,KAAK,CAACY,UAAU,KAAK,UAAU,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgCZ,KAAK,CAACU,WAAW;AACjD;AACA,GAAG;AACH,CAAC;AAACG,GAAA,GAjCIJ,WAAW;AAmCjB,MAAMK,UAAU,GAAG3B,MAAM,CAAC4B,IAAI;AAC9B,gBAAgBf,KAAK,IAAIA,KAAK,CAACE,aAAa,GAAG,SAAS,GAAG,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACc,GAAA,GAfIF,UAAU;AAiBhB,MAAMG,WAAW,GAAG9B,MAAM,CAAC4B,IAAI;AAC/B;AACA;AACA;AACA;AACA;AACA,CAAC;AAACG,GAAA,GANID,WAAW;AAQjB,MAAME,cAAc,GAAGhC,MAAM,CAACI,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC;AAAC6B,GAAA,GANID,cAAc;AAQpB,MAAME,YAAY,GAAGlC,MAAM,CAACmC,CAAC;AAC7B;AACA;AACA;AACA;AACA;AACA,CAAC;AAACC,GAAA,GANIF,YAAY;AAQlB,MAAMG,aAAa,GAAGrC,MAAM,CAACI,GAAG;AAChC;AACA;AACA;AACA;AACA;AACA,gBAAgBS,KAAK,IAAI;EACrB,IAAIA,KAAK,CAACyB,KAAK,KAAK,SAAS,EAAE,OAAO,wBAAwB;EAC9D,IAAIzB,KAAK,CAACyB,KAAK,KAAK,SAAS,EAAE,OAAO,wBAAwB;EAC9D,IAAIzB,KAAK,CAACyB,KAAK,KAAK,OAAO,EAAE,OAAO,wBAAwB;EAC5D,OAAO,yBAAyB;AAClC,CAAC;AACH,WAAWzB,KAAK,IAAI;EAChB,IAAIA,KAAK,CAACyB,KAAK,KAAK,SAAS,EAAE,OAAO,SAAS;EAC/C,IAAIzB,KAAK,CAACyB,KAAK,KAAK,SAAS,EAAE,OAAO,SAAS;EAC/C,IAAIzB,KAAK,CAACyB,KAAK,KAAK,OAAO,EAAE,OAAO,SAAS;EAC7C,OAAO,SAAS;AAClB,CAAC;AACH,sBAAsBzB,KAAK,IAAI;EAC3B,IAAIA,KAAK,CAACyB,KAAK,KAAK,SAAS,EAAE,OAAO,wBAAwB;EAC9D,IAAIzB,KAAK,CAACyB,KAAK,KAAK,SAAS,EAAE,OAAO,wBAAwB;EAC9D,IAAIzB,KAAK,CAACyB,KAAK,KAAK,OAAO,EAAE,OAAO,wBAAwB;EAC5D,OAAO,yBAAyB;AAClC,CAAC;AACH,CAAC;;AAED;AAAAC,IAAA,GA1BMF,aAAa;AA2BnB,MAAMG,aAAa,GAAGA,CAACC,OAAO,EAAEC,IAAI,GAAG,IAAI,KAAK;EAC9CC,OAAO,CAACC,GAAG,CAAC,QAAQH,OAAO,EAAE,CAAC;EAC9B,IAAIC,IAAI,EAAE;IACRC,OAAO,CAACC,GAAG,CAACC,IAAI,CAACC,SAAS,CAACJ,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;EAC5C;EACAC,OAAO,CAACC,GAAG,CAAC,GAAG,CAACG,MAAM,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;;EAElC;EACA,MAAMC,eAAe,GAAG,MAAAA,CAAA,KAAY;IAClC,IAAI;MACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,2BAA2B,EAAE;QACxDC,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE;QAClB,CAAC;QACDC,IAAI,EAAER,IAAI,CAACC,SAAS,CAAC;UACnBL,OAAO,EAAEA,OAAO;UAChBC,IAAI,EAAEA;QACR,CAAC,CAAC;QACF;QACAY,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI;MAClC,CAAC,CAAC;MAEF,IAAI,CAACP,QAAQ,CAACQ,EAAE,EAAE;QAChB,MAAM,IAAIC,KAAK,CAAC,uBAAuBT,QAAQ,CAACU,MAAM,EAAE,CAAC;MAC3D;MACAhB,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;IACpD,CAAC,CAAC,OAAOgB,KAAK,EAAE;MACd;MACAjB,OAAO,CAACC,GAAG,CAAC,uDAAuD,CAAC;IACtE;EACF,CAAC;;EAED;EACAI,eAAe,CAAC,CAAC;AACnB,CAAC;AAED,SAASa,uBAAuBA,CAAC;EAAEC,YAAY;EAAEC,SAAS;EAAEC,gBAAgB;EAAEC;AAAa,CAAC,EAAE;EAAAC,EAAA;EAC5F,MAAM,CAACC,oBAAoB,EAAEC,uBAAuB,CAAC,GAAGrE,QAAQ,CAAC,IAAI,CAAC;EACtE,MAAM,CAACsE,qBAAqB,EAAEC,wBAAwB,CAAC,GAAGvE,QAAQ,CAAC,CAAC,CAAC,CAAC;EAEtE,IAAI,CAACgE,SAAS,EAAE;IACdpB,OAAO,CAACC,GAAG,CAAC,2CAA2C,CAAC;IACxD,oBACE1C,OAAA,CAACC,iBAAiB;MAAAoE,QAAA,gBAChBrE,OAAA,CAACI,YAAY;QAAAiE,QAAA,EAAC;MAAyB;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAc,CAAC,eACtDzE,OAAA,CAACmC,aAAa;QAACC,KAAK,EAAC,SAAS;QAAAiC,QAAA,EAAC;MAE/B;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAe,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACC,CAAC;EAExB;;EAEA;EACA,MAAMC,YAAY,GAAIC,OAAO,IAAK;IAChC,MAAMC,UAAU,GAAG,CACjB,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAChD,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAChD,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,SAAS,EACzD,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EACrD,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,CACvE;IACD,OAAOA,UAAU,CAACD,OAAO,CAAC,IAAI,SAAS;EACzC,CAAC;EAED,MAAME,aAAa,GAAIF,OAAO,IAAK;IACjC,MAAMG,WAAW,GAAG,CAClB,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAC1C,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAC1C,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAC3C,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAC1C,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,CACtD;IACD,OAAOA,WAAW,CAACH,OAAO,CAAC,IAAI,SAAS;EAC1C,CAAC;EAED,MAAMI,mBAAmB,GAAIJ,OAAO,IAAK;IACvC,MAAMK,SAAS,GAAG,EAAE;IACpB,KAAK,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC5B,KAAK,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC5B,KAAK,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UAC5B,IAAIF,CAAC,KAAK,CAAC,IAAIC,CAAC,KAAK,CAAC,IAAIC,CAAC,KAAK,CAAC,EAAE;UACnCH,SAAS,CAACI,IAAI,CAAC,CAACH,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,CAAC;QAC3B;MACF;IACF;IACA,OAAOH,SAAS,CAACL,OAAO,CAAC;EAC3B,CAAC;EAED,MAAMU,wBAAwB,GAAGA,CAACC,KAAK,EAAEX,OAAO,KAAK;IACnD,IAAI,CAACW,KAAK,IAAI,CAACA,KAAK,CAACC,QAAQ,EAAE,OAAO,KAAK;IAC3C,MAAMC,gBAAgB,GAAGT,mBAAmB,CAACJ,OAAO,CAAC;IACrD,OAAOhC,IAAI,CAACC,SAAS,CAAC0C,KAAK,CAACC,QAAQ,CAAC,KAAK5C,IAAI,CAACC,SAAS,CAAC4C,gBAAgB,CAAC;EAC5E,CAAC;EAED,MAAMC,sBAAsB,GAAIC,SAAS,IAAK;IAC5C,MAAMC,YAAY,GAAG,CACnB,SAAS;IAAE;IACX,SAAS;IAAE;IACX,SAAS;IAAE;IACX,SAAS;IAAE;IACX,SAAS;IAAE;IACX,SAAS,CAAE;IAAA,CACZ;IACD,OAAOA,YAAY,CAACD,SAAS,CAAC,IAAI,SAAS;EAC7C,CAAC;EAED,MAAME,kBAAkB,GAAIF,SAAS,IAAK;IACxC,MAAMG,UAAU,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,CAAC;IACxE,OAAOA,UAAU,CAACH,SAAS,CAAC,IAAI,SAAS;EAC3C,CAAC;EAED,MAAMI,gBAAgB,GAAIC,UAAU,IAAK;IACvC,MAAMC,QAAQ,GAAG;MACf,KAAK,EAAE,SAAS;MAChB,MAAM,EAAE,SAAS;MACjB,OAAO,EAAE,SAAS;MAClB,QAAQ,EAAE,SAAS;MACnB,QAAQ,EAAE,SAAS;MACnB,QAAQ,EAAE,SAAS;MACnB,MAAM,EAAE,SAAS;MACjB,SAAS,EAAE,SAAS;MACpB,MAAM,EAAE,SAAS;MACjB,MAAM,EAAE;IACV,CAAC;IACD,OAAOA,QAAQ,CAACD,UAAU,CAAC,IAAI,SAAS;EAC1C,CAAC;;EAED;EACA,MAAME,wBAAwB,GAAGA,CAAA,KAAM;IACrC3D,aAAa,CAAC,gEAAgE,CAAC;IAE/E,IAAI,CAACuB,SAAS,IAAIA,SAAS,CAACqC,MAAM,KAAK,CAAC,EAAE;MACxC5D,aAAa,CAAC,+DAA+D,CAAC;MAC9E,OAAO;QACL6D,IAAI,EAAE,kBAAkB;QACxBC,eAAe,EAAE,EAAE;QACnBC,KAAK,EAAE,CAAC;QACRC,mBAAmB,EAAE;MACvB,CAAC;IACH;IAEAhE,aAAa,CAAC,8EAA8E,EAAEuB,SAAS,CAACqC,MAAM,EAAE,WAAW,CAAC;IAE5H,MAAME,eAAe,GAAG,EAAE;IAC1B,IAAIE,mBAAmB,GAAG,CAAC;IAC3B,IAAIC,aAAa,GAAG,CAAC;IAErB1C,SAAS,CAAC2C,OAAO,CAAC,CAAClB,KAAK,EAAEmB,KAAK,KAAK;MAClCF,aAAa,EAAE;MACf,MAAM5B,OAAO,GAAGW,KAAK,CAACX,OAAO,IAAI8B,KAAK;MAEtC,IAAI,CAACC,KAAK,CAACC,OAAO,CAACrB,KAAK,CAACC,QAAQ,CAAC,IAAI,CAACD,KAAK,CAACsB,MAAM,IAAI,OAAOtB,KAAK,CAACsB,MAAM,KAAK,QAAQ,EAAE;QACvFtE,aAAa,CAAC,cAAcqC,OAAO,iCAAiC,CAAC;QACrE;MACF;MAEA,MAAM,CAACM,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAGG,KAAK,CAACC,QAAQ;;MAEhC;MACA,MAAMsB,eAAe,GAAG;QACtBC,KAAK,EAAE3B,CAAC,KAAK,CAAC;QACd4B,IAAI,EAAE5B,CAAC,KAAK,CAAC,CAAC;QACd6B,KAAK,EAAE/B,CAAC,KAAK,CAAC;QACdgC,IAAI,EAAEhC,CAAC,KAAK,CAAC,CAAC;QACdiC,GAAG,EAAEhC,CAAC,KAAK,CAAC;QACZiC,MAAM,EAAEjC,CAAC,KAAK,CAAC;MACjB,CAAC;MAED,MAAMkC,cAAc,GAAG,EAAE;;MAEzB;MACAC,MAAM,CAACC,IAAI,CAACT,eAAe,CAAC,CAACL,OAAO,CAACe,IAAI,IAAI;QAC3C,IAAIV,eAAe,CAACU,IAAI,CAAC,EAAE;UACzB,MAAMC,SAAS,GAAGlC,KAAK,CAACsB,MAAM,CAACW,IAAI,CAAC;;UAEpC;UACA,IAAIC,SAAS,KAAK,SAAS,IAAIA,SAAS,KAAK,OAAO,IAAIA,SAAS,KAAK,SAAS,EAAE;YAC/EJ,cAAc,CAAChC,IAAI,CAAC;cAClBmC,IAAI,EAAEA,IAAI;cACVE,YAAY,EAAED,SAAS;cACvBE,KAAK,EAAE;YACT,CAAC,CAAC;YACFpB,mBAAmB,EAAE;YACrBhE,aAAa,CAAC,cAAcqC,OAAO,mBAAmB4C,IAAI,UAAUC,SAAS,8CAA8C,CAAC;UAC9H,CAAC,MAAM;YACLlF,aAAa,CAAC,cAAcqC,OAAO,IAAI4C,IAAI,2BAA2BC,SAAS,EAAE,CAAC;UACpF;QACF;MACF,CAAC,CAAC;MAEF,IAAIJ,cAAc,CAAClB,MAAM,GAAG,CAAC,EAAE;QAC7BE,eAAe,CAAChB,IAAI,CAAC;UACnBT,OAAO,EAAEA,OAAO;UAChBgD,eAAe,EAAErC,KAAK,CAACC,QAAQ;UAC/BqC,cAAc,EAAEtC,KAAK,CAACsC,cAAc;UACpCR,cAAc,EAAEA;QAClB,CAAC,CAAC;QACF9E,aAAa,CAAC,oBAAoBqC,OAAO,6BAA6ByC,cAAc,CAAClB,MAAM,kBAAkB,CAAC;MAChH;IACF,CAAC,CAAC;IAEF5D,aAAa,CAAC,wEAAwE,CAAC;IACvFA,aAAa,CAAC,0BAA0B,EAAEiE,aAAa,CAAC;IACxDjE,aAAa,CAAC,6CAA6C,EAAE8D,eAAe,CAACF,MAAM,CAAC;IACpF5D,aAAa,CAAC,iCAAiC,EAAEgE,mBAAmB,CAAC;IAErE,MAAMuB,MAAM,GAAG;MACb1B,IAAI,EAAE,kBAAkB;MACxBC,eAAe,EAAEA,eAAe;MAChCC,KAAK,EAAED,eAAe,CAACF,MAAM;MAC7BI,mBAAmB,EAAEA;IACvB,CAAC;IAEDlC,wBAAwB,CAAC0D,IAAI,KAAK;MAChC,GAAGA,IAAI;MACP,kBAAkB,EAAED;IACtB,CAAC,CAAC,CAAC;IAEH,OAAOA,MAAM;EACf,CAAC;;EAED;EACA,MAAME,uBAAuB,GAAIR,IAAI,IAAK;IACxC,MAAMvB,QAAQ,GAAG;MACfc,KAAK,EAAE,OAAO;MACdC,IAAI,EAAE,QAAQ;MACdC,KAAK,EAAE,KAAK;MACZC,IAAI,EAAE,QAAQ;MACdC,GAAG,EAAE,MAAM;MACXC,MAAM,EAAE;IACV,CAAC;IACD,OAAOnB,QAAQ,CAACuB,IAAI,CAAC,IAAI,SAAS;EACpC,CAAC;;EAED;EACA,MAAMS,SAAS,GAAGA,CAAA,KAAM;IACtB,IAAItB,KAAK,CAACC,OAAO,CAAC9C,SAAS,CAAC,EAAE;MAC5B,OAAOA,SAAS,CAACoE,GAAG,CAAC,CAAC3C,KAAK,EAAEmB,KAAK,MAAM;QACtC9B,OAAO,EAAE8B,KAAK;QACdlB,QAAQ,EAAED,KAAK,CAACC,QAAQ;QACxBqB,MAAM,EAAEtB,KAAK,CAACsB,MAAM;QACpBsB,eAAe,EAAE5C,KAAK,CAAC4C,eAAe,IAAI;MAC5C,CAAC,CAAC,CAAC;IACL,CAAC,MAAM,IAAIrE,SAAS,aAATA,SAAS,eAATA,SAAS,CAAEsE,MAAM,EAAE;MAC5B,OAAOtE,SAAS,CAACsE,MAAM;IACzB;IACA,OAAO,EAAE;EACX,CAAC;EAED,MAAMA,MAAM,GAAGH,SAAS,CAAC,CAAC;;EAE1B;EACA,MAAMI,6BAA6B,GAAIC,SAAS,IAAK;IACnD,MAAMjC,eAAe,GAAG+B,MAAM,CAACG,MAAM,CAAChD,KAAK,IAAI;MAC7C,MAAMX,OAAO,GAAGW,KAAK,CAACX,OAAO;MAC7B,MAAM4D,eAAe,GAAG7D,YAAY,CAACC,OAAO,CAAC;MAC7C,OAAO4D,eAAe,KAAKF,SAAS,IAAI,CAAChD,wBAAwB,CAACC,KAAK,EAAEX,OAAO,CAAC;IACnF,CAAC,CAAC;IAEF,MAAMkD,MAAM,GAAG;MACb1B,IAAI,EAAE,OAAO;MACbkC,SAAS;MACTjC,eAAe,EAAEA,eAAe,CAAC6B,GAAG,CAAC3C,KAAK,KAAK;QAC7CX,OAAO,EAAEW,KAAK,CAACX,OAAO;QACtB0D,SAAS,EAAE3D,YAAY,CAACY,KAAK,CAACX,OAAO,CAAC;QACtCoB,UAAU,EAAElB,aAAa,CAACS,KAAK,CAACX,OAAO,CAAC;QACxCgD,eAAe,EAAErC,KAAK,CAACC,QAAQ;QAC/BC,gBAAgB,EAAET,mBAAmB,CAACO,KAAK,CAACX,OAAO,CAAC;QACpDiC,MAAM,EAAEtB,KAAK,CAACsB,MAAM;QACpBsB,eAAe,EAAE5C,KAAK,CAAC4C;MACzB,CAAC,CAAC,CAAC;MACH7B,KAAK,EAAED,eAAe,CAACF;IACzB,CAAC;IAED9B,wBAAwB,CAAC0D,IAAI,KAAK;MAChC,GAAGA,IAAI;MACP,CAAC,SAASO,SAAS,EAAE,GAAGR;IAC1B,CAAC,CAAC,CAAC;IAEHvF,aAAa,CAAC,2BAA2B+F,SAAS,CAACG,WAAW,CAAC,CAAC,SAAS,EAAEX,MAAM,CAAC;IAElF,IAAI/D,gBAAgB,EAAE;MACpBA,gBAAgB,CAAC+D,MAAM,CAAC;IAC1B;IAEA,OAAOA,MAAM;EACf,CAAC;;EAED;EACA,MAAMY,8BAA8B,GAAI1C,UAAU,IAAK;IACrD,MAAMK,eAAe,GAAG+B,MAAM,CAACG,MAAM,CAAChD,KAAK,IAAI;MAC7C,MAAMX,OAAO,GAAGW,KAAK,CAACX,OAAO;MAC7B,MAAM+D,gBAAgB,GAAG7D,aAAa,CAACF,OAAO,CAAC;MAC/C,OAAO+D,gBAAgB,KAAK3C,UAAU,IAAI,CAACV,wBAAwB,CAACC,KAAK,EAAEX,OAAO,CAAC;IACrF,CAAC,CAAC;IAEF,MAAMkD,MAAM,GAAG;MACb1B,IAAI,EAAE,OAAO;MACbJ,UAAU;MACVK,eAAe,EAAEA,eAAe,CAAC6B,GAAG,CAAC3C,KAAK,KAAK;QAC7CX,OAAO,EAAEW,KAAK,CAACX,OAAO;QACtB0D,SAAS,EAAE3D,YAAY,CAACY,KAAK,CAACX,OAAO,CAAC;QACtCoB,UAAU,EAAElB,aAAa,CAACS,KAAK,CAACX,OAAO,CAAC;QACxCgD,eAAe,EAAErC,KAAK,CAACC,QAAQ;QAC/BC,gBAAgB,EAAET,mBAAmB,CAACO,KAAK,CAACX,OAAO,CAAC;QACpDiC,MAAM,EAAEtB,KAAK,CAACsB,MAAM;QACpBsB,eAAe,EAAE5C,KAAK,CAAC4C;MACzB,CAAC,CAAC,CAAC;MACH7B,KAAK,EAAED,eAAe,CAACF;IACzB,CAAC;IAED9B,wBAAwB,CAAC0D,IAAI,KAAK;MAChC,GAAGA,IAAI;MACP,CAAC,SAAS/B,UAAU,EAAE,GAAG8B;IAC3B,CAAC,CAAC,CAAC;IAEHvF,aAAa,CAAC,2BAA2ByD,UAAU,CAACyC,WAAW,CAAC,CAAC,SAAS,EAAEX,MAAM,CAAC;IAEnF,IAAI/D,gBAAgB,EAAE;MACpBA,gBAAgB,CAAC+D,MAAM,CAAC;IAC1B;IAEA,OAAOA,MAAM;EACf,CAAC;;EAED;EACA,MAAMc,6BAA6B,GAAIjD,SAAS,IAAK;IACnD,MAAMkD,eAAe,GAAGhD,kBAAkB,CAACF,SAAS,CAAC;IACrD,MAAMmD,cAAc,GAAGpD,sBAAsB,CAACC,SAAS,CAAC;IAExD,MAAMU,eAAe,GAAG+B,MAAM,CAACG,MAAM,CAAChD,KAAK,IAAI;MAC7C,MAAMX,OAAO,GAAGW,KAAK,CAACX,OAAO;MAC7B,MAAMmE,mBAAmB,GAAGzD,wBAAwB,CAACC,KAAK,EAAEX,OAAO,CAAC;;MAEpE;MACA,MAAM,CAACM,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAGG,KAAK,CAACC,QAAQ;MAChC,IAAIwD,qBAAqB,GAAG,KAAK;MAEjC,QAAQrD,SAAS;QACf,KAAK,CAAC;UAAE;UACNqD,qBAAqB,GAAG5D,CAAC,KAAK,CAAC;UAC/B;QACF,KAAK,CAAC;UAAE;UACN4D,qBAAqB,GAAG5D,CAAC,KAAK,CAAC,CAAC;UAChC;QACF,KAAK,CAAC;UAAE;UACN4D,qBAAqB,GAAG9D,CAAC,KAAK,CAAC;UAC/B;QACF,KAAK,CAAC;UAAE;UACN8D,qBAAqB,GAAG9D,CAAC,KAAK,CAAC,CAAC;UAChC;QACF,KAAK,CAAC;UAAE;UACN8D,qBAAqB,GAAG7D,CAAC,KAAK,CAAC;UAC/B;QACF,KAAK,CAAC;UAAE;UACN6D,qBAAqB,GAAG7D,CAAC,KAAK,CAAC,CAAC;UAChC;MACJ;;MAEA;MACA,OAAO6D,qBAAqB,IAAI,CAACD,mBAAmB;IACtD,CAAC,CAAC;IAEF,MAAMjB,MAAM,GAAG;MACb1B,IAAI,EAAE,QAAQ;MACdT,SAAS;MACTkD,eAAe;MACfC,cAAc;MACdzC,eAAe,EAAEA,eAAe,CAAC6B,GAAG,CAAC3C,KAAK,KAAK;QAC7CX,OAAO,EAAEW,KAAK,CAACX,OAAO;QACtB0D,SAAS,EAAE3D,YAAY,CAACY,KAAK,CAACX,OAAO,CAAC;QACtCoB,UAAU,EAAElB,aAAa,CAACS,KAAK,CAACX,OAAO,CAAC;QACxCgD,eAAe,EAAErC,KAAK,CAACC,QAAQ;QAC/BC,gBAAgB,EAAET,mBAAmB,CAACO,KAAK,CAACX,OAAO,CAAC;QACpDiC,MAAM,EAAEtB,KAAK,CAACsB,MAAM;QACpBsB,eAAe,EAAE5C,KAAK,CAAC4C;MACzB,CAAC,CAAC,CAAC;MACH7B,KAAK,EAAED,eAAe,CAACF;IACzB,CAAC;IAED9B,wBAAwB,CAAC0D,IAAI,KAAK;MAChC,GAAGA,IAAI;MACP,CAAC,UAAUpC,SAAS,EAAE,GAAGmC;IAC3B,CAAC,CAAC,CAAC;IAEHvF,aAAa,CAAC,2BAA2BsG,eAAe,CAACJ,WAAW,CAAC,CAAC,gBAAgB,EAAEX,MAAM,CAAC;IAE/F,IAAI/D,gBAAgB,EAAE;MACpBA,gBAAgB,CAAC+D,MAAM,CAAC;IAC1B;IAEA,OAAOA,MAAM;EACf,CAAC;;EAED;EACA,MAAMmB,4BAA4B,GAAGA,CAAA,KAAM;IACzC1G,aAAa,CAAC,8DAA8D,CAAC;IAC7EA,aAAa,CAAC,oBAAoB,EAAE,OAAOuB,SAAS,CAAC;IACrDvB,aAAa,CAAC,sBAAsB,EAAEuB,SAAS,GAAGA,SAAS,CAACqC,MAAM,GAAG,MAAM,CAAC;IAC5E5D,aAAa,CAAC,uBAAuB,EAAEuB,SAAS,KAAK,IAAI,CAAC;IAC1DvB,aAAa,CAAC,4BAA4B,EAAEuB,SAAS,KAAKoF,SAAS,CAAC;IAEpE,IAAI,CAACpF,SAAS,IAAIA,SAAS,CAACqC,MAAM,KAAK,CAAC,EAAE;MACxC5D,aAAa,CAAC,iDAAiD,CAAC;MAChE,OAAO;QACL6D,IAAI,EAAE,YAAY;QAClBC,eAAe,EAAE,EAAE;QACnBC,KAAK,EAAE,CAAC;QACR6C,eAAe,EAAE;MACnB,CAAC;IACH;IAEA5G,aAAa,CAAC,qCAAqC,EAAEuB,SAAS,CAACqC,MAAM,EAAE,WAAW,CAAC;IAEnF,MAAME,eAAe,GAAG,EAAE;IAC1B,IAAI8C,eAAe,GAAG,CAAC;IACvB,IAAI3C,aAAa,GAAG,CAAC;IACrB,IAAI4C,gBAAgB,GAAG,CAAC;IACxB,IAAIC,kBAAkB,GAAG,CAAC;;IAE1B;IACA9G,aAAa,CAAC,mDAAmD,CAAC;IAClEuB,SAAS,CAACwF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC7C,OAAO,CAAC,CAAClB,KAAK,EAAEmB,KAAK,KAAK;MAC9CnE,aAAa,CAAC,YAAYmE,KAAK,GAAG,EAAE;QAClC9B,OAAO,EAAEW,KAAK,CAACX,OAAO;QACtB2E,WAAW,EAAE5C,KAAK,CAACC,OAAO,CAACrB,KAAK,CAACC,QAAQ,CAAC;QAC1CA,QAAQ,EAAED,KAAK,CAACC,QAAQ;QACxBgE,SAAS,EAAE,OAAOjE,KAAK,CAACsB,MAAM,KAAK,QAAQ,IAAItB,KAAK,CAACsB,MAAM,KAAK,IAAI;QACpEA,MAAM,EAAEtB,KAAK,CAACsB,MAAM;QACpB4C,OAAO,EAAEnC,MAAM,CAACC,IAAI,CAAChC,KAAK;MAC5B,CAAC,CAAC;IACJ,CAAC,CAAC;IAEFhD,aAAa,CAAC,8CAA8C,CAAC;IAE7DuB,SAAS,CAAC2C,OAAO,CAAC,CAAClB,KAAK,EAAEmB,KAAK,KAAK;MAClCF,aAAa,EAAE;MACf,MAAM5B,OAAO,GAAGW,KAAK,CAACX,OAAO,IAAI8B,KAAK;;MAEtC;MACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACrB,KAAK,CAACC,QAAQ,CAAC,EAAE;QAClCjD,aAAa,CAAC,cAAcqC,OAAO,wBAAwB,EAAEW,KAAK,CAACC,QAAQ,CAAC;QAC5E;MACF;MACA6D,kBAAkB,EAAE;;MAEpB;MACA,IAAI,CAAC9D,KAAK,CAACsB,MAAM,IAAI,OAAOtB,KAAK,CAACsB,MAAM,KAAK,QAAQ,EAAE;QACrDtE,aAAa,CAAC,cAAcqC,OAAO,sBAAsB,EAAEW,KAAK,CAACsB,MAAM,CAAC;QACxE;MACF;MACAuC,gBAAgB,EAAE;MAElB,MAAM,CAAClE,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAGG,KAAK,CAACC,QAAQ;MAEhCjD,aAAa,CAAC,qBAAqBqC,OAAO,iBAAiBM,CAAC,KAAKC,CAAC,KAAKC,CAAC,GAAG,CAAC;MAC5E7C,aAAa,CAAC,yBAAyB,EAAEgD,KAAK,CAACsB,MAAM,CAAC;MACtDtE,aAAa,CAAC,gBAAgB,EAAE+E,MAAM,CAACC,IAAI,CAAChC,KAAK,CAACsB,MAAM,CAAC,CAAC;;MAE1D;MACA,MAAM6C,YAAY,GAAG,EAAE;MACvB,IAAIxE,CAAC,KAAK,CAAC,EAAEwE,YAAY,CAACrE,IAAI,CAAC,OAAO,CAAC;MACvC,IAAIH,CAAC,KAAK,CAAC,CAAC,EAAEwE,YAAY,CAACrE,IAAI,CAAC,MAAM,CAAC;MACvC,IAAIF,CAAC,KAAK,CAAC,EAAEuE,YAAY,CAACrE,IAAI,CAAC,KAAK,CAAC;MACrC,IAAIF,CAAC,KAAK,CAAC,CAAC,EAAEuE,YAAY,CAACrE,IAAI,CAAC,QAAQ,CAAC;MACzC,IAAID,CAAC,KAAK,CAAC,EAAEsE,YAAY,CAACrE,IAAI,CAAC,OAAO,CAAC;MACvC,IAAID,CAAC,KAAK,CAAC,CAAC,EAAEsE,YAAY,CAACrE,IAAI,CAAC,MAAM,CAAC;MAEvC9C,aAAa,CAAC,8BAA8BqC,OAAO,GAAG,EAAE8E,YAAY,CAAC;;MAErE;MACA,MAAMC,iBAAiB,GAAG,EAAE;MAC5BD,YAAY,CAACjD,OAAO,CAACe,IAAI,IAAI;QAC3B,MAAMC,SAAS,GAAGlC,KAAK,CAACsB,MAAM,CAACW,IAAI,CAAC;QACpCjF,aAAa,CAAC,WAAWiF,IAAI,YAAYC,SAAS,YAAY,OAAOA,SAAS,GAAG,CAAC;;QAElF;QACA,IAAIA,SAAS,KAAK,SAAS,IAAIA,SAAS,KAAK,OAAO,IAAIA,SAAS,KAAK,SAAS,EAAE;UAC/EkC,iBAAiB,CAACtE,IAAI,CAACmC,IAAI,CAAC;UAC5B2B,eAAe,EAAE;UACjB5G,aAAa,CAAC,+BAA+BiF,IAAI,aAAa5C,OAAO,gBAAgB6C,SAAS,GAAG,CAAC;QACpG,CAAC,MAAM;UACLlF,aAAa,CAAC,WAAWiF,IAAI,+BAA+BC,SAAS,IAAI,CAAC;QAC5E;MACF,CAAC,CAAC;MAEF,IAAIkC,iBAAiB,CAACxD,MAAM,GAAG,CAAC,EAAE;QAChCE,eAAe,CAAChB,IAAI,CAAC;UACnBT,OAAO,EAAEA,OAAO;UAChBgD,eAAe,EAAErC,KAAK,CAACC,QAAQ;UAC/BmE,iBAAiB,EAAEA;QACrB,CAAC,CAAC;QACFpH,aAAa,CAAC,oBAAoBqC,OAAO,6BAA6B+E,iBAAiB,CAACxD,MAAM,eAAe,EAAEwD,iBAAiB,CAAC;MACnI,CAAC,MAAM;QACLpH,aAAa,CAAC,YAAYqC,OAAO,6BAA6B,CAAC;MACjE;IACF,CAAC,CAAC;IAEFrC,aAAa,CAAC,iDAAiD,CAAC;IAChEA,aAAa,CAAC,0BAA0B,EAAEiE,aAAa,CAAC;IACxDjE,aAAa,CAAC,gCAAgC,EAAE8G,kBAAkB,CAAC;IACnE9G,aAAa,CAAC,8BAA8B,EAAE6G,gBAAgB,CAAC;IAC/D7G,aAAa,CAAC,6BAA6B,EAAE8D,eAAe,CAACF,MAAM,CAAC;IACpE5D,aAAa,CAAC,6BAA6B,EAAE4G,eAAe,CAAC;IAC7D5G,aAAa,CAAC,8BAA8B,EAAE8D,eAAe,CAAC;IAE9D,MAAMyB,MAAM,GAAG;MACb1B,IAAI,EAAE,YAAY;MAClBC,eAAe,EAAEA,eAAe;MAChCC,KAAK,EAAED,eAAe,CAACF,MAAM;MAC7BgD,eAAe,EAAEA;IACnB,CAAC;IAED5G,aAAa,CAAC,2CAA2C,CAAC;IAC1DA,aAAa,CAAC,YAAY,EAAEuF,MAAM,CAAC;IAEnCzD,wBAAwB,CAAC0D,IAAI,IAAI;MAC/B,MAAM6B,UAAU,GAAG;QACjB,GAAG7B,IAAI;QACP,YAAY,EAAED;MAChB,CAAC;MACDvF,aAAa,CAAC,oCAAoC,EAAEqH,UAAU,CAAC;MAC/D,OAAOA,UAAU;IACnB,CAAC,CAAC;IAEF,OAAO9B,MAAM;EACf,CAAC;EAED,MAAM+B,iBAAiB,GAAGA,CAACzD,IAAI,EAAE0D,UAAU,KAAK;IAC9C,IAAIjG,YAAY,EAAE;IAElBM,uBAAuB,CAAC,GAAGiC,IAAI,IAAI0D,UAAU,EAAE,CAAC;IAEhD,IAAIhC,MAAM;IACV,QAAQ1B,IAAI;MACV,KAAK,OAAO;QACV0B,MAAM,GAAGO,6BAA6B,CAACyB,UAAU,CAAC;QAClD;MACF,KAAK,OAAO;QACVhC,MAAM,GAAGY,8BAA8B,CAACoB,UAAU,CAAC;QACnD;MACF,KAAK,QAAQ;QACXhC,MAAM,GAAGc,6BAA6B,CAACkB,UAAU,CAAC;QAClD;MACF,KAAK,YAAY;QACfhC,MAAM,GAAGmB,4BAA4B,CAAC,CAAC;QACvC;MACF,KAAK,kBAAkB;QACrBnB,MAAM,GAAG5B,wBAAwB,CAAC,CAAC;QACnC;IACJ;;IAEA;IACA6D,UAAU,CAAC,MAAM;MACf5F,uBAAuB,CAAC,IAAI,CAAC;IAC/B,CAAC,EAAE,IAAI,CAAC;EACV,CAAC;EAED,MAAM6F,yBAAyB,GAAGA,CAAA,KAAM;IACtCzH,aAAa,CAAC,4CAA4C,CAAC;IAC3DA,aAAa,CAAC,kBAAkB,EAAEsB,YAAY,CAAC;IAE/C,IAAIA,YAAY,EAAE;MAChBtB,aAAa,CAAC,yCAAyC,CAAC;MACxD;IACF;;IAEA;IACA,MAAM0H,gBAAgB,GAAGhB,4BAA4B,CAAC,CAAC;IAEvD,IAAIgB,gBAAgB,CAAC3D,KAAK,KAAK,CAAC,EAAE;MAChC/D,aAAa,CAAC,sBAAsB,CAAC;MACrC;IACF;IAEAA,aAAa,CAAC,iCAAiC,EAAE0H,gBAAgB,CAAC5D,eAAe,CAACF,MAAM,EAAE,QAAQ,CAAC;IACnG5D,aAAa,CAAC,mBAAmB,EAAE0H,gBAAgB,CAAC5D,eAAe,CAAC6B,GAAG,CAAChG,CAAC,IAAI,GAAGA,CAAC,CAAC0C,OAAO,QAAQ1C,CAAC,CAAC0F,eAAe,CAACsC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;;IAElI;IACA,IAAI,OAAOC,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,gBAAgB,EAAE;MAC5D7H,aAAa,CAAC,gDAAgD,CAAC;MAC/D;MACA,MAAM8H,YAAY,GAAGF,MAAM,CAACC,gBAAgB,CAACE,KAAK,IAAIxG,SAAS;MAC/DvB,aAAa,CAAC,0BAA0B,EAAE8H,YAAY,CAAClE,MAAM,CAAC;MAE9DgE,MAAM,CAACC,gBAAgB,CAACG,QAAQ,CAACC,SAAS,IAAI;QAC5CjI,aAAa,CAAC,4DAA4D,EAAEiI,SAAS,CAACrE,MAAM,CAAC;QAC7F,MAAMsE,QAAQ,GAAG,CAAC,GAAGD,SAAS,CAAC;QAE/BP,gBAAgB,CAAC5D,eAAe,CAACI,OAAO,CAACiE,cAAc,IAAI;UACzDnI,aAAa,CAAC,uBAAuBmI,cAAc,CAAC9F,OAAO,KAAK,CAAC;UACjE,MAAM+F,UAAU,GAAGF,QAAQ,CAACG,SAAS,CAAC1I,CAAC,IAAIA,CAAC,CAAC0C,OAAO,KAAK8F,cAAc,CAAC9F,OAAO,CAAC;UAChFrC,aAAa,CAAC,2BAA2BoI,UAAU,EAAE,CAAC;UAEtD,IAAIA,UAAU,KAAK,CAAC,CAAC,EAAE;YACrB,MAAMpF,KAAK,GAAGkF,QAAQ,CAACE,UAAU,CAAC;YAClC,MAAM,CAACzF,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAGG,KAAK,CAACC,QAAQ;YAChCjD,aAAa,CAAC,YAAYgD,KAAK,CAACX,OAAO,iBAAiBM,CAAC,KAAKC,CAAC,KAAKC,CAAC,GAAG,CAAC;YACzE7C,aAAa,CAAC,oBAAoB,EAAEgD,KAAK,CAACsB,MAAM,CAAC;;YAEjD;YACA,MAAM6C,YAAY,GAAG,EAAE;YACvB,IAAIxE,CAAC,KAAK,CAAC,EAAEwE,YAAY,CAACrE,IAAI,CAAC,OAAO,CAAC;YACvC,IAAIH,CAAC,KAAK,CAAC,CAAC,EAAEwE,YAAY,CAACrE,IAAI,CAAC,MAAM,CAAC;YACvC,IAAIF,CAAC,KAAK,CAAC,EAAEuE,YAAY,CAACrE,IAAI,CAAC,KAAK,CAAC;YACrC,IAAIF,CAAC,KAAK,CAAC,CAAC,EAAEuE,YAAY,CAACrE,IAAI,CAAC,QAAQ,CAAC;YACzC,IAAID,CAAC,KAAK,CAAC,EAAEsE,YAAY,CAACrE,IAAI,CAAC,OAAO,CAAC;YACvC,IAAID,CAAC,KAAK,CAAC,CAAC,EAAEsE,YAAY,CAACrE,IAAI,CAAC,MAAM,CAAC;YAEvC9C,aAAa,CAAC,mBAAmB,EAAEmH,YAAY,CAAC;;YAEhD;YACA,MAAMmB,aAAa,GAAG;cAAE,GAAGtF,KAAK,CAACsB;YAAO,CAAC;YACzC,IAAIiE,QAAQ,GAAG,KAAK;YAEpBpB,YAAY,CAACjD,OAAO,CAACe,IAAI,IAAI;cAC3BjF,aAAa,CAAC,oBAAoBiF,IAAI,qBAAqBqD,aAAa,CAACrD,IAAI,CAAC,EAAE,CAAC;cACjF,IAAIqD,aAAa,CAACrD,IAAI,CAAC,KAAK,SAAS,IAAIqD,aAAa,CAACrD,IAAI,CAAC,KAAK,OAAO,IAAIqD,aAAa,CAACrD,IAAI,CAAC,KAAK,SAAS,EAAE;gBAC7G;gBACA,QAAQA,IAAI;kBACV,KAAK,OAAO;oBACVqD,aAAa,CAACrD,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACjC;kBACF,KAAK,MAAM;oBACTqD,aAAa,CAACrD,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACjC;kBACF,KAAK,OAAO;oBACVqD,aAAa,CAACrD,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACjC;kBACF,KAAK,MAAM;oBACTqD,aAAa,CAACrD,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACjC;kBACF,KAAK,KAAK;oBACRqD,aAAa,CAACrD,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACjC;kBACF,KAAK,QAAQ;oBACXqD,aAAa,CAACrD,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACjC;gBACJ;gBACAjF,aAAa,CAAC,iBAAiBiF,IAAI,OAAOqD,aAAa,CAACrD,IAAI,CAAC,EAAE,CAAC;gBAChEsD,QAAQ,GAAG,IAAI;cACjB;YACF,CAAC,CAAC;YAEF,IAAIA,QAAQ,EAAE;cACZL,QAAQ,CAACE,UAAU,CAAC,GAAG;gBACrB,GAAGpF,KAAK;gBACRsB,MAAM,EAAEgE;cACV,CAAC;cACDtI,aAAa,CAAC,oBAAoBgD,KAAK,CAACX,OAAO,mBAAmB,EAAEiG,aAAa,CAAC;YACpF,CAAC,MAAM;cACLtI,aAAa,CAAC,kCAAkCgD,KAAK,CAACX,OAAO,EAAE,CAAC;YAClE;UACF,CAAC,MAAM;YACLrC,aAAa,CAAC,kCAAkCmI,cAAc,CAAC9F,OAAO,gBAAgB,CAAC;UACzF;QACF,CAAC,CAAC;QAEFrC,aAAa,CAAC,sCAAsC,CAAC;QACrDA,aAAa,CAAC,sBAAsB,EAAEkI,QAAQ,CAACtE,MAAM,CAAC;QACtD,OAAOsE,QAAQ;MACjB,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACAlI,aAAa,CAAC,uCAAuC,CAAC;MACtDyB,YAAY,CAACwG,SAAS,IAAI;QACxBjI,aAAa,CAAC,+CAA+C,EAAEiI,SAAS,CAACrE,MAAM,CAAC;QAChF,MAAMsE,QAAQ,GAAG,CAAC,GAAGD,SAAS,CAAC;QAE/BP,gBAAgB,CAAC5D,eAAe,CAACI,OAAO,CAACiE,cAAc,IAAI;UACzDnI,aAAa,CAAC,uBAAuBmI,cAAc,CAAC9F,OAAO,KAAK,CAAC;UACjE,MAAM+F,UAAU,GAAGF,QAAQ,CAACG,SAAS,CAAC1I,CAAC,IAAIA,CAAC,CAAC0C,OAAO,KAAK8F,cAAc,CAAC9F,OAAO,CAAC;UAChFrC,aAAa,CAAC,2BAA2BoI,UAAU,EAAE,CAAC;UAEtD,IAAIA,UAAU,KAAK,CAAC,CAAC,EAAE;YACrB,MAAMpF,KAAK,GAAGkF,QAAQ,CAACE,UAAU,CAAC;YAClC,MAAM,CAACzF,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAGG,KAAK,CAACC,QAAQ;YAChCjD,aAAa,CAAC,YAAYgD,KAAK,CAACX,OAAO,iBAAiBM,CAAC,KAAKC,CAAC,KAAKC,CAAC,GAAG,CAAC;YACzE7C,aAAa,CAAC,oBAAoB,EAAEgD,KAAK,CAACsB,MAAM,CAAC;;YAEjD;YACA,MAAM6C,YAAY,GAAG,EAAE;YACvB,IAAIxE,CAAC,KAAK,CAAC,EAAEwE,YAAY,CAACrE,IAAI,CAAC,OAAO,CAAC;YACvC,IAAIH,CAAC,KAAK,CAAC,CAAC,EAAEwE,YAAY,CAACrE,IAAI,CAAC,MAAM,CAAC;YACvC,IAAIF,CAAC,KAAK,CAAC,EAAEuE,YAAY,CAACrE,IAAI,CAAC,KAAK,CAAC;YACrC,IAAIF,CAAC,KAAK,CAAC,CAAC,EAAEuE,YAAY,CAACrE,IAAI,CAAC,QAAQ,CAAC;YACzC,IAAID,CAAC,KAAK,CAAC,EAAEsE,YAAY,CAACrE,IAAI,CAAC,OAAO,CAAC;YACvC,IAAID,CAAC,KAAK,CAAC,CAAC,EAAEsE,YAAY,CAACrE,IAAI,CAAC,MAAM,CAAC;YAEvC9C,aAAa,CAAC,mBAAmB,EAAEmH,YAAY,CAAC;;YAEhD;YACA,MAAMmB,aAAa,GAAG;cAAE,GAAGtF,KAAK,CAACsB;YAAO,CAAC;YACzC,IAAIiE,QAAQ,GAAG,KAAK;YAEpBpB,YAAY,CAACjD,OAAO,CAACe,IAAI,IAAI;cAC3BjF,aAAa,CAAC,oBAAoBiF,IAAI,qBAAqBqD,aAAa,CAACrD,IAAI,CAAC,EAAE,CAAC;cACjF,IAAIqD,aAAa,CAACrD,IAAI,CAAC,KAAK,SAAS,IAAIqD,aAAa,CAACrD,IAAI,CAAC,KAAK,OAAO,IAAIqD,aAAa,CAACrD,IAAI,CAAC,KAAK,SAAS,EAAE;gBAC7G;gBACA,QAAQA,IAAI;kBACV,KAAK,OAAO;oBACVqD,aAAa,CAACrD,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACjC;kBACF,KAAK,MAAM;oBACTqD,aAAa,CAACrD,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACjC;kBACF,KAAK,OAAO;oBACVqD,aAAa,CAACrD,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACjC;kBACF,KAAK,MAAM;oBACTqD,aAAa,CAACrD,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACjC;kBACF,KAAK,KAAK;oBACRqD,aAAa,CAACrD,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACjC;kBACF,KAAK,QAAQ;oBACXqD,aAAa,CAACrD,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACjC;gBACJ;gBACAjF,aAAa,CAAC,iBAAiBiF,IAAI,OAAOqD,aAAa,CAACrD,IAAI,CAAC,EAAE,CAAC;gBAChEsD,QAAQ,GAAG,IAAI;cACjB;YACF,CAAC,CAAC;YAEF,IAAIA,QAAQ,EAAE;cACZL,QAAQ,CAACE,UAAU,CAAC,GAAG;gBACrB,GAAGpF,KAAK;gBACRsB,MAAM,EAAEgE;cACV,CAAC;cACDtI,aAAa,CAAC,oBAAoBgD,KAAK,CAACX,OAAO,mBAAmB,EAAEiG,aAAa,CAAC;YACpF,CAAC,MAAM;cACLtI,aAAa,CAAC,kCAAkCgD,KAAK,CAACX,OAAO,EAAE,CAAC;YAClE;UACF,CAAC,MAAM;YACLrC,aAAa,CAAC,kCAAkCmI,cAAc,CAAC9F,OAAO,gBAAgB,CAAC;UACzF;QACF,CAAC,CAAC;QAEFrC,aAAa,CAAC,sCAAsC,CAAC;QACrDA,aAAa,CAAC,sBAAsB,EAAEkI,QAAQ,CAACtE,MAAM,CAAC;QACtD,OAAOsE,QAAQ;MACjB,CAAC,CAAC;IACJ;;IAEA;IACApG,wBAAwB,CAAC0D,IAAI,KAAK;MAChC,GAAGA,IAAI;MACPgD,UAAU,EAAE;IACd,CAAC,CAAC,CAAC;;IAEH;IACA,IAAIhH,gBAAgB,EAAE;MACpBA,gBAAgB,CAAC;QACfqC,IAAI,EAAE,YAAY;QAClBE,KAAK,EAAE,CAAC;QACR6C,eAAe,EAAE,CAAC;QAClB9C,eAAe,EAAE;MACnB,CAAC,CAAC;IACJ;EACF,CAAC;EAED,MAAM2E,cAAc,GAAGA,CAAC5E,IAAI,EAAE0D,UAAU,KAAK;IAC3C,MAAMmB,GAAG,GAAG,GAAG7E,IAAI,IAAI0D,UAAU,EAAE;IACnC,MAAMhC,MAAM,GAAG1D,qBAAqB,CAAC6G,GAAG,CAAC;IACzC,MAAMC,QAAQ,GAAGhH,oBAAoB,KAAK+G,GAAG;IAE7C,OAAO;MACLC,QAAQ;MACRC,YAAY,EAAErD,MAAM,IAAIA,MAAM,CAACxB,KAAK,GAAG,CAAC;MACxCA,KAAK,EAAEwB,MAAM,GAAGA,MAAM,CAACxB,KAAK,GAAG;IACjC,CAAC;EACH,CAAC;;EAED;EACA,MAAM8E,oBAAoB,GAAGA,CAAA,KAAM;IACjC,MAAMvG,UAAU,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,UAAU,EAAE,SAAS,CAAC;IAC9D,MAAME,WAAW,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,MAAM,CAAC;IAC7G,MAAMa,YAAY,GAAG,CACnB;MAAEyF,IAAI,EAAE,OAAO;MAAEC,GAAG,EAAE,SAAS;MAAE3F,SAAS,EAAE;IAAE,CAAC,EAC/C;MAAE0F,IAAI,EAAE,QAAQ;MAAEC,GAAG,EAAE,SAAS;MAAE3F,SAAS,EAAE;IAAE,CAAC,EAChD;MAAE0F,IAAI,EAAE,OAAO;MAAEC,GAAG,EAAE,SAAS;MAAE3F,SAAS,EAAE;IAAE,CAAC,EAC/C;MAAE0F,IAAI,EAAE,KAAK;MAAEC,GAAG,EAAE,SAAS;MAAE3F,SAAS,EAAE;IAAE,CAAC,EAC7C;MAAE0F,IAAI,EAAE,MAAM;MAAEC,GAAG,EAAE,SAAS;MAAE3F,SAAS,EAAE;IAAE,CAAC,EAC9C;MAAE0F,IAAI,EAAE,QAAQ;MAAEC,GAAG,EAAE,SAAS;MAAE3F,SAAS,EAAE;IAAE,CAAC,CACjD;IAED,MAAM4F,YAAY,GAAG,EAAE;IACvB1G,UAAU,CAAC4B,OAAO,CAAC6B,SAAS,IAAI;MAC9BvD,WAAW,CAAC0B,OAAO,CAACT,UAAU,IAAI;QAChCJ,YAAY,CAACa,OAAO,CAAC+E,WAAW,IAAI;UAClCD,YAAY,CAAClG,IAAI,CAAC;YAChBoG,EAAE,EAAE,GAAGnD,SAAS,IAAItC,UAAU,IAAIwF,WAAW,CAACH,IAAI,EAAE;YACpD/C,SAAS;YACTtC,UAAU;YACVwF,WAAW,EAAEA,WAAW,CAACH,IAAI;YAC7BvC,cAAc,EAAE0C,WAAW,CAACF,GAAG;YAC/B3F,SAAS,EAAE6F,WAAW,CAAC7F;UACzB,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAO4F,YAAY;EACrB,CAAC;;EAED;EACA,MAAMG,4BAA4B,GAAIC,WAAW,IAAK;IACpD,MAAMtF,eAAe,GAAG+B,MAAM,CAACG,MAAM,CAAChD,KAAK,IAAI;MAC7C,MAAMX,OAAO,GAAGW,KAAK,CAACX,OAAO;MAC7B,MAAM4D,eAAe,GAAG7D,YAAY,CAACC,OAAO,CAAC;MAC7C,MAAM+D,gBAAgB,GAAG7D,aAAa,CAACF,OAAO,CAAC;MAC/C,MAAMmE,mBAAmB,GAAGzD,wBAAwB,CAACC,KAAK,EAAEX,OAAO,CAAC;;MAEpE;MACA,MAAMgH,YAAY,GAAGpD,eAAe,KAAKmD,WAAW,CAACrD,SAAS;MAC9D,MAAMuD,YAAY,GAAGlD,gBAAgB,KAAKgD,WAAW,CAAC3F,UAAU;;MAEhE;MACA,MAAM,CAACd,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAGG,KAAK,CAACC,QAAQ;MAChC,IAAIwD,qBAAqB,GAAG,KAAK;MAEjC,QAAQ2C,WAAW,CAAChG,SAAS;QAC3B,KAAK,CAAC;UAAE;UACNqD,qBAAqB,GAAG5D,CAAC,KAAK,CAAC;UAC/B;QACF,KAAK,CAAC;UAAE;UACN4D,qBAAqB,GAAG5D,CAAC,KAAK,CAAC,CAAC;UAChC;QACF,KAAK,CAAC;UAAE;UACN4D,qBAAqB,GAAG9D,CAAC,KAAK,CAAC;UAC/B;QACF,KAAK,CAAC;UAAE;UACN8D,qBAAqB,GAAG9D,CAAC,KAAK,CAAC,CAAC;UAChC;QACF,KAAK,CAAC;UAAE;UACN8D,qBAAqB,GAAG7D,CAAC,KAAK,CAAC;UAC/B;QACF,KAAK,CAAC;UAAE;UACN6D,qBAAqB,GAAG7D,CAAC,KAAK,CAAC,CAAC;UAChC;MACJ;;MAEA;MACA,OAAOyG,YAAY,IAAIC,YAAY,IAAI7C,qBAAqB,IAAI,CAACD,mBAAmB;IACtF,CAAC,CAAC;IAEF,MAAMjB,MAAM,GAAG;MACb1B,IAAI,EAAE,aAAa;MACnBuF,WAAW;MACXtF,eAAe,EAAEA,eAAe,CAAC6B,GAAG,CAAC3C,KAAK,KAAK;QAC7CX,OAAO,EAAEW,KAAK,CAACX,OAAO;QACtB0D,SAAS,EAAE3D,YAAY,CAACY,KAAK,CAACX,OAAO,CAAC;QACtCoB,UAAU,EAAElB,aAAa,CAACS,KAAK,CAACX,OAAO,CAAC;QACxCgD,eAAe,EAAErC,KAAK,CAACC,QAAQ;QAC/BC,gBAAgB,EAAET,mBAAmB,CAACO,KAAK,CAACX,OAAO,CAAC;QACpDiC,MAAM,EAAEtB,KAAK,CAACsB,MAAM;QACpBsB,eAAe,EAAE5C,KAAK,CAAC4C;MACzB,CAAC,CAAC,CAAC;MACH7B,KAAK,EAAED,eAAe,CAACF;IACzB,CAAC;IAED9B,wBAAwB,CAAC0D,IAAI,KAAK;MAChC,GAAGA,IAAI;MACP,CAAC,eAAe4D,WAAW,CAACF,EAAE,EAAE,GAAG3D;IACrC,CAAC,CAAC,CAAC;IAEHvF,aAAa,CAAC,2BAA2BoJ,WAAW,CAAC3F,UAAU,IAAI2F,WAAW,CAACrD,SAAS,SAASqD,WAAW,CAACH,WAAW,SAAS,EAAE1D,MAAM,CAAC;IAE1I,IAAI/D,gBAAgB,EAAE;MACpBA,gBAAgB,CAAC+D,MAAM,CAAC;IAC1B;IAEA,OAAOA,MAAM;EACf,CAAC;EAED,MAAMgE,sBAAsB,GAAIH,WAAW,IAAK;IAC9C,IAAI9H,YAAY,EAAE;IAElBM,uBAAuB,CAAC,eAAewH,WAAW,CAACF,EAAE,EAAE,CAAC;IACxD,MAAM3D,MAAM,GAAG4D,4BAA4B,CAACC,WAAW,CAAC;;IAExD;IACA5B,UAAU,CAAC,MAAM;MACf5F,uBAAuB,CAAC,IAAI,CAAC;IAC/B,CAAC,EAAE,IAAI,CAAC;EACV,CAAC;EAED,MAAM4H,yBAAyB,GAAIJ,WAAW,IAAK;IACjD,MAAMV,GAAG,GAAG,eAAeU,WAAW,CAACF,EAAE,EAAE;IAC3C,MAAM3D,MAAM,GAAG1D,qBAAqB,CAAC6G,GAAG,CAAC;IACzC,MAAMC,QAAQ,GAAGhH,oBAAoB,KAAK+G,GAAG;IAE7C,OAAO;MACLC,QAAQ;MACRC,YAAY,EAAErD,MAAM,IAAIA,MAAM,CAACxB,KAAK,GAAG,CAAC;MACxCA,KAAK,EAAEwB,MAAM,GAAGA,MAAM,CAACxB,KAAK,GAAG;IACjC,CAAC;EACH,CAAC;EAED,MAAMiF,YAAY,GAAGH,oBAAoB,CAAC,CAAC;EAE3C,oBACEnL,OAAA,CAACC,iBAAiB;IAAAoE,QAAA,gBAChBrE,OAAA,CAACI,YAAY;MAAAiE,QAAA,EAAC;IAAyB;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAc,CAAC,eACtDzE,OAAA,CAACgC,YAAY;MAAAqC,QAAA,EAAC;IAGd;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAc,CAAC,eAGfzE,OAAA;MAAAqE,QAAA,gBACErE,OAAA;QAAI+L,KAAK,EAAE;UAAEC,KAAK,EAAE,OAAO;UAAEC,YAAY,EAAE,MAAM;UAAEC,QAAQ,EAAE;QAAO,CAAE;QAAA7H,QAAA,EAAC;MAAkC;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAI,CAAC,eAC9GzE,OAAA,CAACO,UAAU;QAACwL,KAAK,EAAE;UAAEI,mBAAmB,EAAE,sCAAsC;UAAEF,YAAY,EAAE;QAAO,CAAE;QAAA5H,QAAA,gBAEvGrE,OAAA,CAACS,cAAc;UACb2L,OAAO,EAAEA,CAAA,KAAMxC,iBAAiB,CAAC,kBAAkB,EAAE,KAAK,CAAE;UAC5D9I,QAAQ,EAAE8C,YAAa;UACvBhD,SAAS,EAAEqD,oBAAoB,KAAK,sBAAuB;UAC3DpD,aAAa,EAAEsD,qBAAqB,CAAC,kBAAkB,CAAC,IAAIA,qBAAqB,CAAC,kBAAkB,CAAC,CAACkC,KAAK,GAAG,CAAE;UAChH0F,KAAK,EAAE;YACLR,WAAW,EAAE,SAAS;YACtBc,WAAW,EAAE,KAAK;YAClBC,UAAU,EAAE;UACd,CAAE;UAAAjI,QAAA,eAEFrE,OAAA,CAACgB,aAAa;YAAAqD,QAAA,gBACZrE,OAAA;cAAK+L,KAAK,EAAE;gBAAEG,QAAQ,EAAE,MAAM;gBAAED,YAAY,EAAE;cAAM,CAAE;cAAA5H,QAAA,EAAC;YAAE;cAAAC,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAK,CAAC,eAC/DzE,OAAA,CAAC4B,WAAW;cAACmK,KAAK,EAAE;gBAAEC,KAAK,EAAE,SAAS;gBAAEO,UAAU,EAAE;cAAO,CAAE;cAAAlI,QAAA,EAAC;YAE9D;cAAAC,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAa,CAAC,eACdzE,OAAA,CAAC8B,cAAc;cAAAuC,QAAA,EAAC;YAEhB;cAAAC,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAgB,CAAC,EAChBN,qBAAqB,CAAC,kBAAkB,CAAC,IAAIA,qBAAqB,CAAC,kBAAkB,CAAC,CAACkC,KAAK,GAAG,CAAC,iBAC/FrG,OAAA,CAACyB,UAAU;cAACZ,aAAa,EAAE,IAAK;cAAAwD,QAAA,GAC7BF,qBAAqB,CAAC,kBAAkB,CAAC,CAACkC,KAAK,EAAC,SACjD,eAAArG,OAAA;gBAAAsE,QAAA,EAAAC,YAAA;gBAAAC,UAAA;gBAAAC,YAAA;cAAA,OAAK,CAAC,EACLN,qBAAqB,CAAC,kBAAkB,CAAC,CAACmC,mBAAmB,EAAC,QACjE;YAAA;cAAAhC,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAY,CACb;UAAA;YAAAH,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OACY;QAAC;UAAAH,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACF,CAAC,eACjBzE,OAAA,CAACS,cAAc;UACb2L,OAAO,EAAEA,CAAA,KAAMxC,iBAAiB,CAAC,YAAY,EAAE,KAAK,CAAE;UACtD9I,QAAQ,EAAE8C,YAAa;UACvBhD,SAAS,EAAEqD,oBAAoB,KAAK,gBAAiB;UACrDpD,aAAa,EAAEsD,qBAAqB,CAAC,YAAY,CAAC,IAAIA,qBAAqB,CAAC,YAAY,CAAC,CAACkC,KAAK,GAAG,CAAE;UACpG0F,KAAK,EAAE;YACLO,UAAU,EAAE,sBAAsB;YAClCf,WAAW,EAAE,SAAS;YACtBc,WAAW,EAAE,KAAK;YAClBG,OAAO,EAAE,MAAM,CAAC;UAClB,CAAE;UAAAnI,QAAA,eAEFrE,OAAA,CAACgB,aAAa;YAAAqD,QAAA,gBACZrE,OAAA;cAAK+L,KAAK,EAAE;gBAAEG,QAAQ,EAAE,MAAM;gBAAED,YAAY,EAAE;cAAM,CAAE;cAAA5H,QAAA,EAAC;YAAC;cAAAC,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAK,CAAC,eAC9DzE,OAAA,CAAC4B,WAAW;cAACmK,KAAK,EAAE;gBAAEC,KAAK,EAAE,SAAS;gBAAEO,UAAU,EAAE;cAAO,CAAE;cAAAlI,QAAA,EAAC;YAE9D;cAAAC,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAa,CAAC,eACdzE,OAAA,CAAC8B,cAAc;cAAAuC,QAAA,EAAC;YAEhB;cAAAC,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAgB,CAAC,EAChBN,qBAAqB,CAAC,YAAY,CAAC,IAAIA,qBAAqB,CAAC,YAAY,CAAC,CAACkC,KAAK,GAAG,CAAC,iBACnFrG,OAAA,CAACyB,UAAU;cAACZ,aAAa,EAAE,IAAK;cAAAwD,QAAA,GAC7BF,qBAAqB,CAAC,YAAY,CAAC,CAACkC,KAAK,EAAC,SAC3C,eAAArG,OAAA;gBAAAsE,QAAA,EAAAC,YAAA;gBAAAC,UAAA;gBAAAC,YAAA;cAAA,OAAK,CAAC,EACLN,qBAAqB,CAAC,YAAY,CAAC,CAAC+E,eAAe,EAAC,QACvD;YAAA;cAAA5E,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAY,CACb;UAAA;YAAAH,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OACY;QAAC;UAAAH,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACF,CAAC,eAGjBzE,OAAA,CAACS,cAAc;UACb2L,OAAO,EAAEA,CAAA,KAAM;YACb9J,aAAa,CAAC,+CAA+C,CAAC;YAC9DA,aAAa,CAAC,kBAAkB,EAAEsB,YAAY,CAAC;YAC/CmG,yBAAyB,CAAC,CAAC;UAC7B,CAAE;UACFjJ,QAAQ,EAAE8C,YAAa;UACvBhD,SAAS,EAAE,KAAM;UACjBC,aAAa,EAAE,KAAM;UACrBkL,KAAK,EAAE;YACLR,WAAW,EAAE,SAAS;YACtBc,WAAW,EAAE,KAAK;YAClBC,UAAU,EAAE;UACd,CAAE;UAAAjI,QAAA,eAEFrE,OAAA,CAACgB,aAAa;YAAAqD,QAAA,gBACZrE,OAAA;cAAK+L,KAAK,EAAE;gBAAEG,QAAQ,EAAE,MAAM;gBAAED,YAAY,EAAE;cAAM,CAAE;cAAA5H,QAAA,EAAC;YAAE;cAAAC,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAK,CAAC,eAC/DzE,OAAA,CAAC4B,WAAW;cAACmK,KAAK,EAAE;gBAAEC,KAAK,EAAE,SAAS;gBAAEO,UAAU,EAAE;cAAO,CAAE;cAAAlI,QAAA,EAAC;YAE9D;cAAAC,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAa,CAAC,eACdzE,OAAA,CAAC8B,cAAc;cAAAuC,QAAA,EAAC;YAEhB;cAAAC,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAgB,CAAC;UAAA;YAAAH,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OACJ;QAAC;UAAAH,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACF,CAAC;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACP,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACV,CAAC,eAGNzE,OAAA;MAAAqE,QAAA,gBACErE,OAAA;QAAI+L,KAAK,EAAE;UAAEC,KAAK,EAAE,OAAO;UAAEC,YAAY,EAAE,MAAM;UAAEC,QAAQ,EAAE;QAAO,CAAE;QAAA7H,QAAA,EAAC;MAAsC;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAI,CAAC,eAClHzE,OAAA,CAACO,UAAU;QAACwL,KAAK,EAAE;UAAEI,mBAAmB,EAAE;QAAuC,CAAE;QAAA9H,QAAA,EAChFiH,YAAY,CAACrD,GAAG,CAACyD,WAAW,IAAI;UAC/B,MAAMrB,KAAK,GAAGyB,yBAAyB,CAACJ,WAAW,CAAC;UAEpD,oBACE1L,OAAA,CAACS,cAAc;YAEb2L,OAAO,EAAEA,CAAA,KAAMP,sBAAsB,CAACH,WAAW,CAAE;YACnD5K,QAAQ,EAAE8C,YAAa;YACvBhD,SAAS,EAAEyJ,KAAK,CAACY,QAAS;YAC1BpK,aAAa,EAAEwJ,KAAK,CAACa,YAAa;YAClCa,KAAK,EAAE;cACLR,WAAW,EAAElB,KAAK,CAACa,YAAY,GAAG,SAAS,GAAGQ,WAAW,CAAC7C,cAAc;cACxEwD,WAAW,EAAE;YACf,CAAE;YAAAhI,QAAA,eAEFrE,OAAA,CAACgB,aAAa;cAAAqD,QAAA,gBACZrE,OAAA,CAACkB,cAAc;gBAAAmD,QAAA,GACZqH,WAAW,CAACrD,SAAS,KAAK,UAAU,gBACnCrI,OAAA;kBAAKyM,KAAK,EAAC,IAAI;kBAACC,MAAM,EAAC,IAAI;kBAACC,OAAO,EAAC,WAAW;kBAAAtI,QAAA,eAC7CrE,OAAA;oBACE4M,MAAM,EAAC,iBAAiB;oBACxBC,IAAI,EAAE/G,gBAAgB,CAAC4F,WAAW,CAAC3F,UAAU,CAAE;oBAC/C+G,MAAM,EAAEpB,WAAW,CAAC7C,cAAe;oBACnCkE,WAAW,EAAC;kBAAG;oBAAAzI,QAAA,EAAAC,YAAA;oBAAAC,UAAA;oBAAAC,YAAA;kBAAA,OAChB;gBAAC;kBAAAH,QAAA,EAAAC,YAAA;kBAAAC,UAAA;kBAAAC,YAAA;gBAAA,OACC,CAAC,gBAENzE,OAAA,CAACoB,WAAW;kBACVG,UAAU,EAAEmK,WAAW,CAACrD,SAAU;kBAClChH,WAAW,EAAEyE,gBAAgB,CAAC4F,WAAW,CAAC3F,UAAU,CAAE;kBACtDzE,YAAY,EAAEoK,WAAW,CAAC7C;gBAAe;kBAAAvE,QAAA,EAAAC,YAAA;kBAAAC,UAAA;kBAAAC,YAAA;gBAAA,OAC1C,CACF,EACA4F,KAAK,CAAChE,KAAK,GAAG,CAAC,iBACdrG,OAAA,CAACyB,UAAU;kBAACZ,aAAa,EAAEwJ,KAAK,CAACa,YAAa;kBAAA7G,QAAA,EAC3CgG,KAAK,CAAChE;gBAAK;kBAAA/B,QAAA,EAAAC,YAAA;kBAAAC,UAAA;kBAAAC,YAAA;gBAAA,OACF,CACb;cAAA;gBAAAH,QAAA,EAAAC,YAAA;gBAAAC,UAAA;gBAAAC,YAAA;cAAA,OACa,CAAC,eACjBzE,OAAA,CAAC4B,WAAW;gBAAAyC,QAAA,GACTqH,WAAW,CAAC3F,UAAU,EAAC,GAAC,EAAC2F,WAAW,CAACrD,SAAS;cAAA;gBAAA/D,QAAA,EAAAC,YAAA;gBAAAC,UAAA;gBAAAC,YAAA;cAAA,OACpC,CAAC;YAAA;cAAAH,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OACD;UAAC,GArCX,eAAeiH,WAAW,CAACF,EAAE,EAAE;YAAAlH,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAsCtB,CAAC;QAErB,CAAC;MAAC;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACQ,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACV,CAAC,EAGLR,oBAAoB,iBACnBjE,OAAA,CAACmC,aAAa;MAACC,KAAK,EAAC,SAAS;MAAAiC,QAAA,EAAC;IAE/B;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAe,CAChB;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACgB,CAAC;AAExB;AAACT,EAAA,CAjgCQL,uBAAuB;AAAAqJ,IAAA,GAAvBrJ,uBAAuB;AAmgChC,eAAeA,uBAAuB;AAAC,IAAAxD,EAAA,EAAAG,GAAA,EAAAE,GAAA,EAAAO,GAAA,EAAAE,GAAA,EAAAE,GAAA,EAAAK,GAAA,EAAAG,GAAA,EAAAE,GAAA,EAAAE,GAAA,EAAAG,GAAA,EAAAG,IAAA,EAAA2K,IAAA;AAAAC,YAAA,CAAA9M,EAAA;AAAA8M,YAAA,CAAA3M,GAAA;AAAA2M,YAAA,CAAAzM,GAAA;AAAAyM,YAAA,CAAAlM,GAAA;AAAAkM,YAAA,CAAAhM,GAAA;AAAAgM,YAAA,CAAA9L,GAAA;AAAA8L,YAAA,CAAAzL,GAAA;AAAAyL,YAAA,CAAAtL,GAAA;AAAAsL,YAAA,CAAApL,GAAA;AAAAoL,YAAA,CAAAlL,GAAA;AAAAkL,YAAA,CAAA/K,GAAA;AAAA+K,YAAA,CAAA5K,IAAA;AAAA4K,YAAA,CAAAD,IAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}