{"ast":null,"code":"var _jsxFileName = \"C:\\\\Repo\\\\GitHub\\\\rubiks-cube\\\\src\\\\components\\\\IdentifyIncorrectShapes.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport styled from 'styled-components';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst IdentifyContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 20px;\n  padding: 20px;\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 15px;\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);\n  max-height: 500px;\n  overflow-y: auto;\n`;\n_c = IdentifyContainer;\nconst SectionTitle = styled.h3`\n  color: white;\n  text-align: center;\n  margin: 0 0 15px 0;\n  font-size: 1.3rem;\n  font-weight: 600;\n  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\n`;\n_c2 = SectionTitle;\nconst ButtonGrid = styled.div`\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  gap: 15px;\n  margin-bottom: 20px;\n`;\n_c3 = ButtonGrid;\nconst IdentifyButton = styled.button`\n  padding: 12px 16px;\n  border: 2px solid ${props => {\n  if (props.$isActive) return '#4CAF50';\n  if (props.$hasIncorrect) return '#ff4757';\n  return 'rgba(255, 255, 255, 0.3)';\n}};\n  border-radius: 10px;\n  font-size: 14px;\n  font-weight: 600;\n  cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};\n  transition: all 0.3s ease;\n  background: ${props => {\n  if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\n  if (props.$isActive) return 'rgba(76, 175, 80, 0.2)';\n  if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.2)';\n  return 'rgba(255, 255, 255, 0.1)';\n}};\n  color: ${props => {\n  if (props.disabled) return '#666';\n  if (props.$isActive) return '#4CAF50';\n  if (props.$hasIncorrect) return '#ff4757';\n  return 'white';\n}};\n  opacity: ${props => props.disabled ? 0.5 : 1};\n  \n  &:hover {\n    transform: ${props => props.disabled ? 'none' : 'translateY(-2px)'};\n    box-shadow: ${props => props.disabled ? 'none' : '0 4px 12px rgba(0, 0, 0, 0.3)'};\n    background: ${props => {\n  if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\n  if (props.$isActive) return 'rgba(76, 175, 80, 0.3)';\n  if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.3)';\n  return 'rgba(255, 255, 255, 0.2)';\n}};\n  }\n  \n  &:active {\n    transform: ${props => props.disabled ? 'none' : 'translateY(0)'};\n  }\n`;\n_c4 = IdentifyButton;\nconst ButtonContent = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 4px;\n  width: 100%;\n  height: 100%;\n  position: relative;\n`;\n_c5 = ButtonContent;\nconst ShapeContainer = styled.div`\n  width: 60px;\n  height: 60px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n  margin: 8px 0;\n`;\n_c6 = ShapeContainer;\nconst ShapeVisual = styled.div`\n  width: 50px;\n  height: 50px;\n  background: ${props => props.$shapeColor};\n  border: 3px solid ${props => props.$borderColor};\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  \n  /* Shape-specific styling */\n  border-radius: ${props => {\n  if (props.$shapeType === 'Circle') return '50%';\n  if (props.$shapeType === 'Diamond') return '0';\n  return '0';\n}};\n  \n  transform: ${props => {\n  if (props.$shapeType === 'Diamond') return 'rotate(45deg)';\n  return 'none';\n}};\n  \n  /* Triangle shape using CSS */\n  ${props => props.$shapeType === 'Triangle' && `\n    width: 0;\n    height: 0;\n    background: transparent;\n    border: none;\n    border-left: 25px solid transparent;\n    border-right: 25px solid transparent;\n    border-bottom: 43px solid ${props.$shapeColor};\n    position: relative;\n  `}\n`;\n_c7 = ShapeVisual;\nconst CountBadge = styled.span`\n  background: ${props => props.$hasIncorrect ? '#ff4757' : '#4CAF50'};\n  color: white;\n  border-radius: 50%;\n  width: 20px;\n  height: 20px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 10px;\n  font-weight: bold;\n  position: absolute;\n  top: -5px;\n  right: -5px;\n  z-index: 10;\n`;\n_c8 = CountBadge;\nconst ButtonTitle = styled.span`\n  font-size: 12px;\n  font-weight: 600;\n  color: white;\n  text-align: center;\n  margin-top: 4px;\n`;\n_c9 = ButtonTitle;\nconst ButtonSubtitle = styled.div`\n  font-size: 10px;\n  color: rgba(255, 255, 255, 0.8);\n  text-align: center;\n  margin-top: 2px;\n  line-height: 1.2;\n`;\n_c0 = ButtonSubtitle;\nconst Instructions = styled.p`\n  color: rgba(255, 255, 255, 0.8);\n  font-size: 13px;\n  text-align: center;\n  margin: 0 0 15px 0;\n  line-height: 1.4;\n`;\n_c1 = Instructions;\nconst StatusMessage = styled.div`\n  padding: 10px;\n  border-radius: 8px;\n  text-align: center;\n  font-size: 12px;\n  font-weight: 600;\n  background: ${props => {\n  if (props.$type === 'success') return 'rgba(76, 175, 80, 0.2)';\n  if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.2)';\n  if (props.$type === 'error') return 'rgba(244, 67, 54, 0.2)';\n  return 'rgba(33, 150, 243, 0.2)';\n}};\n  color: ${props => {\n  if (props.$type === 'success') return '#4CAF50';\n  if (props.$type === 'warning') return '#FFC107';\n  if (props.$type === 'error') return '#f44336';\n  return '#2196F3';\n}};\n  border: 1px solid ${props => {\n  if (props.$type === 'success') return 'rgba(76, 175, 80, 0.3)';\n  if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.3)';\n  if (props.$type === 'error') return 'rgba(244, 67, 54, 0.3)';\n  return 'rgba(33, 150, 243, 0.3)';\n}};\n`;\n\n// Custom logging function\n_c10 = StatusMessage;\nconst logToTerminal = (message, data = null) => {\n  console.log(`\\n🎯 ${message}`);\n  if (data) {\n    console.log(JSON.stringify(data, null, 2));\n  }\n  console.log('='.repeat(80) + '\\n');\n\n  // Send to log server\n  fetch('http://localhost:3001/log', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      message: message,\n      data: data\n    })\n  }).then(response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    console.log('✅ Log sent to terminal successfully');\n  }).catch(error => {\n    console.error('❌ Could not send log to terminal server:', error);\n  });\n};\nfunction IdentifyIncorrectShapes({\n  isScrambling,\n  cubeState,\n  onIdentification\n}) {\n  _s();\n  const [activeIdentification, setActiveIdentification] = useState(null);\n  const [identificationResults, setIdentificationResults] = useState({});\n\n  // Helper functions\n  const getShapeType = pieceId => {\n    const shapeTypes = ['Square', 'Square', 'Square', 'Square', 'Square', 'Circle', 'Circle', 'Circle', 'Circle', 'Circle', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle'];\n    return shapeTypes[pieceId] || 'Unknown';\n  };\n  const getShapeColor = pieceId => {\n    const shapeColors = ['Red', 'Blue', 'Green', 'Orange', 'Purple', 'Red', 'Blue', 'Green', 'Orange', 'Yellow', 'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple', 'Red', 'Blue', 'Green', 'Orange', 'Purple', 'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple', 'Yellow'];\n    return shapeColors[pieceId] || 'Unknown';\n  };\n  const getExpectedPosition = pieceId => {\n    const positions = [];\n    for (let x = -1; x <= 1; x++) {\n      for (let y = -1; y <= 1; y++) {\n        for (let z = -1; z <= 1; z++) {\n          if (x === 0 && y === 0 && z === 0) continue;\n          positions.push([x, y, z]);\n        }\n      }\n    }\n    return positions[pieceId];\n  };\n  const isPieceInCorrectPosition = (piece, pieceId) => {\n    if (!piece || !piece.position) return false;\n    const expectedPosition = getExpectedPosition(pieceId);\n    return JSON.stringify(piece.position) === JSON.stringify(expectedPosition);\n  };\n  const getExpectedBorderColor = faceIndex => {\n    const borderColors = ['#FFFFFF',\n    // Face 0 (front) - White\n    '#FF8C00',\n    // Face 1 (back) - Orange  \n    '#00FF00',\n    // Face 2 (right) - Green\n    '#DC143C',\n    // Face 3 (left) - Red\n    '#0000FF',\n    // Face 4 (top) - Blue\n    '#FFD700' // Face 5 (bottom) - Yellow\n    ];\n    return borderColors[faceIndex] || '#000000';\n  };\n  const getBorderColorName = faceIndex => {\n    const colorNames = ['White', 'Orange', 'Green', 'Red', 'Blue', 'Yellow'];\n    return colorNames[faceIndex] || 'Unknown';\n  };\n  const getShapeColorHex = shapeColor => {\n    const colorMap = {\n      'Red': '#DC143C',\n      'Blue': '#0000FF',\n      'Green': '#00FF00',\n      'Orange': '#FF8C00',\n      'Purple': '#800080',\n      'Yellow': '#FFD700',\n      'Cyan': '#00FFFF',\n      'Magenta': '#FF00FF',\n      'Lime': '#00FF00',\n      'Pink': '#FFC0CB'\n    };\n    return colorMap[shapeColor] || '#000000';\n  };\n\n  // Get pieces data\n  const getPieces = () => {\n    if (Array.isArray(cubeState)) {\n      return cubeState.map((piece, index) => ({\n        pieceId: index,\n        position: piece.position,\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory || []\n      }));\n    } else if (cubeState !== null && cubeState !== void 0 && cubeState.pieces) {\n      return cubeState.pieces;\n    }\n    return [];\n  };\n  const pieces = getPieces();\n\n  // Identify incorrect shapes by type\n  const identifyIncorrectShapesByType = shapeType => {\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const actualShapeType = getShapeType(pieceId);\n      return actualShapeType === shapeType && !isPieceInCorrectPosition(piece, pieceId);\n    });\n    const result = {\n      type: 'shape',\n      shapeType,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`shape-${shapeType}`]: result\n    }));\n    logToTerminal(`🔍 IDENTIFIED INCORRECT ${shapeType.toUpperCase()} SHAPES`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n\n  // Identify incorrect shapes by color\n  const identifyIncorrectShapesByColor = shapeColor => {\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const actualShapeColor = getShapeColor(pieceId);\n      return actualShapeColor === shapeColor && !isPieceInCorrectPosition(piece, pieceId);\n    });\n    const result = {\n      type: 'color',\n      shapeColor,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`color-${shapeColor}`]: result\n    }));\n    logToTerminal(`🎨 IDENTIFIED INCORRECT ${shapeColor.toUpperCase()} SHAPES`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n\n  // Identify incorrect border colors\n  const identifyIncorrectBorderColors = faceIndex => {\n    const borderColorName = getBorderColorName(faceIndex);\n    const borderColorHex = getExpectedBorderColor(faceIndex);\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\n\n      // Check if this piece should have this border color in its current position\n      const [x, y, z] = piece.position;\n      let shouldHaveBorderColor = false;\n      switch (faceIndex) {\n        case 0:\n          // Front face (Z+) - White\n          shouldHaveBorderColor = z === 1;\n          break;\n        case 1:\n          // Back face (Z-) - Orange\n          shouldHaveBorderColor = z === -1;\n          break;\n        case 2:\n          // Right face (X+) - Green\n          shouldHaveBorderColor = x === 1;\n          break;\n        case 3:\n          // Left face (X-) - Red\n          shouldHaveBorderColor = x === -1;\n          break;\n        case 4:\n          // Top face (Y+) - Blue\n          shouldHaveBorderColor = y === 1;\n          break;\n        case 5:\n          // Bottom face (Y-) - Yellow\n          shouldHaveBorderColor = y === -1;\n          break;\n      }\n\n      // Piece is incorrect if it should have this border color but is not in correct position\n      return shouldHaveBorderColor && !isInCorrectPosition;\n    });\n    const result = {\n      type: 'border',\n      faceIndex,\n      borderColorName,\n      borderColorHex,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`border-${faceIndex}`]: result\n    }));\n    logToTerminal(`🎭 IDENTIFIED INCORRECT ${borderColorName.toUpperCase()} BORDER COLORS`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n\n  // Identify pieces with black faces that should be visible\n  const identifyPiecesWithBlackFaces = () => {\n    const piecesWithBlackFaces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const [x, y, z] = piece.position;\n\n      // Check which faces should be visible and have colors\n      const visibleFaces = [];\n      if (x === 1) visibleFaces.push('right');\n      if (x === -1) visibleFaces.push('left');\n      if (y === 1) visibleFaces.push('top');\n      if (y === -1) visibleFaces.push('bottom');\n      if (z === 1) visibleFaces.push('front');\n      if (z === -1) visibleFaces.push('back');\n\n      // Only check if any VISIBLE face is dark gray (hidden faces don't count)\n      // Note: Dark gray faces are rendered as bright pink for visibility\n      return visibleFaces.some(face => piece.colors[face] === '#444444');\n    });\n    const result = {\n      type: 'blackFaces',\n      incorrectPieces: piecesWithBlackFaces.map(piece => {\n        const [x, y, z] = piece.position;\n        const visibleFaces = [];\n        if (x === 1) visibleFaces.push('right');\n        if (x === -1) visibleFaces.push('left');\n        if (y === 1) visibleFaces.push('top');\n        if (y === -1) visibleFaces.push('bottom');\n        if (z === 1) visibleFaces.push('front');\n        if (z === -1) visibleFaces.push('back');\n        const blackVisibleFaces = visibleFaces.filter(face => piece.colors[face] === '#444444');\n        return {\n          pieceId: piece.pieceId,\n          shapeType: getShapeType(piece.pieceId),\n          shapeColor: getShapeColor(piece.pieceId),\n          currentPosition: piece.position,\n          expectedPosition: getExpectedPosition(piece.pieceId),\n          colors: piece.colors,\n          rotationHistory: piece.rotationHistory,\n          blackVisibleFaces: blackVisibleFaces,\n          visibleFaces: visibleFaces\n        };\n      }),\n      count: piecesWithBlackFaces.length,\n      totalBlackFaces: piecesWithBlackFaces.reduce((total, piece) => {\n        const [x, y, z] = piece.position;\n        const visibleFaces = [];\n        if (x === 1) visibleFaces.push('right');\n        if (x === -1) visibleFaces.push('left');\n        if (y === 1) visibleFaces.push('top');\n        if (y === -1) visibleFaces.push('bottom');\n        if (z === 1) visibleFaces.push('front');\n        if (z === -1) visibleFaces.push('back');\n        return total + visibleFaces.filter(face => piece.colors[face] === '#444444').length;\n      }, 0)\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      'blackFaces': result\n    }));\n    logToTerminal(`⚫ IDENTIFIED PIECES WITH DARK GRAY FACES`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n  const handleButtonClick = (type, identifier) => {\n    if (isScrambling) return;\n    setActiveIdentification(`${type}-${identifier}`);\n    let result;\n    switch (type) {\n      case 'shape':\n        result = identifyIncorrectShapesByType(identifier);\n        break;\n      case 'color':\n        result = identifyIncorrectShapesByColor(identifier);\n        break;\n      case 'border':\n        result = identifyIncorrectBorderColors(identifier);\n        break;\n      case 'blackFaces':\n        result = identifyPiecesWithBlackFaces();\n        break;\n    }\n\n    // Reset active state after a short delay\n    setTimeout(() => {\n      setActiveIdentification(null);\n    }, 2000);\n  };\n  const getButtonState = (type, identifier) => {\n    const key = `${type}-${identifier}`;\n    const result = identificationResults[key];\n    const isActive = activeIdentification === key;\n    return {\n      isActive,\n      hasIncorrect: result && result.count > 0,\n      count: result ? result.count : 0\n    };\n  };\n  if (!cubeState) {\n    console.log('🚨 SHOWING LOADING MESSAGE - no cubeState');\n    return /*#__PURE__*/_jsxDEV(IdentifyContainer, {\n      children: [/*#__PURE__*/_jsxDEV(SectionTitle, {\n        children: \"Identify Incorrect Shapes\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 585,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(StatusMessage, {\n        $type: \"warning\",\n        children: \"Loading cube state... Please scramble the cube first to identify incorrect shapes.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 586,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 584,\n      columnNumber: 7\n    }, this);\n  }\n\n  // Generate all possible combinations of shape+color+border\n  const generateCombinations = () => {\n    const shapeTypes = ['Square', 'Circle', 'Triangle', 'Diamond'];\n    const shapeColors = ['Red', 'Blue', 'Green', 'Orange', 'Purple', 'Yellow', 'Cyan', 'Magenta', 'Lime', 'Pink'];\n    const borderColors = [{\n      name: 'White',\n      hex: '#FFFFFF',\n      faceIndex: 0\n    }, {\n      name: 'Orange',\n      hex: '#FF8C00',\n      faceIndex: 1\n    }, {\n      name: 'Green',\n      hex: '#00FF00',\n      faceIndex: 2\n    }, {\n      name: 'Red',\n      hex: '#DC143C',\n      faceIndex: 3\n    }, {\n      name: 'Blue',\n      hex: '#0000FF',\n      faceIndex: 4\n    }, {\n      name: 'Yellow',\n      hex: '#FFD700',\n      faceIndex: 5\n    }];\n    const combinations = [];\n    shapeTypes.forEach(shapeType => {\n      shapeColors.forEach(shapeColor => {\n        borderColors.forEach(borderColor => {\n          combinations.push({\n            id: `${shapeType}-${shapeColor}-${borderColor.name}`,\n            shapeType,\n            shapeColor,\n            borderColor: borderColor.name,\n            borderColorHex: borderColor.hex,\n            faceIndex: borderColor.faceIndex\n          });\n        });\n      });\n    });\n    return combinations;\n  };\n\n  // Identify incorrect pieces by combination\n  const identifyIncorrectCombination = combination => {\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const actualShapeType = getShapeType(pieceId);\n      const actualShapeColor = getShapeColor(pieceId);\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\n\n      // Check if this piece matches the combination\n      const matchesShape = actualShapeType === combination.shapeType;\n      const matchesColor = actualShapeColor === combination.shapeColor;\n\n      // Check if this piece should have this border color in its current position\n      const [x, y, z] = piece.position;\n      let shouldHaveBorderColor = false;\n      switch (combination.faceIndex) {\n        case 0:\n          // Front face (Z+) - White\n          shouldHaveBorderColor = z === 1;\n          break;\n        case 1:\n          // Back face (Z-) - Orange\n          shouldHaveBorderColor = z === -1;\n          break;\n        case 2:\n          // Right face (X+) - Green\n          shouldHaveBorderColor = x === 1;\n          break;\n        case 3:\n          // Left face (X-) - Red\n          shouldHaveBorderColor = x === -1;\n          break;\n        case 4:\n          // Top face (Y+) - Blue\n          shouldHaveBorderColor = y === 1;\n          break;\n        case 5:\n          // Bottom face (Y-) - Yellow\n          shouldHaveBorderColor = y === -1;\n          break;\n      }\n\n      // Piece is incorrect if it matches the combination but is not in correct position\n      return matchesShape && matchesColor && shouldHaveBorderColor && !isInCorrectPosition;\n    });\n    const result = {\n      type: 'combination',\n      combination,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`combination-${combination.id}`]: result\n    }));\n    logToTerminal(`🎯 IDENTIFIED INCORRECT ${combination.shapeColor} ${combination.shapeType} with ${combination.borderColor} border`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n  const handleCombinationClick = combination => {\n    if (isScrambling) return;\n    setActiveIdentification(`combination-${combination.id}`);\n    const result = identifyIncorrectCombination(combination);\n\n    // Reset active state after a short delay\n    setTimeout(() => {\n      setActiveIdentification(null);\n    }, 2000);\n  };\n  const getCombinationButtonState = combination => {\n    const key = `combination-${combination.id}`;\n    const result = identificationResults[key];\n    const isActive = activeIdentification === key;\n    return {\n      isActive,\n      hasIncorrect: result && result.count > 0,\n      count: result ? result.count : 0\n    };\n  };\n  const combinations = generateCombinations();\n  return /*#__PURE__*/_jsxDEV(IdentifyContainer, {\n    children: [/*#__PURE__*/_jsxDEV(SectionTitle, {\n      children: \"Identify Incorrect Shapes\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 722,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Instructions, {\n      children: \"Click any button below to identify pieces with that specific combination of shape+color+border that are in incorrect positions. Buttons show the count of incorrect pieces found for each combination.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 723,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n        style: {\n          color: 'white',\n          marginBottom: '10px',\n          fontSize: '16px'\n        },\n        children: \"Special Issues\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 730,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ButtonGrid, {\n        style: {\n          gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',\n          marginBottom: '20px'\n        },\n        children: /*#__PURE__*/_jsxDEV(IdentifyButton, {\n          onClick: () => handleButtonClick('blackFaces', 'all'),\n          disabled: isScrambling,\n          $isActive: activeIdentification === 'blackFaces-all',\n          $hasIncorrect: identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0,\n          style: {\n            background: 'rgba(255, 0, 0, 0.2)',\n            borderColor: '#ff0000',\n            borderWidth: '3px'\n          },\n          children: /*#__PURE__*/_jsxDEV(ButtonContent, {\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              style: {\n                fontSize: '24px',\n                marginBottom: '8px'\n              },\n              children: \"\\u26AB\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 744,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonTitle, {\n              style: {\n                color: '#ff0000',\n                fontWeight: 'bold'\n              },\n              children: \"Dark Gray Faces\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 745,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonSubtitle, {\n              children: \"Find pieces with dark gray faces (highlighted in pink)\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 748,\n              columnNumber: 15\n            }, this), identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0 && /*#__PURE__*/_jsxDEV(CountBadge, {\n              $hasIncorrect: true,\n              children: [identificationResults['blackFaces'].count, \" pieces\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 754,\n                columnNumber: 19\n              }, this), identificationResults['blackFaces'].totalBlackFaces, \" faces\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 752,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 743,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 732,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 731,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 729,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n        style: {\n          color: 'white',\n          marginBottom: '15px',\n          fontSize: '16px'\n        },\n        children: \"By Shape + Color + Border Combinations\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 765,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ButtonGrid, {\n        style: {\n          gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))'\n        },\n        children: combinations.map(combination => {\n          const state = getCombinationButtonState(combination);\n          return /*#__PURE__*/_jsxDEV(IdentifyButton, {\n            onClick: () => handleCombinationClick(combination),\n            disabled: isScrambling,\n            $isActive: state.isActive,\n            $hasIncorrect: state.hasIncorrect,\n            style: {\n              borderColor: state.hasIncorrect ? '#ff4757' : combination.borderColorHex,\n              borderWidth: '3px'\n            },\n            children: /*#__PURE__*/_jsxDEV(ButtonContent, {\n              children: [/*#__PURE__*/_jsxDEV(ShapeContainer, {\n                children: [combination.shapeType === 'Triangle' ? /*#__PURE__*/_jsxDEV(\"svg\", {\n                  width: \"50\",\n                  height: \"50\",\n                  viewBox: \"0 0 50 50\",\n                  children: /*#__PURE__*/_jsxDEV(\"polygon\", {\n                    points: \"25,5 45,40 5,40\",\n                    fill: getShapeColorHex(combination.shapeColor),\n                    stroke: combination.borderColorHex,\n                    strokeWidth: \"3\"\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 786,\n                    columnNumber: 25\n                  }, this)\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 785,\n                  columnNumber: 23\n                }, this) : /*#__PURE__*/_jsxDEV(ShapeVisual, {\n                  $shapeType: combination.shapeType,\n                  $shapeColor: getShapeColorHex(combination.shapeColor),\n                  $borderColor: combination.borderColorHex\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 794,\n                  columnNumber: 23\n                }, this), state.count > 0 && /*#__PURE__*/_jsxDEV(CountBadge, {\n                  $hasIncorrect: state.hasIncorrect,\n                  children: state.count\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 801,\n                  columnNumber: 23\n                }, this)]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 783,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(ButtonTitle, {\n                children: [combination.shapeColor, \" \", combination.shapeType]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 806,\n                columnNumber: 19\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 782,\n              columnNumber: 17\n            }, this)\n          }, `combination-${combination.id}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 771,\n            columnNumber: 15\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 766,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 764,\n      columnNumber: 7\n    }, this), activeIdentification && /*#__PURE__*/_jsxDEV(StatusMessage, {\n      $type: \"success\",\n      children: \"Combination identification complete! Check the terminal for detailed results.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 818,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 721,\n    columnNumber: 5\n  }, this);\n}\n_s(IdentifyIncorrectShapes, \"ii/H1hjjocRwhM9agB/LU82OhuE=\");\n_c11 = IdentifyIncorrectShapes;\nexport default IdentifyIncorrectShapes;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c0, _c1, _c10, _c11;\n$RefreshReg$(_c, \"IdentifyContainer\");\n$RefreshReg$(_c2, \"SectionTitle\");\n$RefreshReg$(_c3, \"ButtonGrid\");\n$RefreshReg$(_c4, \"IdentifyButton\");\n$RefreshReg$(_c5, \"ButtonContent\");\n$RefreshReg$(_c6, \"ShapeContainer\");\n$RefreshReg$(_c7, \"ShapeVisual\");\n$RefreshReg$(_c8, \"CountBadge\");\n$RefreshReg$(_c9, \"ButtonTitle\");\n$RefreshReg$(_c0, \"ButtonSubtitle\");\n$RefreshReg$(_c1, \"Instructions\");\n$RefreshReg$(_c10, \"StatusMessage\");\n$RefreshReg$(_c11, \"IdentifyIncorrectShapes\");","map":{"version":3,"names":["React","useState","styled","jsxDEV","_jsxDEV","IdentifyContainer","div","_c","SectionTitle","h3","_c2","ButtonGrid","_c3","IdentifyButton","button","props","$isActive","$hasIncorrect","disabled","_c4","ButtonContent","_c5","ShapeContainer","_c6","ShapeVisual","$shapeColor","$borderColor","$shapeType","_c7","CountBadge","span","_c8","ButtonTitle","_c9","ButtonSubtitle","_c0","Instructions","p","_c1","StatusMessage","$type","_c10","logToTerminal","message","data","console","log","JSON","stringify","repeat","fetch","method","headers","body","then","response","ok","Error","status","catch","error","IdentifyIncorrectShapes","isScrambling","cubeState","onIdentification","_s","activeIdentification","setActiveIdentification","identificationResults","setIdentificationResults","getShapeType","pieceId","shapeTypes","getShapeColor","shapeColors","getExpectedPosition","positions","x","y","z","push","isPieceInCorrectPosition","piece","position","expectedPosition","getExpectedBorderColor","faceIndex","borderColors","getBorderColorName","colorNames","getShapeColorHex","shapeColor","colorMap","getPieces","Array","isArray","map","index","colors","rotationHistory","pieces","identifyIncorrectShapesByType","shapeType","incorrectPieces","filter","actualShapeType","result","type","currentPosition","count","length","prev","toUpperCase","identifyIncorrectShapesByColor","actualShapeColor","identifyIncorrectBorderColors","borderColorName","borderColorHex","isInCorrectPosition","shouldHaveBorderColor","identifyPiecesWithBlackFaces","piecesWithBlackFaces","visibleFaces","some","face","blackVisibleFaces","totalBlackFaces","reduce","total","handleButtonClick","identifier","setTimeout","getButtonState","key","isActive","hasIncorrect","children","fileName","_jsxFileName","lineNumber","columnNumber","generateCombinations","name","hex","combinations","forEach","borderColor","id","identifyIncorrectCombination","combination","matchesShape","matchesColor","handleCombinationClick","getCombinationButtonState","style","color","marginBottom","fontSize","gridTemplateColumns","onClick","background","borderWidth","fontWeight","state","width","height","viewBox","points","fill","stroke","strokeWidth","_c11","$RefreshReg$"],"sources":["C:/Repo/GitHub/rubiks-cube/src/components/IdentifyIncorrectShapes.js"],"sourcesContent":["import React, { useState } from 'react';\r\nimport styled from 'styled-components';\r\n\r\nconst IdentifyContainer = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 20px;\r\n  padding: 20px;\r\n  background: rgba(255, 255, 255, 0.1);\r\n  border-radius: 15px;\r\n  backdrop-filter: blur(10px);\r\n  border: 1px solid rgba(255, 255, 255, 0.2);\r\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);\r\n  max-height: 500px;\r\n  overflow-y: auto;\r\n`;\r\n\r\nconst SectionTitle = styled.h3`\r\n  color: white;\r\n  text-align: center;\r\n  margin: 0 0 15px 0;\r\n  font-size: 1.3rem;\r\n  font-weight: 600;\r\n  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\r\n`;\r\n\r\nconst ButtonGrid = styled.div`\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\r\n  gap: 15px;\r\n  margin-bottom: 20px;\r\n`;\r\n\r\nconst IdentifyButton = styled.button`\r\n  padding: 12px 16px;\r\n  border: 2px solid ${props => {\r\n    if (props.$isActive) return '#4CAF50';\r\n    if (props.$hasIncorrect) return '#ff4757';\r\n    return 'rgba(255, 255, 255, 0.3)';\r\n  }};\r\n  border-radius: 10px;\r\n  font-size: 14px;\r\n  font-weight: 600;\r\n  cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};\r\n  transition: all 0.3s ease;\r\n  background: ${props => {\r\n    if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\r\n    if (props.$isActive) return 'rgba(76, 175, 80, 0.2)';\r\n    if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.2)';\r\n    return 'rgba(255, 255, 255, 0.1)';\r\n  }};\r\n  color: ${props => {\r\n    if (props.disabled) return '#666';\r\n    if (props.$isActive) return '#4CAF50';\r\n    if (props.$hasIncorrect) return '#ff4757';\r\n    return 'white';\r\n  }};\r\n  opacity: ${props => props.disabled ? 0.5 : 1};\r\n  \r\n  &:hover {\r\n    transform: ${props => props.disabled ? 'none' : 'translateY(-2px)'};\r\n    box-shadow: ${props => props.disabled ? 'none' : '0 4px 12px rgba(0, 0, 0, 0.3)'};\r\n    background: ${props => {\r\n      if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\r\n      if (props.$isActive) return 'rgba(76, 175, 80, 0.3)';\r\n      if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.3)';\r\n      return 'rgba(255, 255, 255, 0.2)';\r\n    }};\r\n  }\r\n  \r\n  &:active {\r\n    transform: ${props => props.disabled ? 'none' : 'translateY(0)'};\r\n  }\r\n`;\r\n\r\nconst ButtonContent = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  gap: 4px;\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n`;\r\n\r\nconst ShapeContainer = styled.div`\r\n  width: 60px;\r\n  height: 60px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  position: relative;\r\n  margin: 8px 0;\r\n`;\r\n\r\nconst ShapeVisual = styled.div`\r\n  width: 50px;\r\n  height: 50px;\r\n  background: ${props => props.$shapeColor};\r\n  border: 3px solid ${props => props.$borderColor};\r\n  position: relative;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  \r\n  /* Shape-specific styling */\r\n  border-radius: ${props => {\r\n    if (props.$shapeType === 'Circle') return '50%';\r\n    if (props.$shapeType === 'Diamond') return '0';\r\n    return '0';\r\n  }};\r\n  \r\n  transform: ${props => {\r\n    if (props.$shapeType === 'Diamond') return 'rotate(45deg)';\r\n    return 'none';\r\n  }};\r\n  \r\n  /* Triangle shape using CSS */\r\n  ${props => props.$shapeType === 'Triangle' && `\r\n    width: 0;\r\n    height: 0;\r\n    background: transparent;\r\n    border: none;\r\n    border-left: 25px solid transparent;\r\n    border-right: 25px solid transparent;\r\n    border-bottom: 43px solid ${props.$shapeColor};\r\n    position: relative;\r\n  `}\r\n`;\r\n\r\nconst CountBadge = styled.span`\r\n  background: ${props => props.$hasIncorrect ? '#ff4757' : '#4CAF50'};\r\n  color: white;\r\n  border-radius: 50%;\r\n  width: 20px;\r\n  height: 20px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  font-size: 10px;\r\n  font-weight: bold;\r\n  position: absolute;\r\n  top: -5px;\r\n  right: -5px;\r\n  z-index: 10;\r\n`;\r\n\r\nconst ButtonTitle = styled.span`\r\n  font-size: 12px;\r\n  font-weight: 600;\r\n  color: white;\r\n  text-align: center;\r\n  margin-top: 4px;\r\n`;\r\n\r\nconst ButtonSubtitle = styled.div`\r\n  font-size: 10px;\r\n  color: rgba(255, 255, 255, 0.8);\r\n  text-align: center;\r\n  margin-top: 2px;\r\n  line-height: 1.2;\r\n`;\r\n\r\nconst Instructions = styled.p`\r\n  color: rgba(255, 255, 255, 0.8);\r\n  font-size: 13px;\r\n  text-align: center;\r\n  margin: 0 0 15px 0;\r\n  line-height: 1.4;\r\n`;\r\n\r\nconst StatusMessage = styled.div`\r\n  padding: 10px;\r\n  border-radius: 8px;\r\n  text-align: center;\r\n  font-size: 12px;\r\n  font-weight: 600;\r\n  background: ${props => {\r\n    if (props.$type === 'success') return 'rgba(76, 175, 80, 0.2)';\r\n    if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.2)';\r\n    if (props.$type === 'error') return 'rgba(244, 67, 54, 0.2)';\r\n    return 'rgba(33, 150, 243, 0.2)';\r\n  }};\r\n  color: ${props => {\r\n    if (props.$type === 'success') return '#4CAF50';\r\n    if (props.$type === 'warning') return '#FFC107';\r\n    if (props.$type === 'error') return '#f44336';\r\n    return '#2196F3';\r\n  }};\r\n  border: 1px solid ${props => {\r\n    if (props.$type === 'success') return 'rgba(76, 175, 80, 0.3)';\r\n    if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.3)';\r\n    if (props.$type === 'error') return 'rgba(244, 67, 54, 0.3)';\r\n    return 'rgba(33, 150, 243, 0.3)';\r\n  }};\r\n`;\r\n\r\n// Custom logging function\r\nconst logToTerminal = (message, data = null) => {\r\n  console.log(`\\n🎯 ${message}`);\r\n  if (data) {\r\n    console.log(JSON.stringify(data, null, 2));\r\n  }\r\n  console.log('='.repeat(80) + '\\n');\r\n  \r\n  // Send to log server\r\n  fetch('http://localhost:3001/log', {\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n    },\r\n    body: JSON.stringify({\r\n      message: message,\r\n      data: data\r\n    })\r\n  })\r\n  .then(response => {\r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n    console.log('✅ Log sent to terminal successfully');\r\n  })\r\n  .catch(error => {\r\n    console.error('❌ Could not send log to terminal server:', error);\r\n  });\r\n};\r\n\r\nfunction IdentifyIncorrectShapes({ isScrambling, cubeState, onIdentification }) {\r\n  const [activeIdentification, setActiveIdentification] = useState(null);\r\n  const [identificationResults, setIdentificationResults] = useState({});\r\n\r\n  // Helper functions\r\n  const getShapeType = (pieceId) => {\r\n    const shapeTypes = [\r\n      'Square', 'Square', 'Square', 'Square', 'Square',\r\n      'Circle', 'Circle', 'Circle', 'Circle', 'Circle',\r\n      'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Diamond',\r\n      'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Diamond',\r\n      'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle'\r\n    ];\r\n    return shapeTypes[pieceId] || 'Unknown';\r\n  };\r\n\r\n  const getShapeColor = (pieceId) => {\r\n    const shapeColors = [\r\n      'Red', 'Blue', 'Green', 'Orange', 'Purple',\r\n      'Red', 'Blue', 'Green', 'Orange', 'Yellow',\r\n      'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple',\r\n      'Red', 'Blue', 'Green', 'Orange', 'Purple',\r\n      'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple', 'Yellow'\r\n    ];\r\n    return shapeColors[pieceId] || 'Unknown';\r\n  };\r\n\r\n  const getExpectedPosition = (pieceId) => {\r\n    const positions = [];\r\n    for (let x = -1; x <= 1; x++) {\r\n      for (let y = -1; y <= 1; y++) {\r\n        for (let z = -1; z <= 1; z++) {\r\n          if (x === 0 && y === 0 && z === 0) continue;\r\n          positions.push([x, y, z]);\r\n        }\r\n      }\r\n    }\r\n    return positions[pieceId];\r\n  };\r\n\r\n  const isPieceInCorrectPosition = (piece, pieceId) => {\r\n    if (!piece || !piece.position) return false;\r\n    const expectedPosition = getExpectedPosition(pieceId);\r\n    return JSON.stringify(piece.position) === JSON.stringify(expectedPosition);\r\n  };\r\n\r\n  const getExpectedBorderColor = (faceIndex) => {\r\n    const borderColors = [\r\n      '#FFFFFF', // Face 0 (front) - White\r\n      '#FF8C00', // Face 1 (back) - Orange  \r\n      '#00FF00', // Face 2 (right) - Green\r\n      '#DC143C', // Face 3 (left) - Red\r\n      '#0000FF', // Face 4 (top) - Blue\r\n      '#FFD700'  // Face 5 (bottom) - Yellow\r\n    ];\r\n    return borderColors[faceIndex] || '#000000';\r\n  };\r\n\r\n  const getBorderColorName = (faceIndex) => {\r\n    const colorNames = ['White', 'Orange', 'Green', 'Red', 'Blue', 'Yellow'];\r\n    return colorNames[faceIndex] || 'Unknown';\r\n  };\r\n\r\n  const getShapeColorHex = (shapeColor) => {\r\n    const colorMap = {\r\n      'Red': '#DC143C',\r\n      'Blue': '#0000FF',\r\n      'Green': '#00FF00',\r\n      'Orange': '#FF8C00',\r\n      'Purple': '#800080',\r\n      'Yellow': '#FFD700',\r\n      'Cyan': '#00FFFF',\r\n      'Magenta': '#FF00FF',\r\n      'Lime': '#00FF00',\r\n      'Pink': '#FFC0CB'\r\n    };\r\n    return colorMap[shapeColor] || '#000000';\r\n  };\r\n\r\n  // Get pieces data\r\n  const getPieces = () => {\r\n    if (Array.isArray(cubeState)) {\r\n      return cubeState.map((piece, index) => ({\r\n        pieceId: index,\r\n        position: piece.position,\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory || []\r\n      }));\r\n    } else if (cubeState?.pieces) {\r\n      return cubeState.pieces;\r\n    }\r\n    return [];\r\n  };\r\n\r\n  const pieces = getPieces();\r\n\r\n  // Identify incorrect shapes by type\r\n  const identifyIncorrectShapesByType = (shapeType) => {\r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const actualShapeType = getShapeType(pieceId);\r\n      return actualShapeType === shapeType && !isPieceInCorrectPosition(piece, pieceId);\r\n    });\r\n\r\n    const result = {\r\n      type: 'shape',\r\n      shapeType,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`shape-${shapeType}`]: result\r\n    }));\r\n\r\n    logToTerminal(`🔍 IDENTIFIED INCORRECT ${shapeType.toUpperCase()} SHAPES`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  // Identify incorrect shapes by color\r\n  const identifyIncorrectShapesByColor = (shapeColor) => {\r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const actualShapeColor = getShapeColor(pieceId);\r\n      return actualShapeColor === shapeColor && !isPieceInCorrectPosition(piece, pieceId);\r\n    });\r\n\r\n    const result = {\r\n      type: 'color',\r\n      shapeColor,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`color-${shapeColor}`]: result\r\n    }));\r\n\r\n    logToTerminal(`🎨 IDENTIFIED INCORRECT ${shapeColor.toUpperCase()} SHAPES`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  // Identify incorrect border colors\r\n  const identifyIncorrectBorderColors = (faceIndex) => {\r\n    const borderColorName = getBorderColorName(faceIndex);\r\n    const borderColorHex = getExpectedBorderColor(faceIndex);\r\n    \r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\r\n      \r\n      // Check if this piece should have this border color in its current position\r\n      const [x, y, z] = piece.position;\r\n      let shouldHaveBorderColor = false;\r\n      \r\n      switch (faceIndex) {\r\n        case 0: // Front face (Z+) - White\r\n          shouldHaveBorderColor = z === 1;\r\n          break;\r\n        case 1: // Back face (Z-) - Orange\r\n          shouldHaveBorderColor = z === -1;\r\n          break;\r\n        case 2: // Right face (X+) - Green\r\n          shouldHaveBorderColor = x === 1;\r\n          break;\r\n        case 3: // Left face (X-) - Red\r\n          shouldHaveBorderColor = x === -1;\r\n          break;\r\n        case 4: // Top face (Y+) - Blue\r\n          shouldHaveBorderColor = y === 1;\r\n          break;\r\n        case 5: // Bottom face (Y-) - Yellow\r\n          shouldHaveBorderColor = y === -1;\r\n          break;\r\n      }\r\n      \r\n      // Piece is incorrect if it should have this border color but is not in correct position\r\n      return shouldHaveBorderColor && !isInCorrectPosition;\r\n    });\r\n\r\n    const result = {\r\n      type: 'border',\r\n      faceIndex,\r\n      borderColorName,\r\n      borderColorHex,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`border-${faceIndex}`]: result\r\n    }));\r\n\r\n    logToTerminal(`🎭 IDENTIFIED INCORRECT ${borderColorName.toUpperCase()} BORDER COLORS`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  // Identify pieces with black faces that should be visible\r\n  const identifyPiecesWithBlackFaces = () => {\r\n    const piecesWithBlackFaces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const [x, y, z] = piece.position;\r\n      \r\n      // Check which faces should be visible and have colors\r\n      const visibleFaces = [];\r\n      if (x === 1) visibleFaces.push('right');\r\n      if (x === -1) visibleFaces.push('left');\r\n      if (y === 1) visibleFaces.push('top');\r\n      if (y === -1) visibleFaces.push('bottom');\r\n      if (z === 1) visibleFaces.push('front');\r\n      if (z === -1) visibleFaces.push('back');\r\n      \r\n      // Only check if any VISIBLE face is dark gray (hidden faces don't count)\r\n      // Note: Dark gray faces are rendered as bright pink for visibility\r\n      return visibleFaces.some(face => piece.colors[face] === '#444444');\r\n    });\r\n\r\n    const result = {\r\n      type: 'blackFaces',\r\n      incorrectPieces: piecesWithBlackFaces.map(piece => {\r\n        const [x, y, z] = piece.position;\r\n        const visibleFaces = [];\r\n        if (x === 1) visibleFaces.push('right');\r\n        if (x === -1) visibleFaces.push('left');\r\n        if (y === 1) visibleFaces.push('top');\r\n        if (y === -1) visibleFaces.push('bottom');\r\n        if (z === 1) visibleFaces.push('front');\r\n        if (z === -1) visibleFaces.push('back');\r\n        \r\n        const blackVisibleFaces = visibleFaces.filter(face => piece.colors[face] === '#444444');\r\n        \r\n        return {\r\n          pieceId: piece.pieceId,\r\n          shapeType: getShapeType(piece.pieceId),\r\n          shapeColor: getShapeColor(piece.pieceId),\r\n          currentPosition: piece.position,\r\n          expectedPosition: getExpectedPosition(piece.pieceId),\r\n          colors: piece.colors,\r\n          rotationHistory: piece.rotationHistory,\r\n          blackVisibleFaces: blackVisibleFaces,\r\n          visibleFaces: visibleFaces\r\n        };\r\n      }),\r\n      count: piecesWithBlackFaces.length,\r\n      totalBlackFaces: piecesWithBlackFaces.reduce((total, piece) => {\r\n        const [x, y, z] = piece.position;\r\n        const visibleFaces = [];\r\n        if (x === 1) visibleFaces.push('right');\r\n        if (x === -1) visibleFaces.push('left');\r\n        if (y === 1) visibleFaces.push('top');\r\n        if (y === -1) visibleFaces.push('bottom');\r\n        if (z === 1) visibleFaces.push('front');\r\n        if (z === -1) visibleFaces.push('back');\r\n        return total + visibleFaces.filter(face => piece.colors[face] === '#444444').length;\r\n      }, 0)\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      'blackFaces': result\r\n    }));\r\n\r\n    logToTerminal(`⚫ IDENTIFIED PIECES WITH DARK GRAY FACES`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  const handleButtonClick = (type, identifier) => {\r\n    if (isScrambling) return;\r\n\r\n    setActiveIdentification(`${type}-${identifier}`);\r\n\r\n    let result;\r\n    switch (type) {\r\n      case 'shape':\r\n        result = identifyIncorrectShapesByType(identifier);\r\n        break;\r\n      case 'color':\r\n        result = identifyIncorrectShapesByColor(identifier);\r\n        break;\r\n      case 'border':\r\n        result = identifyIncorrectBorderColors(identifier);\r\n        break;\r\n      case 'blackFaces':\r\n        result = identifyPiecesWithBlackFaces();\r\n        break;\r\n    }\r\n\r\n    // Reset active state after a short delay\r\n    setTimeout(() => {\r\n      setActiveIdentification(null);\r\n    }, 2000);\r\n  };\r\n\r\n  const getButtonState = (type, identifier) => {\r\n    const key = `${type}-${identifier}`;\r\n    const result = identificationResults[key];\r\n    const isActive = activeIdentification === key;\r\n    \r\n    return {\r\n      isActive,\r\n      hasIncorrect: result && result.count > 0,\r\n      count: result ? result.count : 0\r\n    };\r\n  };\r\n\r\n\r\n  if (!cubeState) {\r\n    console.log('🚨 SHOWING LOADING MESSAGE - no cubeState');\r\n    return (\r\n      <IdentifyContainer>\r\n        <SectionTitle>Identify Incorrect Shapes</SectionTitle>\r\n        <StatusMessage $type=\"warning\">\r\n          Loading cube state... Please scramble the cube first to identify incorrect shapes.\r\n        </StatusMessage>\r\n      </IdentifyContainer>\r\n    );\r\n  }\r\n\r\n  // Generate all possible combinations of shape+color+border\r\n  const generateCombinations = () => {\r\n    const shapeTypes = ['Square', 'Circle', 'Triangle', 'Diamond'];\r\n    const shapeColors = ['Red', 'Blue', 'Green', 'Orange', 'Purple', 'Yellow', 'Cyan', 'Magenta', 'Lime', 'Pink'];\r\n    const borderColors = [\r\n      { name: 'White', hex: '#FFFFFF', faceIndex: 0 },\r\n      { name: 'Orange', hex: '#FF8C00', faceIndex: 1 },\r\n      { name: 'Green', hex: '#00FF00', faceIndex: 2 },\r\n      { name: 'Red', hex: '#DC143C', faceIndex: 3 },\r\n      { name: 'Blue', hex: '#0000FF', faceIndex: 4 },\r\n      { name: 'Yellow', hex: '#FFD700', faceIndex: 5 }\r\n    ];\r\n\r\n    const combinations = [];\r\n    shapeTypes.forEach(shapeType => {\r\n      shapeColors.forEach(shapeColor => {\r\n        borderColors.forEach(borderColor => {\r\n          combinations.push({\r\n            id: `${shapeType}-${shapeColor}-${borderColor.name}`,\r\n            shapeType,\r\n            shapeColor,\r\n            borderColor: borderColor.name,\r\n            borderColorHex: borderColor.hex,\r\n            faceIndex: borderColor.faceIndex\r\n          });\r\n        });\r\n      });\r\n    });\r\n    return combinations;\r\n  };\r\n\r\n  // Identify incorrect pieces by combination\r\n  const identifyIncorrectCombination = (combination) => {\r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const actualShapeType = getShapeType(pieceId);\r\n      const actualShapeColor = getShapeColor(pieceId);\r\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\r\n      \r\n      // Check if this piece matches the combination\r\n      const matchesShape = actualShapeType === combination.shapeType;\r\n      const matchesColor = actualShapeColor === combination.shapeColor;\r\n      \r\n      // Check if this piece should have this border color in its current position\r\n      const [x, y, z] = piece.position;\r\n      let shouldHaveBorderColor = false;\r\n      \r\n      switch (combination.faceIndex) {\r\n        case 0: // Front face (Z+) - White\r\n          shouldHaveBorderColor = z === 1;\r\n          break;\r\n        case 1: // Back face (Z-) - Orange\r\n          shouldHaveBorderColor = z === -1;\r\n          break;\r\n        case 2: // Right face (X+) - Green\r\n          shouldHaveBorderColor = x === 1;\r\n          break;\r\n        case 3: // Left face (X-) - Red\r\n          shouldHaveBorderColor = x === -1;\r\n          break;\r\n        case 4: // Top face (Y+) - Blue\r\n          shouldHaveBorderColor = y === 1;\r\n          break;\r\n        case 5: // Bottom face (Y-) - Yellow\r\n          shouldHaveBorderColor = y === -1;\r\n          break;\r\n      }\r\n      \r\n      // Piece is incorrect if it matches the combination but is not in correct position\r\n      return matchesShape && matchesColor && shouldHaveBorderColor && !isInCorrectPosition;\r\n    });\r\n\r\n    const result = {\r\n      type: 'combination',\r\n      combination,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`combination-${combination.id}`]: result\r\n    }));\r\n\r\n    logToTerminal(`🎯 IDENTIFIED INCORRECT ${combination.shapeColor} ${combination.shapeType} with ${combination.borderColor} border`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  const handleCombinationClick = (combination) => {\r\n    if (isScrambling) return;\r\n\r\n    setActiveIdentification(`combination-${combination.id}`);\r\n    const result = identifyIncorrectCombination(combination);\r\n\r\n    // Reset active state after a short delay\r\n    setTimeout(() => {\r\n      setActiveIdentification(null);\r\n    }, 2000);\r\n  };\r\n\r\n  const getCombinationButtonState = (combination) => {\r\n    const key = `combination-${combination.id}`;\r\n    const result = identificationResults[key];\r\n    const isActive = activeIdentification === key;\r\n    \r\n    return {\r\n      isActive,\r\n      hasIncorrect: result && result.count > 0,\r\n      count: result ? result.count : 0\r\n    };\r\n  };\r\n\r\n  const combinations = generateCombinations();\r\n\r\n  return (\r\n    <IdentifyContainer>\r\n      <SectionTitle>Identify Incorrect Shapes</SectionTitle>\r\n      <Instructions>\r\n        Click any button below to identify pieces with that specific combination of shape+color+border that are in incorrect positions.\r\n        Buttons show the count of incorrect pieces found for each combination.\r\n      </Instructions>\r\n\r\n      {/* Black Faces Identification */}\r\n      <div>\r\n        <h4 style={{ color: 'white', marginBottom: '10px', fontSize: '16px' }}>Special Issues</h4>\r\n        <ButtonGrid style={{ gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', marginBottom: '20px' }}>\r\n          <IdentifyButton\r\n            onClick={() => handleButtonClick('blackFaces', 'all')}\r\n            disabled={isScrambling}\r\n            $isActive={activeIdentification === 'blackFaces-all'}\r\n            $hasIncorrect={identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0}\r\n            style={{\r\n              background: 'rgba(255, 0, 0, 0.2)',\r\n              borderColor: '#ff0000',\r\n              borderWidth: '3px'\r\n            }}\r\n          >\r\n            <ButtonContent>\r\n              <div style={{ fontSize: '24px', marginBottom: '8px' }}>⚫</div>\r\n              <ButtonTitle style={{ color: '#ff0000', fontWeight: 'bold' }}>\r\n                Dark Gray Faces\r\n              </ButtonTitle>\r\n              <ButtonSubtitle>\r\n                Find pieces with dark gray faces (highlighted in pink)\r\n              </ButtonSubtitle>\r\n              {identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0 && (\r\n                <CountBadge $hasIncorrect={true}>\r\n                  {identificationResults['blackFaces'].count} pieces\r\n                  <br />\r\n                  {identificationResults['blackFaces'].totalBlackFaces} faces\r\n                </CountBadge>\r\n              )}\r\n            </ButtonContent>\r\n          </IdentifyButton>\r\n        </ButtonGrid>\r\n      </div>\r\n\r\n      {/* Combination Identification */}\r\n      <div>\r\n        <h4 style={{ color: 'white', marginBottom: '15px', fontSize: '16px' }}>By Shape + Color + Border Combinations</h4>\r\n        <ButtonGrid style={{ gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))' }}>\r\n          {combinations.map(combination => {\r\n            const state = getCombinationButtonState(combination);\r\n            \r\n            return (\r\n              <IdentifyButton\r\n                key={`combination-${combination.id}`}\r\n                onClick={() => handleCombinationClick(combination)}\r\n                disabled={isScrambling}\r\n                $isActive={state.isActive}\r\n                $hasIncorrect={state.hasIncorrect}\r\n                style={{\r\n                  borderColor: state.hasIncorrect ? '#ff4757' : combination.borderColorHex,\r\n                  borderWidth: '3px'\r\n                }}\r\n              >\r\n                <ButtonContent>\r\n                  <ShapeContainer>\r\n                    {combination.shapeType === 'Triangle' ? (\r\n                      <svg width=\"50\" height=\"50\" viewBox=\"0 0 50 50\">\r\n                        <polygon \r\n                          points=\"25,5 45,40 5,40\" \r\n                          fill={getShapeColorHex(combination.shapeColor)}\r\n                          stroke={combination.borderColorHex}\r\n                          strokeWidth=\"3\"\r\n                        />\r\n                      </svg>\r\n                    ) : (\r\n                      <ShapeVisual\r\n                        $shapeType={combination.shapeType}\r\n                        $shapeColor={getShapeColorHex(combination.shapeColor)}\r\n                        $borderColor={combination.borderColorHex}\r\n                      />\r\n                    )}\r\n                    {state.count > 0 && (\r\n                      <CountBadge $hasIncorrect={state.hasIncorrect}>\r\n                        {state.count}\r\n                      </CountBadge>\r\n                    )}\r\n                  </ShapeContainer>\r\n                  <ButtonTitle>\r\n                    {combination.shapeColor} {combination.shapeType}\r\n                  </ButtonTitle>\r\n                </ButtonContent>\r\n              </IdentifyButton>\r\n            );\r\n          })}\r\n        </ButtonGrid>\r\n      </div>\r\n\r\n      {/* Status Message */}\r\n      {activeIdentification && (\r\n        <StatusMessage $type=\"success\">\r\n          Combination identification complete! Check the terminal for detailed results.\r\n        </StatusMessage>\r\n      )}\r\n    </IdentifyContainer>\r\n  );\r\n}\r\n\r\nexport default IdentifyIncorrectShapes;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}