{"ast":null,"code":"var _jsxFileName = \"C:\\\\Repo\\\\GitHub\\\\rubiks-cube\\\\src\\\\components\\\\IdentifyIncorrectShapes.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport styled from 'styled-components';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst IdentifyContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 20px;\n  padding: 20px;\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 15px;\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);\n  max-height: 500px;\n  overflow-y: auto;\n`;\n_c = IdentifyContainer;\nconst SectionTitle = styled.h3`\n  color: white;\n  text-align: center;\n  margin: 0 0 15px 0;\n  font-size: 1.3rem;\n  font-weight: 600;\n  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\n`;\n_c2 = SectionTitle;\nconst ButtonGrid = styled.div`\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  gap: 15px;\n  margin-bottom: 20px;\n`;\n_c3 = ButtonGrid;\nconst IdentifyButton = styled.button`\n  padding: 12px 16px;\n  border: 2px solid ${props => {\n  if (props.$isActive) return '#4CAF50';\n  if (props.$hasIncorrect) return '#ff4757';\n  return 'rgba(255, 255, 255, 0.3)';\n}};\n  border-radius: 10px;\n  font-size: 14px;\n  font-weight: 600;\n  cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};\n  transition: all 0.3s ease;\n  background: ${props => {\n  if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\n  if (props.$isActive) return 'rgba(76, 175, 80, 0.2)';\n  if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.2)';\n  return 'rgba(255, 255, 255, 0.1)';\n}};\n  color: ${props => {\n  if (props.disabled) return '#666';\n  if (props.$isActive) return '#4CAF50';\n  if (props.$hasIncorrect) return '#ff4757';\n  return 'white';\n}};\n  opacity: ${props => props.disabled ? 0.5 : 1};\n  \n  &:hover {\n    transform: ${props => props.disabled ? 'none' : 'translateY(-2px)'};\n    box-shadow: ${props => props.disabled ? 'none' : '0 4px 12px rgba(0, 0, 0, 0.3)'};\n    background: ${props => {\n  if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\n  if (props.$isActive) return 'rgba(76, 175, 80, 0.3)';\n  if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.3)';\n  return 'rgba(255, 255, 255, 0.2)';\n}};\n  }\n  \n  &:active {\n    transform: ${props => props.disabled ? 'none' : 'translateY(0)'};\n  }\n`;\n_c4 = IdentifyButton;\nconst ButtonContent = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 4px;\n  width: 100%;\n  height: 100%;\n  position: relative;\n`;\n_c5 = ButtonContent;\nconst ShapeContainer = styled.div`\n  width: 60px;\n  height: 60px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n  margin: 8px 0;\n`;\n_c6 = ShapeContainer;\nconst ShapeVisual = styled.div`\n  width: 50px;\n  height: 50px;\n  background: ${props => props.$shapeColor};\n  border: 3px solid ${props => props.$borderColor};\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  \n  /* Shape-specific styling */\n  border-radius: ${props => {\n  if (props.$shapeType === 'Circle') return '50%';\n  if (props.$shapeType === 'Diamond') return '0';\n  return '0';\n}};\n  \n  transform: ${props => {\n  if (props.$shapeType === 'Diamond') return 'rotate(45deg)';\n  return 'none';\n}};\n  \n  /* Triangle shape using CSS */\n  ${props => props.$shapeType === 'Triangle' && `\n    width: 0;\n    height: 0;\n    background: transparent;\n    border: none;\n    border-left: 25px solid transparent;\n    border-right: 25px solid transparent;\n    border-bottom: 43px solid ${props.$shapeColor};\n    position: relative;\n  `}\n`;\n_c7 = ShapeVisual;\nconst CountBadge = styled.span`\n  background: ${props => props.$hasIncorrect ? '#ff4757' : '#4CAF50'};\n  color: white;\n  border-radius: 50%;\n  width: 20px;\n  height: 20px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 10px;\n  font-weight: bold;\n  position: absolute;\n  top: -5px;\n  right: -5px;\n  z-index: 10;\n`;\n_c8 = CountBadge;\nconst ButtonTitle = styled.span`\n  font-size: 12px;\n  font-weight: 600;\n  color: white;\n  text-align: center;\n  margin-top: 4px;\n`;\n_c9 = ButtonTitle;\nconst ButtonSubtitle = styled.div`\n  font-size: 10px;\n  color: rgba(255, 255, 255, 0.8);\n  text-align: center;\n  margin-top: 2px;\n  line-height: 1.2;\n`;\n_c0 = ButtonSubtitle;\nconst Instructions = styled.p`\n  color: rgba(255, 255, 255, 0.8);\n  font-size: 13px;\n  text-align: center;\n  margin: 0 0 15px 0;\n  line-height: 1.4;\n`;\n_c1 = Instructions;\nconst StatusMessage = styled.div`\n  padding: 10px;\n  border-radius: 8px;\n  text-align: center;\n  font-size: 12px;\n  font-weight: 600;\n  background: ${props => {\n  if (props.$type === 'success') return 'rgba(76, 175, 80, 0.2)';\n  if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.2)';\n  if (props.$type === 'error') return 'rgba(244, 67, 54, 0.2)';\n  return 'rgba(33, 150, 243, 0.2)';\n}};\n  color: ${props => {\n  if (props.$type === 'success') return '#4CAF50';\n  if (props.$type === 'warning') return '#FFC107';\n  if (props.$type === 'error') return '#f44336';\n  return '#2196F3';\n}};\n  border: 1px solid ${props => {\n  if (props.$type === 'success') return 'rgba(76, 175, 80, 0.3)';\n  if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.3)';\n  if (props.$type === 'error') return 'rgba(244, 67, 54, 0.3)';\n  return 'rgba(33, 150, 243, 0.3)';\n}};\n`;\n\n// Custom logging function\n_c10 = StatusMessage;\nconst logToTerminal = (message, data = null) => {\n  console.log(`\\nðŸŽ¯ ${message}`);\n  if (data) {\n    console.log(JSON.stringify(data, null, 2));\n  }\n  console.log('='.repeat(80) + '\\n');\n\n  // Try to send to log server, but don't fail if it's not available\n  const sendToLogServer = async () => {\n    try {\n      const response = await fetch('http://localhost:3001/log', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message: message,\n          data: data\n        }),\n        // Add timeout to prevent hanging\n        signal: AbortSignal.timeout(1000)\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      console.log('âœ… Log sent to terminal successfully');\n    } catch (error) {\n      // Silently fail - logging server is optional\n      console.log('ðŸ’¡ Log server not available - logging to console only');\n    }\n  };\n\n  // Execute without blocking\n  sendToLogServer();\n};\nfunction IdentifyIncorrectShapes({\n  isScrambling,\n  cubeState,\n  onIdentification,\n  setCubeState\n}) {\n  _s();\n  const [activeIdentification, setActiveIdentification] = useState(null);\n  const [identificationResults, setIdentificationResults] = useState({});\n  if (!cubeState) {\n    console.log('ðŸš¨ SHOWING LOADING MESSAGE - no cubeState');\n    return /*#__PURE__*/_jsxDEV(IdentifyContainer, {\n      children: [/*#__PURE__*/_jsxDEV(SectionTitle, {\n        children: \"Identify Incorrect Shapes\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 244,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(StatusMessage, {\n        $type: \"warning\",\n        children: \"Loading cube state... Please scramble the cube first to identify incorrect shapes.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 245,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 243,\n      columnNumber: 7\n    }, this);\n  }\n\n  // Helper functions\n  const getShapeType = pieceId => {\n    const shapeTypes = ['Square', 'Square', 'Square', 'Square', 'Square', 'Circle', 'Circle', 'Circle', 'Circle', 'Circle', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle'];\n    return shapeTypes[pieceId] || 'Unknown';\n  };\n  const getShapeColor = pieceId => {\n    const shapeColors = ['Red', 'Blue', 'Green', 'Orange', 'Purple', 'Red', 'Blue', 'Green', 'Orange', 'Yellow', 'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple', 'Red', 'Blue', 'Green', 'Orange', 'Purple', 'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple', 'Yellow'];\n    return shapeColors[pieceId] || 'Unknown';\n  };\n  const getExpectedPosition = pieceId => {\n    const positions = [];\n    for (let x = -1; x <= 1; x++) {\n      for (let y = -1; y <= 1; y++) {\n        for (let z = -1; z <= 1; z++) {\n          if (x === 0 && y === 0 && z === 0) continue;\n          positions.push([x, y, z]);\n        }\n      }\n    }\n    return positions[pieceId];\n  };\n  const isPieceInCorrectPosition = (piece, pieceId) => {\n    if (!piece || !piece.position) return false;\n    const expectedPosition = getExpectedPosition(pieceId);\n    return JSON.stringify(piece.position) === JSON.stringify(expectedPosition);\n  };\n  const getExpectedBorderColor = faceIndex => {\n    const borderColors = ['#FFFFFF',\n    // Face 0 (front) - White\n    '#FF8C00',\n    // Face 1 (back) - Orange  \n    '#00FF00',\n    // Face 2 (right) - Green\n    '#DC143C',\n    // Face 3 (left) - Red\n    '#0000FF',\n    // Face 4 (top) - Blue\n    '#FFD700' // Face 5 (bottom) - Yellow\n    ];\n    return borderColors[faceIndex] || '#000000';\n  };\n  const getBorderColorName = faceIndex => {\n    const colorNames = ['White', 'Orange', 'Green', 'Red', 'Blue', 'Yellow'];\n    return colorNames[faceIndex] || 'Unknown';\n  };\n  const getShapeColorHex = shapeColor => {\n    const colorMap = {\n      'Red': '#DC143C',\n      'Blue': '#0000FF',\n      'Green': '#00FF00',\n      'Orange': '#FF8C00',\n      'Purple': '#800080',\n      'Yellow': '#FFD700',\n      'Cyan': '#00FFFF',\n      'Magenta': '#FF00FF',\n      'Lime': '#00FF00',\n      'Pink': '#FFC0CB'\n    };\n    return colorMap[shapeColor] || '#000000';\n  };\n\n  // Get pieces data\n  const getPieces = () => {\n    if (Array.isArray(cubeState)) {\n      return cubeState.map((piece, index) => ({\n        pieceId: index,\n        position: piece.position,\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory || []\n      }));\n    } else if (cubeState !== null && cubeState !== void 0 && cubeState.pieces) {\n      return cubeState.pieces;\n    }\n    return [];\n  };\n  const pieces = getPieces();\n\n  // Identify incorrect shapes by type\n  const identifyIncorrectShapesByType = shapeType => {\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const actualShapeType = getShapeType(pieceId);\n      return actualShapeType === shapeType && !isPieceInCorrectPosition(piece, pieceId);\n    });\n    const result = {\n      type: 'shape',\n      shapeType,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`shape-${shapeType}`]: result\n    }));\n    logToTerminal(`ðŸ” IDENTIFIED INCORRECT ${shapeType.toUpperCase()} SHAPES`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n\n  // Identify incorrect shapes by color\n  const identifyIncorrectShapesByColor = shapeColor => {\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const actualShapeColor = getShapeColor(pieceId);\n      return actualShapeColor === shapeColor && !isPieceInCorrectPosition(piece, pieceId);\n    });\n    const result = {\n      type: 'color',\n      shapeColor,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`color-${shapeColor}`]: result\n    }));\n    logToTerminal(`ðŸŽ¨ IDENTIFIED INCORRECT ${shapeColor.toUpperCase()} SHAPES`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n\n  // Identify incorrect border colors\n  const identifyIncorrectBorderColors = faceIndex => {\n    const borderColorName = getBorderColorName(faceIndex);\n    const borderColorHex = getExpectedBorderColor(faceIndex);\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\n\n      // Check if this piece should have this border color in its current position\n      const [x, y, z] = piece.position;\n      let shouldHaveBorderColor = false;\n      switch (faceIndex) {\n        case 0:\n          // Front face (Z+) - White\n          shouldHaveBorderColor = z === 1;\n          break;\n        case 1:\n          // Back face (Z-) - Orange\n          shouldHaveBorderColor = z === -1;\n          break;\n        case 2:\n          // Right face (X+) - Green\n          shouldHaveBorderColor = x === 1;\n          break;\n        case 3:\n          // Left face (X-) - Red\n          shouldHaveBorderColor = x === -1;\n          break;\n        case 4:\n          // Top face (Y+) - Blue\n          shouldHaveBorderColor = y === 1;\n          break;\n        case 5:\n          // Bottom face (Y-) - Yellow\n          shouldHaveBorderColor = y === -1;\n          break;\n      }\n\n      // Piece is incorrect if it should have this border color but is not in correct position\n      return shouldHaveBorderColor && !isInCorrectPosition;\n    });\n    const result = {\n      type: 'border',\n      faceIndex,\n      borderColorName,\n      borderColorHex,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`border-${faceIndex}`]: result\n    }));\n    logToTerminal(`ðŸŽ­ IDENTIFIED INCORRECT ${borderColorName.toUpperCase()} BORDER COLORS`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n\n  // Identify pieces with black faces that should be visible\n  const identifyPiecesWithBlackFaces = () => {\n    logToTerminal('ðŸ” ========== STARTING BLACK FACES IDENTIFICATION ==========');\n    logToTerminal('ðŸ” cubeState type:', typeof cubeState);\n    logToTerminal('ðŸ” cubeState length:', cubeState ? cubeState.length : 'null');\n    logToTerminal('ðŸ” cubeState is null:', cubeState === null);\n    logToTerminal('ðŸ” cubeState is undefined:', cubeState === undefined);\n    if (!cubeState || cubeState.length === 0) {\n      logToTerminal('ðŸ” âŒ No cube state available for identification');\n      return {\n        type: 'blackFaces',\n        incorrectPieces: [],\n        count: 0,\n        totalBlackFaces: 0\n      };\n    }\n    logToTerminal('ðŸ” âœ… Cube state available, checking', cubeState.length, 'pieces...');\n    const incorrectPieces = [];\n    let totalBlackFaces = 0;\n    let piecesChecked = 0;\n    let piecesWithColors = 0;\n    let piecesWithPosition = 0;\n\n    // Log detailed structure of first few pieces\n    logToTerminal('ðŸ” ========== PIECE STRUCTURE ANALYSIS ==========');\n    cubeState.slice(0, 5).forEach((piece, index) => {\n      logToTerminal(`ðŸ” Piece ${index}:`, {\n        pieceId: piece.pieceId,\n        hasPosition: Array.isArray(piece.position),\n        position: piece.position,\n        hasColors: typeof piece.colors === 'object' && piece.colors !== null,\n        colors: piece.colors,\n        allKeys: Object.keys(piece)\n      });\n    });\n    logToTerminal('ðŸ” ========== CHECKING ALL PIECES ==========');\n    cubeState.forEach((piece, index) => {\n      piecesChecked++;\n      const pieceId = piece.pieceId || index;\n\n      // Check if piece has position\n      if (!Array.isArray(piece.position)) {\n        logToTerminal(`ðŸ” âŒ Piece ${pieceId} has invalid position:`, piece.position);\n        return;\n      }\n      piecesWithPosition++;\n\n      // Check if piece has colors\n      if (!piece.colors || typeof piece.colors !== 'object') {\n        logToTerminal(`ðŸ” âŒ Piece ${pieceId} has invalid colors:`, piece.colors);\n        return;\n      }\n      piecesWithColors++;\n      const [x, y, z] = piece.position;\n      logToTerminal(`ðŸ” Checking piece ${pieceId} at position [${x}, ${y}, ${z}]`);\n      logToTerminal(`ðŸ” Piece colors object:`, piece.colors);\n      logToTerminal(`ðŸ” Color keys:`, Object.keys(piece.colors));\n\n      // Determine which faces should be visible based on current position\n      const visibleFaces = [];\n      if (x === 1) visibleFaces.push('right');\n      if (x === -1) visibleFaces.push('left');\n      if (y === 1) visibleFaces.push('top');\n      if (y === -1) visibleFaces.push('bottom');\n      if (z === 1) visibleFaces.push('front');\n      if (z === -1) visibleFaces.push('back');\n      logToTerminal(`ðŸ” Visible faces for piece ${pieceId}:`, visibleFaces);\n\n      // Check if any visible faces are black/gray\n      const blackVisibleFaces = [];\n      visibleFaces.forEach(face => {\n        const faceColor = piece.colors[face];\n        logToTerminal(`ðŸ” Face ${face} color: \"${faceColor}\" (type: ${typeof faceColor})`);\n\n        // Check for both #444444 and 'black' values\n        if (faceColor === '#444444' || faceColor === 'black' || faceColor === '#000000') {\n          blackVisibleFaces.push(face);\n          totalBlackFaces++;\n          logToTerminal(`ðŸ” âœ… FOUND BLACK/GRAY FACE: ${face} on piece ${pieceId} with color \"${faceColor}\"`);\n        } else {\n          logToTerminal(`ðŸ” Face ${face} is not black/gray (color: \"${faceColor}\")`);\n        }\n      });\n      if (blackVisibleFaces.length > 0) {\n        incorrectPieces.push({\n          pieceId: pieceId,\n          currentPosition: piece.position,\n          blackVisibleFaces: blackVisibleFaces\n        });\n        logToTerminal(`ðŸ” âœ… Added piece ${pieceId} to incorrect pieces with ${blackVisibleFaces.length} black faces:`, blackVisibleFaces);\n      } else {\n        logToTerminal(`ðŸ” Piece ${pieceId} has no black visible faces`);\n      }\n    });\n    logToTerminal('ðŸ” ========== IDENTIFICATION SUMMARY ==========');\n    logToTerminal('ðŸ” Total pieces checked:', piecesChecked);\n    logToTerminal('ðŸ” Pieces with valid position:', piecesWithPosition);\n    logToTerminal('ðŸ” Pieces with valid colors:', piecesWithColors);\n    logToTerminal('ðŸ” Pieces with black faces:', incorrectPieces.length);\n    logToTerminal('ðŸ” Total black faces found:', totalBlackFaces);\n    logToTerminal('ðŸ” Incorrect pieces details:', incorrectPieces);\n    const result = {\n      type: 'blackFaces',\n      incorrectPieces: incorrectPieces,\n      count: incorrectPieces.length,\n      totalBlackFaces: totalBlackFaces\n    };\n    logToTerminal('ðŸ” ========== RETURNING RESULT ==========');\n    logToTerminal('ðŸ” Result:', result);\n    setIdentificationResults(prev => {\n      const newResults = {\n        ...prev,\n        'blackFaces': result\n      };\n      logToTerminal('ðŸ”§ UPDATING identificationResults:', newResults);\n      return newResults;\n    });\n    return result;\n  };\n  const handleButtonClick = (type, identifier) => {\n    if (isScrambling) return;\n    setActiveIdentification(`${type}-${identifier}`);\n    let result;\n    switch (type) {\n      case 'shape':\n        result = identifyIncorrectShapesByType(identifier);\n        break;\n      case 'color':\n        result = identifyIncorrectShapesByColor(identifier);\n        break;\n      case 'border':\n        result = identifyIncorrectBorderColors(identifier);\n        break;\n      case 'blackFaces':\n        result = identifyPiecesWithBlackFaces();\n        break;\n    }\n\n    // Reset active state after a short delay\n    setTimeout(() => {\n      setActiveIdentification(null);\n    }, 2000);\n  };\n  const handleFindAndFixGrayFaces = () => {\n    logToTerminal('ðŸ”§ FIND AND FIX GRAY FACES BUTTON CLICKED!');\n    logToTerminal('ðŸ”§ isScrambling:', isScrambling);\n    if (isScrambling) {\n      logToTerminal('ðŸ”§ Button disabled - cube is scrambling');\n      return;\n    }\n\n    // First identify the pieces with black faces\n    const blackFacesResult = identifyPiecesWithBlackFaces();\n    if (blackFacesResult.count === 0) {\n      logToTerminal('No gray faces to fix');\n      return;\n    }\n    logToTerminal('ðŸ”§ FOUND AND FIXING GRAY FACES:', blackFacesResult.incorrectPieces.length, 'pieces');\n    logToTerminal('ðŸ”§ Pieces to fix:', blackFacesResult.incorrectPieces.map(p => `${p.pieceId} at [${p.currentPosition.join(', ')}]`));\n\n    // Update the cube state to fix the colors\n    setCubeState(prevState => {\n      logToTerminal('ðŸ”§ setCubeState called with prevState length:', prevState.length);\n      const newState = [...prevState];\n      blackFacesResult.incorrectPieces.forEach(incorrectPiece => {\n        logToTerminal(`ðŸ”§ Processing piece ${incorrectPiece.pieceId}...`);\n        const pieceIndex = newState.findIndex(p => p.pieceId === incorrectPiece.pieceId);\n        logToTerminal(`ðŸ”§ Found piece at index ${pieceIndex}`);\n        if (pieceIndex !== -1) {\n          const piece = newState[pieceIndex];\n          const [x, y, z] = piece.position;\n          logToTerminal(`ðŸ”§ Piece ${piece.pieceId} at position [${x}, ${y}, ${z}]`);\n          logToTerminal(`ðŸ”§ Current colors:`, piece.colors);\n\n          // Determine which faces should be visible based on current position\n          const visibleFaces = [];\n          if (x === 1) visibleFaces.push('right');\n          if (x === -1) visibleFaces.push('left');\n          if (y === 1) visibleFaces.push('top');\n          if (y === -1) visibleFaces.push('bottom');\n          if (z === 1) visibleFaces.push('front');\n          if (z === -1) visibleFaces.push('back');\n          logToTerminal(`ðŸ”§ Visible faces:`, visibleFaces);\n\n          // Fix the colors for visible faces that are currently black/gray\n          const updatedColors = {\n            ...piece.colors\n          };\n          let fixedAny = false;\n          visibleFaces.forEach(face => {\n            logToTerminal(`ðŸ”§ Checking face ${face}: current color = ${updatedColors[face]}`);\n            if (updatedColors[face] === '#444444') {\n              // Set the correct color based on the face\n              switch (face) {\n                case 'front':\n                  updatedColors[face] = '#FFFFFF'; // White\n                  break;\n                case 'back':\n                  updatedColors[face] = '#FFD700'; // Yellow\n                  break;\n                case 'right':\n                  updatedColors[face] = '#DC143C'; // Red\n                  break;\n                case 'left':\n                  updatedColors[face] = '#FF8C00'; // Orange\n                  break;\n                case 'top':\n                  updatedColors[face] = '#0000FF'; // Blue\n                  break;\n                case 'bottom':\n                  updatedColors[face] = '#00FF00'; // Green\n                  break;\n              }\n              logToTerminal(`ðŸ”§ Fixed face ${face} to ${updatedColors[face]}`);\n              fixedAny = true;\n            }\n          });\n          if (fixedAny) {\n            newState[pieceIndex] = {\n              ...piece,\n              colors: updatedColors\n            };\n            logToTerminal(`ðŸ”§ Updated piece ${piece.pieceId} with new colors:`, updatedColors);\n          } else {\n            logToTerminal(`ðŸ”§ No changes needed for piece ${piece.pieceId}`);\n          }\n        } else {\n          logToTerminal(`ðŸ”§ ERROR: Could not find piece ${incorrectPiece.pieceId} in cube state`);\n        }\n      });\n      logToTerminal('âœ… Gray faces find and fix completed!');\n      logToTerminal('ðŸ”§ New state length:', newState.length);\n      return newState;\n    });\n\n    // Clear the identification results since we've fixed the issue\n    setIdentificationResults(prev => ({\n      ...prev,\n      blackFaces: null\n    }));\n\n    // Clear the highlighting by calling onIdentification with empty result\n    if (onIdentification) {\n      onIdentification({\n        type: 'blackFaces',\n        count: 0,\n        totalBlackFaces: 0,\n        incorrectPieces: []\n      });\n    }\n  };\n  const getButtonState = (type, identifier) => {\n    const key = `${type}-${identifier}`;\n    const result = identificationResults[key];\n    const isActive = activeIdentification === key;\n    return {\n      isActive,\n      hasIncorrect: result && result.count > 0,\n      count: result ? result.count : 0\n    };\n  };\n\n  // Generate all possible combinations of shape+color+border\n  const generateCombinations = () => {\n    const shapeTypes = ['Square', 'Circle', 'Triangle', 'Diamond'];\n    const shapeColors = ['Red', 'Blue', 'Green', 'Orange', 'Purple', 'Yellow', 'Cyan', 'Magenta', 'Lime', 'Pink'];\n    const borderColors = [{\n      name: 'White',\n      hex: '#FFFFFF',\n      faceIndex: 0\n    }, {\n      name: 'Orange',\n      hex: '#FF8C00',\n      faceIndex: 1\n    }, {\n      name: 'Green',\n      hex: '#00FF00',\n      faceIndex: 2\n    }, {\n      name: 'Red',\n      hex: '#DC143C',\n      faceIndex: 3\n    }, {\n      name: 'Blue',\n      hex: '#0000FF',\n      faceIndex: 4\n    }, {\n      name: 'Yellow',\n      hex: '#FFD700',\n      faceIndex: 5\n    }];\n    const combinations = [];\n    shapeTypes.forEach(shapeType => {\n      shapeColors.forEach(shapeColor => {\n        borderColors.forEach(borderColor => {\n          combinations.push({\n            id: `${shapeType}-${shapeColor}-${borderColor.name}`,\n            shapeType,\n            shapeColor,\n            borderColor: borderColor.name,\n            borderColorHex: borderColor.hex,\n            faceIndex: borderColor.faceIndex\n          });\n        });\n      });\n    });\n    return combinations;\n  };\n\n  // Identify incorrect pieces by combination\n  const identifyIncorrectCombination = combination => {\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const actualShapeType = getShapeType(pieceId);\n      const actualShapeColor = getShapeColor(pieceId);\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\n\n      // Check if this piece matches the combination\n      const matchesShape = actualShapeType === combination.shapeType;\n      const matchesColor = actualShapeColor === combination.shapeColor;\n\n      // Check if this piece should have this border color in its current position\n      const [x, y, z] = piece.position;\n      let shouldHaveBorderColor = false;\n      switch (combination.faceIndex) {\n        case 0:\n          // Front face (Z+) - White\n          shouldHaveBorderColor = z === 1;\n          break;\n        case 1:\n          // Back face (Z-) - Orange\n          shouldHaveBorderColor = z === -1;\n          break;\n        case 2:\n          // Right face (X+) - Green\n          shouldHaveBorderColor = x === 1;\n          break;\n        case 3:\n          // Left face (X-) - Red\n          shouldHaveBorderColor = x === -1;\n          break;\n        case 4:\n          // Top face (Y+) - Blue\n          shouldHaveBorderColor = y === 1;\n          break;\n        case 5:\n          // Bottom face (Y-) - Yellow\n          shouldHaveBorderColor = y === -1;\n          break;\n      }\n\n      // Piece is incorrect if it matches the combination but is not in correct position\n      return matchesShape && matchesColor && shouldHaveBorderColor && !isInCorrectPosition;\n    });\n    const result = {\n      type: 'combination',\n      combination,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`combination-${combination.id}`]: result\n    }));\n    logToTerminal(`ðŸŽ¯ IDENTIFIED INCORRECT ${combination.shapeColor} ${combination.shapeType} with ${combination.borderColor} border`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n  const handleCombinationClick = combination => {\n    if (isScrambling) return;\n    setActiveIdentification(`combination-${combination.id}`);\n    const result = identifyIncorrectCombination(combination);\n\n    // Reset active state after a short delay\n    setTimeout(() => {\n      setActiveIdentification(null);\n    }, 2000);\n  };\n  const getCombinationButtonState = combination => {\n    const key = `combination-${combination.id}`;\n    const result = identificationResults[key];\n    const isActive = activeIdentification === key;\n    return {\n      isActive,\n      hasIncorrect: result && result.count > 0,\n      count: result ? result.count : 0\n    };\n  };\n  const combinations = generateCombinations();\n  return /*#__PURE__*/_jsxDEV(IdentifyContainer, {\n    children: [/*#__PURE__*/_jsxDEV(SectionTitle, {\n      children: \"Identify Incorrect Shapes\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 905,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Instructions, {\n      children: \"Click any button below to identify pieces with that specific combination of shape+color+border that are in incorrect positions. Buttons show the count of incorrect pieces found for each combination.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 906,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n        style: {\n          color: 'white',\n          marginBottom: '10px',\n          fontSize: '16px'\n        },\n        children: \"Special Issues\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 913,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ButtonGrid, {\n        style: {\n          gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',\n          marginBottom: '20px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(IdentifyButton, {\n          onClick: () => handleButtonClick('blackFaces', 'all'),\n          disabled: isScrambling,\n          $isActive: activeIdentification === 'blackFaces-all',\n          $hasIncorrect: identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0,\n          style: {\n            background: 'rgba(255, 0, 0, 0.2)',\n            borderColor: '#ff0000',\n            borderWidth: '3px',\n            display: 'none' // Hide the button but keep functionality\n          },\n          children: /*#__PURE__*/_jsxDEV(ButtonContent, {\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              style: {\n                fontSize: '24px',\n                marginBottom: '8px'\n              },\n              children: \"\\u26AB\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 928,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonTitle, {\n              style: {\n                color: '#ff0000',\n                fontWeight: 'bold'\n              },\n              children: \"Dark Gray Faces\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 929,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonSubtitle, {\n              children: \"Find pieces with dark gray faces (highlighted in pink)\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 932,\n              columnNumber: 15\n            }, this), identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0 && /*#__PURE__*/_jsxDEV(CountBadge, {\n              $hasIncorrect: true,\n              children: [identificationResults['blackFaces'].count, \" pieces\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 938,\n                columnNumber: 19\n              }, this), identificationResults['blackFaces'].totalBlackFaces, \" faces\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 936,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 927,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 915,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(IdentifyButton, {\n          onClick: () => {\n            logToTerminal('ðŸ”§ BUTTON CLICKED - onClick handler triggered');\n            logToTerminal('ðŸ”§ isScrambling:', isScrambling);\n            handleFindAndFixGrayFaces();\n          },\n          disabled: isScrambling,\n          $isActive: false,\n          $hasIncorrect: false,\n          style: {\n            borderColor: '#FF6B6B',\n            borderWidth: '3px',\n            background: 'rgba(255, 107, 107, 0.2)'\n          },\n          children: /*#__PURE__*/_jsxDEV(ButtonContent, {\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              style: {\n                fontSize: '24px',\n                marginBottom: '8px'\n              },\n              children: \"\\uD83D\\uDD27\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 962,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonTitle, {\n              style: {\n                color: '#FF6B6B',\n                fontWeight: 'bold'\n              },\n              children: \"Find & Fix Gray Faces\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 963,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonSubtitle, {\n              children: \"Identify and automatically correct dark gray faces to proper colors\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 966,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 961,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 946,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 914,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 912,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n        style: {\n          color: 'white',\n          marginBottom: '15px',\n          fontSize: '16px'\n        },\n        children: \"By Shape + Color + Border Combinations\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 976,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ButtonGrid, {\n        style: {\n          gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))'\n        },\n        children: combinations.map(combination => {\n          const state = getCombinationButtonState(combination);\n          return /*#__PURE__*/_jsxDEV(IdentifyButton, {\n            onClick: () => handleCombinationClick(combination),\n            disabled: isScrambling,\n            $isActive: state.isActive,\n            $hasIncorrect: state.hasIncorrect,\n            style: {\n              borderColor: state.hasIncorrect ? '#ff4757' : combination.borderColorHex,\n              borderWidth: '3px'\n            },\n            children: /*#__PURE__*/_jsxDEV(ButtonContent, {\n              children: [/*#__PURE__*/_jsxDEV(ShapeContainer, {\n                children: [combination.shapeType === 'Triangle' ? /*#__PURE__*/_jsxDEV(\"svg\", {\n                  width: \"50\",\n                  height: \"50\",\n                  viewBox: \"0 0 50 50\",\n                  children: /*#__PURE__*/_jsxDEV(\"polygon\", {\n                    points: \"25,5 45,40 5,40\",\n                    fill: getShapeColorHex(combination.shapeColor),\n                    stroke: combination.borderColorHex,\n                    strokeWidth: \"3\"\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 997,\n                    columnNumber: 25\n                  }, this)\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 996,\n                  columnNumber: 23\n                }, this) : /*#__PURE__*/_jsxDEV(ShapeVisual, {\n                  $shapeType: combination.shapeType,\n                  $shapeColor: getShapeColorHex(combination.shapeColor),\n                  $borderColor: combination.borderColorHex\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1005,\n                  columnNumber: 23\n                }, this), state.count > 0 && /*#__PURE__*/_jsxDEV(CountBadge, {\n                  $hasIncorrect: state.hasIncorrect,\n                  children: state.count\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1012,\n                  columnNumber: 23\n                }, this)]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 994,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(ButtonTitle, {\n                children: [combination.shapeColor, \" \", combination.shapeType]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 1017,\n                columnNumber: 19\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 993,\n              columnNumber: 17\n            }, this)\n          }, `combination-${combination.id}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 982,\n            columnNumber: 15\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 977,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 975,\n      columnNumber: 7\n    }, this), activeIdentification && /*#__PURE__*/_jsxDEV(StatusMessage, {\n      $type: \"success\",\n      children: \"Combination identification complete! Check the terminal for detailed results.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1029,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 904,\n    columnNumber: 5\n  }, this);\n}\n_s(IdentifyIncorrectShapes, \"ii/H1hjjocRwhM9agB/LU82OhuE=\");\n_c11 = IdentifyIncorrectShapes;\nexport default IdentifyIncorrectShapes;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c0, _c1, _c10, _c11;\n$RefreshReg$(_c, \"IdentifyContainer\");\n$RefreshReg$(_c2, \"SectionTitle\");\n$RefreshReg$(_c3, \"ButtonGrid\");\n$RefreshReg$(_c4, \"IdentifyButton\");\n$RefreshReg$(_c5, \"ButtonContent\");\n$RefreshReg$(_c6, \"ShapeContainer\");\n$RefreshReg$(_c7, \"ShapeVisual\");\n$RefreshReg$(_c8, \"CountBadge\");\n$RefreshReg$(_c9, \"ButtonTitle\");\n$RefreshReg$(_c0, \"ButtonSubtitle\");\n$RefreshReg$(_c1, \"Instructions\");\n$RefreshReg$(_c10, \"StatusMessage\");\n$RefreshReg$(_c11, \"IdentifyIncorrectShapes\");","map":{"version":3,"names":["React","useState","styled","jsxDEV","_jsxDEV","IdentifyContainer","div","_c","SectionTitle","h3","_c2","ButtonGrid","_c3","IdentifyButton","button","props","$isActive","$hasIncorrect","disabled","_c4","ButtonContent","_c5","ShapeContainer","_c6","ShapeVisual","$shapeColor","$borderColor","$shapeType","_c7","CountBadge","span","_c8","ButtonTitle","_c9","ButtonSubtitle","_c0","Instructions","p","_c1","StatusMessage","$type","_c10","logToTerminal","message","data","console","log","JSON","stringify","repeat","sendToLogServer","response","fetch","method","headers","body","signal","AbortSignal","timeout","ok","Error","status","error","IdentifyIncorrectShapes","isScrambling","cubeState","onIdentification","setCubeState","_s","activeIdentification","setActiveIdentification","identificationResults","setIdentificationResults","children","fileName","_jsxFileName","lineNumber","columnNumber","getShapeType","pieceId","shapeTypes","getShapeColor","shapeColors","getExpectedPosition","positions","x","y","z","push","isPieceInCorrectPosition","piece","position","expectedPosition","getExpectedBorderColor","faceIndex","borderColors","getBorderColorName","colorNames","getShapeColorHex","shapeColor","colorMap","getPieces","Array","isArray","map","index","colors","rotationHistory","pieces","identifyIncorrectShapesByType","shapeType","incorrectPieces","filter","actualShapeType","result","type","currentPosition","count","length","prev","toUpperCase","identifyIncorrectShapesByColor","actualShapeColor","identifyIncorrectBorderColors","borderColorName","borderColorHex","isInCorrectPosition","shouldHaveBorderColor","identifyPiecesWithBlackFaces","undefined","totalBlackFaces","piecesChecked","piecesWithColors","piecesWithPosition","slice","forEach","hasPosition","hasColors","allKeys","Object","keys","visibleFaces","blackVisibleFaces","face","faceColor","newResults","handleButtonClick","identifier","setTimeout","handleFindAndFixGrayFaces","blackFacesResult","join","prevState","newState","incorrectPiece","pieceIndex","findIndex","updatedColors","fixedAny","blackFaces","getButtonState","key","isActive","hasIncorrect","generateCombinations","name","hex","combinations","borderColor","id","identifyIncorrectCombination","combination","matchesShape","matchesColor","handleCombinationClick","getCombinationButtonState","style","color","marginBottom","fontSize","gridTemplateColumns","onClick","background","borderWidth","display","fontWeight","state","width","height","viewBox","points","fill","stroke","strokeWidth","_c11","$RefreshReg$"],"sources":["C:/Repo/GitHub/rubiks-cube/src/components/IdentifyIncorrectShapes.js"],"sourcesContent":["import React, { useState } from 'react';\r\nimport styled from 'styled-components';\r\n\r\nconst IdentifyContainer = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 20px;\r\n  padding: 20px;\r\n  background: rgba(255, 255, 255, 0.1);\r\n  border-radius: 15px;\r\n  backdrop-filter: blur(10px);\r\n  border: 1px solid rgba(255, 255, 255, 0.2);\r\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);\r\n  max-height: 500px;\r\n  overflow-y: auto;\r\n`;\r\n\r\nconst SectionTitle = styled.h3`\r\n  color: white;\r\n  text-align: center;\r\n  margin: 0 0 15px 0;\r\n  font-size: 1.3rem;\r\n  font-weight: 600;\r\n  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\r\n`;\r\n\r\nconst ButtonGrid = styled.div`\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\r\n  gap: 15px;\r\n  margin-bottom: 20px;\r\n`;\r\n\r\nconst IdentifyButton = styled.button`\r\n  padding: 12px 16px;\r\n  border: 2px solid ${props => {\r\n    if (props.$isActive) return '#4CAF50';\r\n    if (props.$hasIncorrect) return '#ff4757';\r\n    return 'rgba(255, 255, 255, 0.3)';\r\n  }};\r\n  border-radius: 10px;\r\n  font-size: 14px;\r\n  font-weight: 600;\r\n  cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};\r\n  transition: all 0.3s ease;\r\n  background: ${props => {\r\n    if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\r\n    if (props.$isActive) return 'rgba(76, 175, 80, 0.2)';\r\n    if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.2)';\r\n    return 'rgba(255, 255, 255, 0.1)';\r\n  }};\r\n  color: ${props => {\r\n    if (props.disabled) return '#666';\r\n    if (props.$isActive) return '#4CAF50';\r\n    if (props.$hasIncorrect) return '#ff4757';\r\n    return 'white';\r\n  }};\r\n  opacity: ${props => props.disabled ? 0.5 : 1};\r\n  \r\n  &:hover {\r\n    transform: ${props => props.disabled ? 'none' : 'translateY(-2px)'};\r\n    box-shadow: ${props => props.disabled ? 'none' : '0 4px 12px rgba(0, 0, 0, 0.3)'};\r\n    background: ${props => {\r\n      if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\r\n      if (props.$isActive) return 'rgba(76, 175, 80, 0.3)';\r\n      if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.3)';\r\n      return 'rgba(255, 255, 255, 0.2)';\r\n    }};\r\n  }\r\n  \r\n  &:active {\r\n    transform: ${props => props.disabled ? 'none' : 'translateY(0)'};\r\n  }\r\n`;\r\n\r\nconst ButtonContent = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  gap: 4px;\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n`;\r\n\r\nconst ShapeContainer = styled.div`\r\n  width: 60px;\r\n  height: 60px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  position: relative;\r\n  margin: 8px 0;\r\n`;\r\n\r\nconst ShapeVisual = styled.div`\r\n  width: 50px;\r\n  height: 50px;\r\n  background: ${props => props.$shapeColor};\r\n  border: 3px solid ${props => props.$borderColor};\r\n  position: relative;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  \r\n  /* Shape-specific styling */\r\n  border-radius: ${props => {\r\n    if (props.$shapeType === 'Circle') return '50%';\r\n    if (props.$shapeType === 'Diamond') return '0';\r\n    return '0';\r\n  }};\r\n  \r\n  transform: ${props => {\r\n    if (props.$shapeType === 'Diamond') return 'rotate(45deg)';\r\n    return 'none';\r\n  }};\r\n  \r\n  /* Triangle shape using CSS */\r\n  ${props => props.$shapeType === 'Triangle' && `\r\n    width: 0;\r\n    height: 0;\r\n    background: transparent;\r\n    border: none;\r\n    border-left: 25px solid transparent;\r\n    border-right: 25px solid transparent;\r\n    border-bottom: 43px solid ${props.$shapeColor};\r\n    position: relative;\r\n  `}\r\n`;\r\n\r\nconst CountBadge = styled.span`\r\n  background: ${props => props.$hasIncorrect ? '#ff4757' : '#4CAF50'};\r\n  color: white;\r\n  border-radius: 50%;\r\n  width: 20px;\r\n  height: 20px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  font-size: 10px;\r\n  font-weight: bold;\r\n  position: absolute;\r\n  top: -5px;\r\n  right: -5px;\r\n  z-index: 10;\r\n`;\r\n\r\nconst ButtonTitle = styled.span`\r\n  font-size: 12px;\r\n  font-weight: 600;\r\n  color: white;\r\n  text-align: center;\r\n  margin-top: 4px;\r\n`;\r\n\r\nconst ButtonSubtitle = styled.div`\r\n  font-size: 10px;\r\n  color: rgba(255, 255, 255, 0.8);\r\n  text-align: center;\r\n  margin-top: 2px;\r\n  line-height: 1.2;\r\n`;\r\n\r\nconst Instructions = styled.p`\r\n  color: rgba(255, 255, 255, 0.8);\r\n  font-size: 13px;\r\n  text-align: center;\r\n  margin: 0 0 15px 0;\r\n  line-height: 1.4;\r\n`;\r\n\r\nconst StatusMessage = styled.div`\r\n  padding: 10px;\r\n  border-radius: 8px;\r\n  text-align: center;\r\n  font-size: 12px;\r\n  font-weight: 600;\r\n  background: ${props => {\r\n    if (props.$type === 'success') return 'rgba(76, 175, 80, 0.2)';\r\n    if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.2)';\r\n    if (props.$type === 'error') return 'rgba(244, 67, 54, 0.2)';\r\n    return 'rgba(33, 150, 243, 0.2)';\r\n  }};\r\n  color: ${props => {\r\n    if (props.$type === 'success') return '#4CAF50';\r\n    if (props.$type === 'warning') return '#FFC107';\r\n    if (props.$type === 'error') return '#f44336';\r\n    return '#2196F3';\r\n  }};\r\n  border: 1px solid ${props => {\r\n    if (props.$type === 'success') return 'rgba(76, 175, 80, 0.3)';\r\n    if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.3)';\r\n    if (props.$type === 'error') return 'rgba(244, 67, 54, 0.3)';\r\n    return 'rgba(33, 150, 243, 0.3)';\r\n  }};\r\n`;\r\n\r\n// Custom logging function\r\nconst logToTerminal = (message, data = null) => {\r\n  console.log(`\\nðŸŽ¯ ${message}`);\r\n  if (data) {\r\n    console.log(JSON.stringify(data, null, 2));\r\n  }\r\n  console.log('='.repeat(80) + '\\n');\r\n  \r\n  // Try to send to log server, but don't fail if it's not available\r\n  const sendToLogServer = async () => {\r\n    try {\r\n      const response = await fetch('http://localhost:3001/log', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          message: message,\r\n          data: data\r\n        }),\r\n        // Add timeout to prevent hanging\r\n        signal: AbortSignal.timeout(1000)\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      console.log('âœ… Log sent to terminal successfully');\r\n    } catch (error) {\r\n      // Silently fail - logging server is optional\r\n      console.log('ðŸ’¡ Log server not available - logging to console only');\r\n    }\r\n  };\r\n  \r\n  // Execute without blocking\r\n  sendToLogServer();\r\n};\r\n\r\nfunction IdentifyIncorrectShapes({ isScrambling, cubeState, onIdentification, setCubeState }) {\r\n  const [activeIdentification, setActiveIdentification] = useState(null);\r\n  const [identificationResults, setIdentificationResults] = useState({});\r\n\r\n  if (!cubeState) {\r\n    console.log('ðŸš¨ SHOWING LOADING MESSAGE - no cubeState');\r\n    return (\r\n      <IdentifyContainer>\r\n        <SectionTitle>Identify Incorrect Shapes</SectionTitle>\r\n        <StatusMessage $type=\"warning\">\r\n          Loading cube state... Please scramble the cube first to identify incorrect shapes.\r\n        </StatusMessage>\r\n      </IdentifyContainer>\r\n    );\r\n  }\r\n\r\n  // Helper functions\r\n  const getShapeType = (pieceId) => {\r\n    const shapeTypes = [\r\n      'Square', 'Square', 'Square', 'Square', 'Square',\r\n      'Circle', 'Circle', 'Circle', 'Circle', 'Circle',\r\n      'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Diamond',\r\n      'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Diamond',\r\n      'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle'\r\n    ];\r\n    return shapeTypes[pieceId] || 'Unknown';\r\n  };\r\n\r\n  const getShapeColor = (pieceId) => {\r\n    const shapeColors = [\r\n      'Red', 'Blue', 'Green', 'Orange', 'Purple',\r\n      'Red', 'Blue', 'Green', 'Orange', 'Yellow',\r\n      'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple',\r\n      'Red', 'Blue', 'Green', 'Orange', 'Purple',\r\n      'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple', 'Yellow'\r\n    ];\r\n    return shapeColors[pieceId] || 'Unknown';\r\n  };\r\n\r\n  const getExpectedPosition = (pieceId) => {\r\n    const positions = [];\r\n    for (let x = -1; x <= 1; x++) {\r\n      for (let y = -1; y <= 1; y++) {\r\n        for (let z = -1; z <= 1; z++) {\r\n          if (x === 0 && y === 0 && z === 0) continue;\r\n          positions.push([x, y, z]);\r\n        }\r\n      }\r\n    }\r\n    return positions[pieceId];\r\n  };\r\n\r\n  const isPieceInCorrectPosition = (piece, pieceId) => {\r\n    if (!piece || !piece.position) return false;\r\n    const expectedPosition = getExpectedPosition(pieceId);\r\n    return JSON.stringify(piece.position) === JSON.stringify(expectedPosition);\r\n  };\r\n\r\n  const getExpectedBorderColor = (faceIndex) => {\r\n    const borderColors = [\r\n      '#FFFFFF', // Face 0 (front) - White\r\n      '#FF8C00', // Face 1 (back) - Orange  \r\n      '#00FF00', // Face 2 (right) - Green\r\n      '#DC143C', // Face 3 (left) - Red\r\n      '#0000FF', // Face 4 (top) - Blue\r\n      '#FFD700'  // Face 5 (bottom) - Yellow\r\n    ];\r\n    return borderColors[faceIndex] || '#000000';\r\n  };\r\n\r\n  const getBorderColorName = (faceIndex) => {\r\n    const colorNames = ['White', 'Orange', 'Green', 'Red', 'Blue', 'Yellow'];\r\n    return colorNames[faceIndex] || 'Unknown';\r\n  };\r\n\r\n  const getShapeColorHex = (shapeColor) => {\r\n    const colorMap = {\r\n      'Red': '#DC143C',\r\n      'Blue': '#0000FF',\r\n      'Green': '#00FF00',\r\n      'Orange': '#FF8C00',\r\n      'Purple': '#800080',\r\n      'Yellow': '#FFD700',\r\n      'Cyan': '#00FFFF',\r\n      'Magenta': '#FF00FF',\r\n      'Lime': '#00FF00',\r\n      'Pink': '#FFC0CB'\r\n    };\r\n    return colorMap[shapeColor] || '#000000';\r\n  };\r\n\r\n  // Get pieces data\r\n  const getPieces = () => {\r\n    if (Array.isArray(cubeState)) {\r\n      return cubeState.map((piece, index) => ({\r\n        pieceId: index,\r\n        position: piece.position,\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory || []\r\n      }));\r\n    } else if (cubeState?.pieces) {\r\n      return cubeState.pieces;\r\n    }\r\n    return [];\r\n  };\r\n\r\n  const pieces = getPieces();\r\n\r\n  // Identify incorrect shapes by type\r\n  const identifyIncorrectShapesByType = (shapeType) => {\r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const actualShapeType = getShapeType(pieceId);\r\n      return actualShapeType === shapeType && !isPieceInCorrectPosition(piece, pieceId);\r\n    });\r\n\r\n    const result = {\r\n      type: 'shape',\r\n      shapeType,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`shape-${shapeType}`]: result\r\n    }));\r\n\r\n    logToTerminal(`ðŸ” IDENTIFIED INCORRECT ${shapeType.toUpperCase()} SHAPES`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  // Identify incorrect shapes by color\r\n  const identifyIncorrectShapesByColor = (shapeColor) => {\r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const actualShapeColor = getShapeColor(pieceId);\r\n      return actualShapeColor === shapeColor && !isPieceInCorrectPosition(piece, pieceId);\r\n    });\r\n\r\n    const result = {\r\n      type: 'color',\r\n      shapeColor,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`color-${shapeColor}`]: result\r\n    }));\r\n\r\n    logToTerminal(`ðŸŽ¨ IDENTIFIED INCORRECT ${shapeColor.toUpperCase()} SHAPES`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  // Identify incorrect border colors\r\n  const identifyIncorrectBorderColors = (faceIndex) => {\r\n    const borderColorName = getBorderColorName(faceIndex);\r\n    const borderColorHex = getExpectedBorderColor(faceIndex);\r\n    \r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\r\n      \r\n      // Check if this piece should have this border color in its current position\r\n      const [x, y, z] = piece.position;\r\n      let shouldHaveBorderColor = false;\r\n      \r\n      switch (faceIndex) {\r\n        case 0: // Front face (Z+) - White\r\n          shouldHaveBorderColor = z === 1;\r\n          break;\r\n        case 1: // Back face (Z-) - Orange\r\n          shouldHaveBorderColor = z === -1;\r\n          break;\r\n        case 2: // Right face (X+) - Green\r\n          shouldHaveBorderColor = x === 1;\r\n          break;\r\n        case 3: // Left face (X-) - Red\r\n          shouldHaveBorderColor = x === -1;\r\n          break;\r\n        case 4: // Top face (Y+) - Blue\r\n          shouldHaveBorderColor = y === 1;\r\n          break;\r\n        case 5: // Bottom face (Y-) - Yellow\r\n          shouldHaveBorderColor = y === -1;\r\n          break;\r\n      }\r\n      \r\n      // Piece is incorrect if it should have this border color but is not in correct position\r\n      return shouldHaveBorderColor && !isInCorrectPosition;\r\n    });\r\n\r\n    const result = {\r\n      type: 'border',\r\n      faceIndex,\r\n      borderColorName,\r\n      borderColorHex,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`border-${faceIndex}`]: result\r\n    }));\r\n\r\n    logToTerminal(`ðŸŽ­ IDENTIFIED INCORRECT ${borderColorName.toUpperCase()} BORDER COLORS`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  // Identify pieces with black faces that should be visible\r\n  const identifyPiecesWithBlackFaces = () => {\r\n    logToTerminal('ðŸ” ========== STARTING BLACK FACES IDENTIFICATION ==========');\r\n    logToTerminal('ðŸ” cubeState type:', typeof cubeState);\r\n    logToTerminal('ðŸ” cubeState length:', cubeState ? cubeState.length : 'null');\r\n    logToTerminal('ðŸ” cubeState is null:', cubeState === null);\r\n    logToTerminal('ðŸ” cubeState is undefined:', cubeState === undefined);\r\n    \r\n    if (!cubeState || cubeState.length === 0) {\r\n      logToTerminal('ðŸ” âŒ No cube state available for identification');\r\n      return {\r\n        type: 'blackFaces',\r\n        incorrectPieces: [],\r\n        count: 0,\r\n        totalBlackFaces: 0\r\n      };\r\n    }\r\n\r\n    logToTerminal('ðŸ” âœ… Cube state available, checking', cubeState.length, 'pieces...');\r\n    \r\n    const incorrectPieces = [];\r\n    let totalBlackFaces = 0;\r\n    let piecesChecked = 0;\r\n    let piecesWithColors = 0;\r\n    let piecesWithPosition = 0;\r\n\r\n    // Log detailed structure of first few pieces\r\n    logToTerminal('ðŸ” ========== PIECE STRUCTURE ANALYSIS ==========');\r\n    cubeState.slice(0, 5).forEach((piece, index) => {\r\n      logToTerminal(`ðŸ” Piece ${index}:`, {\r\n        pieceId: piece.pieceId,\r\n        hasPosition: Array.isArray(piece.position),\r\n        position: piece.position,\r\n        hasColors: typeof piece.colors === 'object' && piece.colors !== null,\r\n        colors: piece.colors,\r\n        allKeys: Object.keys(piece)\r\n      });\r\n    });\r\n\r\n    logToTerminal('ðŸ” ========== CHECKING ALL PIECES ==========');\r\n    \r\n    cubeState.forEach((piece, index) => {\r\n      piecesChecked++;\r\n      const pieceId = piece.pieceId || index;\r\n      \r\n      // Check if piece has position\r\n      if (!Array.isArray(piece.position)) {\r\n        logToTerminal(`ðŸ” âŒ Piece ${pieceId} has invalid position:`, piece.position);\r\n        return;\r\n      }\r\n      piecesWithPosition++;\r\n      \r\n      // Check if piece has colors\r\n      if (!piece.colors || typeof piece.colors !== 'object') {\r\n        logToTerminal(`ðŸ” âŒ Piece ${pieceId} has invalid colors:`, piece.colors);\r\n        return;\r\n      }\r\n      piecesWithColors++;\r\n      \r\n      const [x, y, z] = piece.position;\r\n      \r\n      logToTerminal(`ðŸ” Checking piece ${pieceId} at position [${x}, ${y}, ${z}]`);\r\n      logToTerminal(`ðŸ” Piece colors object:`, piece.colors);\r\n      logToTerminal(`ðŸ” Color keys:`, Object.keys(piece.colors));\r\n      \r\n      // Determine which faces should be visible based on current position\r\n      const visibleFaces = [];\r\n      if (x === 1) visibleFaces.push('right');\r\n      if (x === -1) visibleFaces.push('left');\r\n      if (y === 1) visibleFaces.push('top');\r\n      if (y === -1) visibleFaces.push('bottom');\r\n      if (z === 1) visibleFaces.push('front');\r\n      if (z === -1) visibleFaces.push('back');\r\n      \r\n      logToTerminal(`ðŸ” Visible faces for piece ${pieceId}:`, visibleFaces);\r\n      \r\n      // Check if any visible faces are black/gray\r\n      const blackVisibleFaces = [];\r\n      visibleFaces.forEach(face => {\r\n        const faceColor = piece.colors[face];\r\n        logToTerminal(`ðŸ” Face ${face} color: \"${faceColor}\" (type: ${typeof faceColor})`);\r\n        \r\n        // Check for both #444444 and 'black' values\r\n        if (faceColor === '#444444' || faceColor === 'black' || faceColor === '#000000') {\r\n          blackVisibleFaces.push(face);\r\n          totalBlackFaces++;\r\n          logToTerminal(`ðŸ” âœ… FOUND BLACK/GRAY FACE: ${face} on piece ${pieceId} with color \"${faceColor}\"`);\r\n        } else {\r\n          logToTerminal(`ðŸ” Face ${face} is not black/gray (color: \"${faceColor}\")`);\r\n        }\r\n      });\r\n      \r\n      if (blackVisibleFaces.length > 0) {\r\n        incorrectPieces.push({\r\n          pieceId: pieceId,\r\n          currentPosition: piece.position,\r\n          blackVisibleFaces: blackVisibleFaces\r\n        });\r\n        logToTerminal(`ðŸ” âœ… Added piece ${pieceId} to incorrect pieces with ${blackVisibleFaces.length} black faces:`, blackVisibleFaces);\r\n      } else {\r\n        logToTerminal(`ðŸ” Piece ${pieceId} has no black visible faces`);\r\n      }\r\n    });\r\n\r\n    logToTerminal('ðŸ” ========== IDENTIFICATION SUMMARY ==========');\r\n    logToTerminal('ðŸ” Total pieces checked:', piecesChecked);\r\n    logToTerminal('ðŸ” Pieces with valid position:', piecesWithPosition);\r\n    logToTerminal('ðŸ” Pieces with valid colors:', piecesWithColors);\r\n    logToTerminal('ðŸ” Pieces with black faces:', incorrectPieces.length);\r\n    logToTerminal('ðŸ” Total black faces found:', totalBlackFaces);\r\n    logToTerminal('ðŸ” Incorrect pieces details:', incorrectPieces);\r\n\r\n    const result = {\r\n      type: 'blackFaces',\r\n      incorrectPieces: incorrectPieces,\r\n      count: incorrectPieces.length,\r\n      totalBlackFaces: totalBlackFaces\r\n    };\r\n    \r\n    logToTerminal('ðŸ” ========== RETURNING RESULT ==========');\r\n    logToTerminal('ðŸ” Result:', result);\r\n    \r\n    setIdentificationResults(prev => {\r\n      const newResults = {\r\n        ...prev,\r\n        'blackFaces': result\r\n      };\r\n      logToTerminal('ðŸ”§ UPDATING identificationResults:', newResults);\r\n      return newResults;\r\n    });\r\n\r\n    return result;\r\n  };\r\n\r\n  const handleButtonClick = (type, identifier) => {\r\n    if (isScrambling) return;\r\n\r\n    setActiveIdentification(`${type}-${identifier}`);\r\n\r\n    let result;\r\n    switch (type) {\r\n      case 'shape':\r\n        result = identifyIncorrectShapesByType(identifier);\r\n        break;\r\n      case 'color':\r\n        result = identifyIncorrectShapesByColor(identifier);\r\n        break;\r\n      case 'border':\r\n        result = identifyIncorrectBorderColors(identifier);\r\n        break;\r\n      case 'blackFaces':\r\n        result = identifyPiecesWithBlackFaces();\r\n        break;\r\n    }\r\n\r\n    // Reset active state after a short delay\r\n    setTimeout(() => {\r\n      setActiveIdentification(null);\r\n    }, 2000);\r\n  };\r\n\r\n  const handleFindAndFixGrayFaces = () => {\r\n    logToTerminal('ðŸ”§ FIND AND FIX GRAY FACES BUTTON CLICKED!');\r\n    logToTerminal('ðŸ”§ isScrambling:', isScrambling);\r\n    \r\n    if (isScrambling) {\r\n      logToTerminal('ðŸ”§ Button disabled - cube is scrambling');\r\n      return;\r\n    }\r\n\r\n    // First identify the pieces with black faces\r\n    const blackFacesResult = identifyPiecesWithBlackFaces();\r\n    \r\n    if (blackFacesResult.count === 0) {\r\n      logToTerminal('No gray faces to fix');\r\n      return;\r\n    }\r\n\r\n    logToTerminal('ðŸ”§ FOUND AND FIXING GRAY FACES:', blackFacesResult.incorrectPieces.length, 'pieces');\r\n    logToTerminal('ðŸ”§ Pieces to fix:', blackFacesResult.incorrectPieces.map(p => `${p.pieceId} at [${p.currentPosition.join(', ')}]`));\r\n\r\n    // Update the cube state to fix the colors\r\n    setCubeState(prevState => {\r\n      logToTerminal('ðŸ”§ setCubeState called with prevState length:', prevState.length);\r\n      const newState = [...prevState];\r\n      \r\n      blackFacesResult.incorrectPieces.forEach(incorrectPiece => {\r\n        logToTerminal(`ðŸ”§ Processing piece ${incorrectPiece.pieceId}...`);\r\n        const pieceIndex = newState.findIndex(p => p.pieceId === incorrectPiece.pieceId);\r\n        logToTerminal(`ðŸ”§ Found piece at index ${pieceIndex}`);\r\n        \r\n        if (pieceIndex !== -1) {\r\n          const piece = newState[pieceIndex];\r\n          const [x, y, z] = piece.position;\r\n          logToTerminal(`ðŸ”§ Piece ${piece.pieceId} at position [${x}, ${y}, ${z}]`);\r\n          logToTerminal(`ðŸ”§ Current colors:`, piece.colors);\r\n          \r\n          // Determine which faces should be visible based on current position\r\n          const visibleFaces = [];\r\n          if (x === 1) visibleFaces.push('right');\r\n          if (x === -1) visibleFaces.push('left');\r\n          if (y === 1) visibleFaces.push('top');\r\n          if (y === -1) visibleFaces.push('bottom');\r\n          if (z === 1) visibleFaces.push('front');\r\n          if (z === -1) visibleFaces.push('back');\r\n          \r\n          logToTerminal(`ðŸ”§ Visible faces:`, visibleFaces);\r\n          \r\n          // Fix the colors for visible faces that are currently black/gray\r\n          const updatedColors = { ...piece.colors };\r\n          let fixedAny = false;\r\n          \r\n          visibleFaces.forEach(face => {\r\n            logToTerminal(`ðŸ”§ Checking face ${face}: current color = ${updatedColors[face]}`);\r\n            if (updatedColors[face] === '#444444') {\r\n              // Set the correct color based on the face\r\n              switch (face) {\r\n                case 'front':\r\n                  updatedColors[face] = '#FFFFFF'; // White\r\n                  break;\r\n                case 'back':\r\n                  updatedColors[face] = '#FFD700'; // Yellow\r\n                  break;\r\n                case 'right':\r\n                  updatedColors[face] = '#DC143C'; // Red\r\n                  break;\r\n                case 'left':\r\n                  updatedColors[face] = '#FF8C00'; // Orange\r\n                  break;\r\n                case 'top':\r\n                  updatedColors[face] = '#0000FF'; // Blue\r\n                  break;\r\n                case 'bottom':\r\n                  updatedColors[face] = '#00FF00'; // Green\r\n                  break;\r\n              }\r\n              logToTerminal(`ðŸ”§ Fixed face ${face} to ${updatedColors[face]}`);\r\n              fixedAny = true;\r\n            }\r\n          });\r\n          \r\n          if (fixedAny) {\r\n            newState[pieceIndex] = {\r\n              ...piece,\r\n              colors: updatedColors\r\n            };\r\n            logToTerminal(`ðŸ”§ Updated piece ${piece.pieceId} with new colors:`, updatedColors);\r\n          } else {\r\n            logToTerminal(`ðŸ”§ No changes needed for piece ${piece.pieceId}`);\r\n          }\r\n        } else {\r\n          logToTerminal(`ðŸ”§ ERROR: Could not find piece ${incorrectPiece.pieceId} in cube state`);\r\n        }\r\n      });\r\n      \r\n      logToTerminal('âœ… Gray faces find and fix completed!');\r\n      logToTerminal('ðŸ”§ New state length:', newState.length);\r\n      return newState;\r\n    });\r\n\r\n    // Clear the identification results since we've fixed the issue\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      blackFaces: null\r\n    }));\r\n\r\n    // Clear the highlighting by calling onIdentification with empty result\r\n    if (onIdentification) {\r\n      onIdentification({\r\n        type: 'blackFaces',\r\n        count: 0,\r\n        totalBlackFaces: 0,\r\n        incorrectPieces: []\r\n      });\r\n    }\r\n  };\r\n\r\n  const getButtonState = (type, identifier) => {\r\n    const key = `${type}-${identifier}`;\r\n    const result = identificationResults[key];\r\n    const isActive = activeIdentification === key;\r\n    \r\n    return {\r\n      isActive,\r\n      hasIncorrect: result && result.count > 0,\r\n      count: result ? result.count : 0\r\n    };\r\n  };\r\n\r\n  // Generate all possible combinations of shape+color+border\r\n  const generateCombinations = () => {\r\n    const shapeTypes = ['Square', 'Circle', 'Triangle', 'Diamond'];\r\n    const shapeColors = ['Red', 'Blue', 'Green', 'Orange', 'Purple', 'Yellow', 'Cyan', 'Magenta', 'Lime', 'Pink'];\r\n    const borderColors = [\r\n      { name: 'White', hex: '#FFFFFF', faceIndex: 0 },\r\n      { name: 'Orange', hex: '#FF8C00', faceIndex: 1 },\r\n      { name: 'Green', hex: '#00FF00', faceIndex: 2 },\r\n      { name: 'Red', hex: '#DC143C', faceIndex: 3 },\r\n      { name: 'Blue', hex: '#0000FF', faceIndex: 4 },\r\n      { name: 'Yellow', hex: '#FFD700', faceIndex: 5 }\r\n    ];\r\n\r\n    const combinations = [];\r\n    shapeTypes.forEach(shapeType => {\r\n      shapeColors.forEach(shapeColor => {\r\n        borderColors.forEach(borderColor => {\r\n          combinations.push({\r\n            id: `${shapeType}-${shapeColor}-${borderColor.name}`,\r\n            shapeType,\r\n            shapeColor,\r\n            borderColor: borderColor.name,\r\n            borderColorHex: borderColor.hex,\r\n            faceIndex: borderColor.faceIndex\r\n          });\r\n        });\r\n      });\r\n    });\r\n    return combinations;\r\n  };\r\n\r\n  // Identify incorrect pieces by combination\r\n  const identifyIncorrectCombination = (combination) => {\r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const actualShapeType = getShapeType(pieceId);\r\n      const actualShapeColor = getShapeColor(pieceId);\r\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\r\n      \r\n      // Check if this piece matches the combination\r\n      const matchesShape = actualShapeType === combination.shapeType;\r\n      const matchesColor = actualShapeColor === combination.shapeColor;\r\n      \r\n      // Check if this piece should have this border color in its current position\r\n      const [x, y, z] = piece.position;\r\n      let shouldHaveBorderColor = false;\r\n      \r\n      switch (combination.faceIndex) {\r\n        case 0: // Front face (Z+) - White\r\n          shouldHaveBorderColor = z === 1;\r\n          break;\r\n        case 1: // Back face (Z-) - Orange\r\n          shouldHaveBorderColor = z === -1;\r\n          break;\r\n        case 2: // Right face (X+) - Green\r\n          shouldHaveBorderColor = x === 1;\r\n          break;\r\n        case 3: // Left face (X-) - Red\r\n          shouldHaveBorderColor = x === -1;\r\n          break;\r\n        case 4: // Top face (Y+) - Blue\r\n          shouldHaveBorderColor = y === 1;\r\n          break;\r\n        case 5: // Bottom face (Y-) - Yellow\r\n          shouldHaveBorderColor = y === -1;\r\n          break;\r\n      }\r\n      \r\n      // Piece is incorrect if it matches the combination but is not in correct position\r\n      return matchesShape && matchesColor && shouldHaveBorderColor && !isInCorrectPosition;\r\n    });\r\n\r\n    const result = {\r\n      type: 'combination',\r\n      combination,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`combination-${combination.id}`]: result\r\n    }));\r\n\r\n    logToTerminal(`ðŸŽ¯ IDENTIFIED INCORRECT ${combination.shapeColor} ${combination.shapeType} with ${combination.borderColor} border`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  const handleCombinationClick = (combination) => {\r\n    if (isScrambling) return;\r\n\r\n    setActiveIdentification(`combination-${combination.id}`);\r\n    const result = identifyIncorrectCombination(combination);\r\n\r\n    // Reset active state after a short delay\r\n    setTimeout(() => {\r\n      setActiveIdentification(null);\r\n    }, 2000);\r\n  };\r\n\r\n  const getCombinationButtonState = (combination) => {\r\n    const key = `combination-${combination.id}`;\r\n    const result = identificationResults[key];\r\n    const isActive = activeIdentification === key;\r\n    \r\n    return {\r\n      isActive,\r\n      hasIncorrect: result && result.count > 0,\r\n      count: result ? result.count : 0\r\n    };\r\n  };\r\n\r\n  const combinations = generateCombinations();\r\n\r\n  return (\r\n    <IdentifyContainer>\r\n      <SectionTitle>Identify Incorrect Shapes</SectionTitle>\r\n      <Instructions>\r\n        Click any button below to identify pieces with that specific combination of shape+color+border that are in incorrect positions.\r\n        Buttons show the count of incorrect pieces found for each combination.\r\n      </Instructions>\r\n\r\n      {/* Black Faces Identification */}\r\n      <div>\r\n        <h4 style={{ color: 'white', marginBottom: '10px', fontSize: '16px' }}>Special Issues</h4>\r\n        <ButtonGrid style={{ gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', marginBottom: '20px' }}>\r\n          <IdentifyButton\r\n            onClick={() => handleButtonClick('blackFaces', 'all')}\r\n            disabled={isScrambling}\r\n            $isActive={activeIdentification === 'blackFaces-all'}\r\n            $hasIncorrect={identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0}\r\n            style={{\r\n              background: 'rgba(255, 0, 0, 0.2)',\r\n              borderColor: '#ff0000',\r\n              borderWidth: '3px',\r\n              display: 'none' // Hide the button but keep functionality\r\n            }}\r\n          >\r\n            <ButtonContent>\r\n              <div style={{ fontSize: '24px', marginBottom: '8px' }}>âš«</div>\r\n              <ButtonTitle style={{ color: '#ff0000', fontWeight: 'bold' }}>\r\n                Dark Gray Faces\r\n              </ButtonTitle>\r\n              <ButtonSubtitle>\r\n                Find pieces with dark gray faces (highlighted in pink)\r\n              </ButtonSubtitle>\r\n              {identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0 && (\r\n                <CountBadge $hasIncorrect={true}>\r\n                  {identificationResults['blackFaces'].count} pieces\r\n                  <br />\r\n                  {identificationResults['blackFaces'].totalBlackFaces} faces\r\n                </CountBadge>\r\n              )}\r\n            </ButtonContent>\r\n          </IdentifyButton>\r\n          \r\n          {/* Find and Fix Gray Faces Button */}\r\n          <IdentifyButton\r\n            onClick={() => {\r\n              logToTerminal('ðŸ”§ BUTTON CLICKED - onClick handler triggered');\r\n              logToTerminal('ðŸ”§ isScrambling:', isScrambling);\r\n              handleFindAndFixGrayFaces();\r\n            }}\r\n            disabled={isScrambling}\r\n            $isActive={false}\r\n            $hasIncorrect={false}\r\n            style={{\r\n              borderColor: '#FF6B6B',\r\n              borderWidth: '3px',\r\n              background: 'rgba(255, 107, 107, 0.2)'\r\n            }}\r\n          >\r\n            <ButtonContent>\r\n              <div style={{ fontSize: '24px', marginBottom: '8px' }}>ðŸ”§</div>\r\n              <ButtonTitle style={{ color: '#FF6B6B', fontWeight: 'bold' }}>\r\n                Find & Fix Gray Faces\r\n              </ButtonTitle>\r\n              <ButtonSubtitle>\r\n                Identify and automatically correct dark gray faces to proper colors\r\n              </ButtonSubtitle>\r\n            </ButtonContent>\r\n          </IdentifyButton>\r\n        </ButtonGrid>\r\n      </div>\r\n\r\n      {/* Combination Identification */}\r\n      <div>\r\n        <h4 style={{ color: 'white', marginBottom: '15px', fontSize: '16px' }}>By Shape + Color + Border Combinations</h4>\r\n        <ButtonGrid style={{ gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))' }}>\r\n          {combinations.map(combination => {\r\n            const state = getCombinationButtonState(combination);\r\n            \r\n            return (\r\n              <IdentifyButton\r\n                key={`combination-${combination.id}`}\r\n                onClick={() => handleCombinationClick(combination)}\r\n                disabled={isScrambling}\r\n                $isActive={state.isActive}\r\n                $hasIncorrect={state.hasIncorrect}\r\n                style={{\r\n                  borderColor: state.hasIncorrect ? '#ff4757' : combination.borderColorHex,\r\n                  borderWidth: '3px'\r\n                }}\r\n              >\r\n                <ButtonContent>\r\n                  <ShapeContainer>\r\n                    {combination.shapeType === 'Triangle' ? (\r\n                      <svg width=\"50\" height=\"50\" viewBox=\"0 0 50 50\">\r\n                        <polygon \r\n                          points=\"25,5 45,40 5,40\" \r\n                          fill={getShapeColorHex(combination.shapeColor)}\r\n                          stroke={combination.borderColorHex}\r\n                          strokeWidth=\"3\"\r\n                        />\r\n                      </svg>\r\n                    ) : (\r\n                      <ShapeVisual\r\n                        $shapeType={combination.shapeType}\r\n                        $shapeColor={getShapeColorHex(combination.shapeColor)}\r\n                        $borderColor={combination.borderColorHex}\r\n                      />\r\n                    )}\r\n                    {state.count > 0 && (\r\n                      <CountBadge $hasIncorrect={state.hasIncorrect}>\r\n                        {state.count}\r\n                      </CountBadge>\r\n                    )}\r\n                  </ShapeContainer>\r\n                  <ButtonTitle>\r\n                    {combination.shapeColor} {combination.shapeType}\r\n                  </ButtonTitle>\r\n                </ButtonContent>\r\n              </IdentifyButton>\r\n            );\r\n          })}\r\n        </ButtonGrid>\r\n      </div>\r\n\r\n      {/* Status Message */}\r\n      {activeIdentification && (\r\n        <StatusMessage $type=\"success\">\r\n          Combination identification complete! Check the terminal for detailed results.\r\n        </StatusMessage>\r\n      )}\r\n    </IdentifyContainer>\r\n  );\r\n}\r\n\r\nexport default IdentifyIncorrectShapes;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}