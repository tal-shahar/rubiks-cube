{"ast":null,"code":"import React,{useRef,useMemo,useState}from'react';import{Canvas,useFrame}from'@react-three/fiber';import{OrbitControls,Environment}from'@react-three/drei';import*as THREE from'three';// Individual cube piece component with improved materials\nimport{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";function CubePiece(_ref){let{position,colors,size=0.95}=_ref;const meshRef=useRef();const colorMap={'white':'#ffffff','yellow':'#ffff00','red':'#ff0000','orange':'#ff8c00','blue':'#0000ff','green':'#00ff00','black':'#1a1a1a'};// Create individual face meshes for each side\nconst faceSize=size*0.5;const faceGeometry=useMemo(()=>new THREE.PlaneGeometry(faceSize,faceSize),[faceSize]);return/*#__PURE__*/_jsxs(\"group\",{ref:meshRef,position:position,children:[/*#__PURE__*/_jsxs(\"mesh\",{position:[0,0,size*0.5],rotation:[0,0,0],children:[/*#__PURE__*/_jsx(\"primitive\",{object:faceGeometry}),/*#__PURE__*/_jsx(\"meshPhongMaterial\",{color:colorMap[colors[0]]||colorMap['black'],side:THREE.DoubleSide})]}),/*#__PURE__*/_jsxs(\"mesh\",{position:[0,0,-size*0.5],rotation:[0,Math.PI,0],children:[/*#__PURE__*/_jsx(\"primitive\",{object:faceGeometry}),/*#__PURE__*/_jsx(\"meshPhongMaterial\",{color:colorMap[colors[1]]||colorMap['black'],side:THREE.DoubleSide})]}),/*#__PURE__*/_jsxs(\"mesh\",{position:[size*0.5,0,0],rotation:[0,Math.PI/2,0],children:[/*#__PURE__*/_jsx(\"primitive\",{object:faceGeometry}),/*#__PURE__*/_jsx(\"meshPhongMaterial\",{color:colorMap[colors[2]]||colorMap['black'],side:THREE.DoubleSide})]}),/*#__PURE__*/_jsxs(\"mesh\",{position:[-size*0.5,0,0],rotation:[0,-Math.PI/2,0],children:[/*#__PURE__*/_jsx(\"primitive\",{object:faceGeometry}),/*#__PURE__*/_jsx(\"meshPhongMaterial\",{color:colorMap[colors[3]]||colorMap['black'],side:THREE.DoubleSide})]}),/*#__PURE__*/_jsxs(\"mesh\",{position:[0,size*0.5,0],rotation:[-Math.PI/2,0,0],children:[/*#__PURE__*/_jsx(\"primitive\",{object:faceGeometry}),/*#__PURE__*/_jsx(\"meshPhongMaterial\",{color:colorMap[colors[4]]||colorMap['black'],side:THREE.DoubleSide})]}),/*#__PURE__*/_jsxs(\"mesh\",{position:[0,-size*0.5,0],rotation:[Math.PI/2,0,0],children:[/*#__PURE__*/_jsx(\"primitive\",{object:faceGeometry}),/*#__PURE__*/_jsx(\"meshPhongMaterial\",{color:colorMap[colors[5]]||colorMap['black'],side:THREE.DoubleSide})]})]});}// Main cube group component with enhanced structure\nfunction CubeGroup(_ref2){let{isRotating,autoRotate=false}=_ref2;const groupRef=useRef();const[rotationSpeed]=useState({x:0.005,y:0.01});useFrame(state=>{if(autoRotate&&groupRef.current){groupRef.current.rotation.y+=rotationSpeed.y;groupRef.current.rotation.x+=rotationSpeed.x;}});// Generate complete 3x3x3 cube structure\nconst cubePieces=useMemo(()=>{const pieces=[];// Create all 27 pieces (3x3x3)\nfor(let x=-1;x<=1;x++){for(let y=-1;y<=1;y++){for(let z=-1;z<=1;z++){const position=[x*1.1,y*1.1,z*1.1];// Determine colors for each face based on position\nconst pieceColors=['black','black','black','black','black','black'];// Apply colors to ALL faces of each piece based on their position\n// This ensures every face of every cube piece has its proper color\n// Front face (z = 1) - white\nif(z===1)pieceColors[0]='white';// Back face (z = -1) - yellow  \nif(z===-1)pieceColors[1]='yellow';// Right face (x = 1) - red\nif(x===1)pieceColors[2]='red';// Left face (x = -1) - orange\nif(x===-1)pieceColors[3]='orange';// Top face (y = 1) - blue\nif(y===1)pieceColors[4]='blue';// Bottom face (y = -1) - green\nif(y===-1)pieceColors[5]='green';// For inner pieces, assign colors based on their position in the grid\n// This ensures all faces have proper colors, not just black\nif(x===0&&y===0&&z===0){// Center piece - assign colors based on adjacent faces\npieceColors[0]='white';// front\npieceColors[1]='yellow';// back\npieceColors[2]='red';// right\npieceColors[3]='orange';// left\npieceColors[4]='blue';// top\npieceColors[5]='green';// bottom\n}else if(x===0&&y===0){// Edge pieces (center of edges)\nif(z===1)pieceColors[0]='white';if(z===-1)pieceColors[1]='yellow';pieceColors[2]='red';pieceColors[3]='orange';pieceColors[4]='blue';pieceColors[5]='green';}else if(x===0&&z===0){// Edge pieces (center of edges)\npieceColors[0]='white';pieceColors[1]='yellow';pieceColors[2]='red';pieceColors[3]='orange';if(y===1)pieceColors[4]='blue';if(y===-1)pieceColors[5]='green';}else if(y===0&&z===0){// Edge pieces (center of edges)\npieceColors[0]='white';pieceColors[1]='yellow';if(x===1)pieceColors[2]='red';if(x===-1)pieceColors[3]='orange';pieceColors[4]='blue';pieceColors[5]='green';}pieces.push({position,colors:pieceColors});}}}return pieces;},[]);return/*#__PURE__*/_jsx(\"group\",{ref:groupRef,children:cubePieces.map((piece,index)=>/*#__PURE__*/_jsx(CubePiece,{position:piece.position,colors:piece.colors},index))});}// Main Rubik's Cube component\nfunction RubiksCube(_ref3){let{isRotating,autoRotate=false}=_ref3;return/*#__PURE__*/_jsxs(Canvas,{camera:{position:[6,6,6],fov:60},style:{width:'100%',height:'100%'},gl:{antialias:true,alpha:true},children:[/*#__PURE__*/_jsx(\"ambientLight\",{intensity:0.3}),/*#__PURE__*/_jsx(\"directionalLight\",{position:[10,10,5],intensity:1.2,castShadow:true,\"shadow-mapSize-width\":2048,\"shadow-mapSize-height\":2048}),/*#__PURE__*/_jsx(\"pointLight\",{position:[-10,-10,-5],intensity:0.8}),/*#__PURE__*/_jsx(\"spotLight\",{position:[0,10,0],angle:0.3,penumbra:1,intensity:0.5,castShadow:true}),/*#__PURE__*/_jsx(Environment,{preset:\"city\"}),/*#__PURE__*/_jsx(CubeGroup,{isRotating:isRotating,autoRotate:autoRotate}),/*#__PURE__*/_jsx(OrbitControls,{enablePan:true,enableZoom:true,enableRotate:true,autoRotate:false,autoRotateSpeed:1,minDistance:3,maxDistance:15,dampingFactor:0.05,enableDamping:true})]});}export default RubiksCube;","map":{"version":3,"names":["React","useRef","useMemo","useState","Canvas","useFrame","OrbitControls","Environment","THREE","jsx","_jsx","jsxs","_jsxs","CubePiece","_ref","position","colors","size","meshRef","colorMap","faceSize","faceGeometry","PlaneGeometry","ref","children","rotation","object","color","side","DoubleSide","Math","PI","CubeGroup","_ref2","isRotating","autoRotate","groupRef","rotationSpeed","x","y","state","current","cubePieces","pieces","z","pieceColors","push","map","piece","index","RubiksCube","_ref3","camera","fov","style","width","height","gl","antialias","alpha","intensity","castShadow","angle","penumbra","preset","enablePan","enableZoom","enableRotate","autoRotateSpeed","minDistance","maxDistance","dampingFactor","enableDamping"],"sources":["C:/Repo/GitHub/rubiks-cube/src/components/RubiksCube.js"],"sourcesContent":["import React, { useRef, useMemo, useState } from 'react';\r\nimport { Canvas, useFrame } from '@react-three/fiber';\r\nimport { OrbitControls, Environment } from '@react-three/drei';\r\nimport * as THREE from 'three';\r\n\r\n// Individual cube piece component with improved materials\r\nfunction CubePiece({ position, colors, size = 0.95 }) {\r\n  const meshRef = useRef();\r\n  \r\n  const colorMap = {\r\n    'white': '#ffffff',\r\n    'yellow': '#ffff00',\r\n    'red': '#ff0000',\r\n    'orange': '#ff8c00',\r\n    'blue': '#0000ff',\r\n    'green': '#00ff00',\r\n    'black': '#1a1a1a'\r\n  };\r\n\r\n  // Create individual face meshes for each side\r\n  const faceSize = size * 0.5;\r\n  const faceGeometry = useMemo(() => new THREE.PlaneGeometry(faceSize, faceSize), [faceSize]);\r\n\r\n  return (\r\n    <group ref={meshRef} position={position}>\r\n             {/* Front face (z = 1) */}\r\n       <mesh position={[0, 0, size * 0.5]} rotation={[0, 0, 0]}>\r\n         <primitive object={faceGeometry} />\r\n         <meshPhongMaterial \r\n           color={colorMap[colors[0]] || colorMap['black']}\r\n           side={THREE.DoubleSide}\r\n         />\r\n       </mesh>\r\n       \r\n       {/* Back face (z = -1) */}\r\n       <mesh position={[0, 0, -size * 0.5]} rotation={[0, Math.PI, 0]}>\r\n         <primitive object={faceGeometry} />\r\n         <meshPhongMaterial \r\n           color={colorMap[colors[1]] || colorMap['black']}\r\n           side={THREE.DoubleSide}\r\n         />\r\n       </mesh>\r\n       \r\n       {/* Right face (x = 1) */}\r\n       <mesh position={[size * 0.5, 0, 0]} rotation={[0, Math.PI / 2, 0]}>\r\n         <primitive object={faceGeometry} />\r\n         <meshPhongMaterial \r\n           color={colorMap[colors[2]] || colorMap['black']}\r\n           side={THREE.DoubleSide}\r\n         />\r\n       </mesh>\r\n       \r\n       {/* Left face (x = -1) */}\r\n       <mesh position={[-size * 0.5, 0, 0]} rotation={[0, -Math.PI / 2, 0]}>\r\n         <primitive object={faceGeometry} />\r\n         <meshPhongMaterial \r\n           color={colorMap[colors[3]] || colorMap['black']}\r\n           side={THREE.DoubleSide}\r\n         />\r\n       </mesh>\r\n       \r\n       {/* Top face (y = 1) */}\r\n       <mesh position={[0, size * 0.5, 0]} rotation={[-Math.PI / 2, 0, 0]}>\r\n         <primitive object={faceGeometry} />\r\n         <meshPhongMaterial \r\n           color={colorMap[colors[4]] || colorMap['black']}\r\n           side={THREE.DoubleSide}\r\n         />\r\n       </mesh>\r\n       \r\n       {/* Bottom face (y = -1) */}\r\n       <mesh position={[0, -size * 0.5, 0]} rotation={[Math.PI / 2, 0, 0]}>\r\n         <primitive object={faceGeometry} />\r\n         <meshPhongMaterial \r\n           color={colorMap[colors[5]] || colorMap['black']}\r\n           side={THREE.DoubleSide}\r\n         />\r\n       </mesh>\r\n    </group>\r\n  );\r\n}\r\n\r\n// Main cube group component with enhanced structure\r\nfunction CubeGroup({ isRotating, autoRotate = false }) {\r\n  const groupRef = useRef();\r\n  const [rotationSpeed] = useState({ x: 0.005, y: 0.01 });\r\n  \r\n  useFrame((state) => {\r\n    if (autoRotate && groupRef.current) {\r\n      groupRef.current.rotation.y += rotationSpeed.y;\r\n      groupRef.current.rotation.x += rotationSpeed.x;\r\n    }\r\n  });\r\n\r\n  // Generate complete 3x3x3 cube structure\r\n  const cubePieces = useMemo(() => {\r\n    const pieces = [];\r\n    \r\n    // Create all 27 pieces (3x3x3)\r\n    for (let x = -1; x <= 1; x++) {\r\n      for (let y = -1; y <= 1; y++) {\r\n        for (let z = -1; z <= 1; z++) {\r\n          const position = [x * 1.1, y * 1.1, z * 1.1];\r\n          \r\n                     // Determine colors for each face based on position\r\n           const pieceColors = ['black', 'black', 'black', 'black', 'black', 'black'];\r\n           \r\n           // Apply colors to ALL faces of each piece based on their position\r\n           // This ensures every face of every cube piece has its proper color\r\n           \r\n           // Front face (z = 1) - white\r\n           if (z === 1) pieceColors[0] = 'white';\r\n           // Back face (z = -1) - yellow  \r\n           if (z === -1) pieceColors[1] = 'yellow';\r\n           // Right face (x = 1) - red\r\n           if (x === 1) pieceColors[2] = 'red';\r\n           // Left face (x = -1) - orange\r\n           if (x === -1) pieceColors[3] = 'orange';\r\n           // Top face (y = 1) - blue\r\n           if (y === 1) pieceColors[4] = 'blue';\r\n           // Bottom face (y = -1) - green\r\n           if (y === -1) pieceColors[5] = 'green';\r\n           \r\n           // For inner pieces, assign colors based on their position in the grid\r\n           // This ensures all faces have proper colors, not just black\r\n           if (x === 0 && y === 0 && z === 0) {\r\n             // Center piece - assign colors based on adjacent faces\r\n             pieceColors[0] = 'white';  // front\r\n             pieceColors[1] = 'yellow'; // back\r\n             pieceColors[2] = 'red';    // right\r\n             pieceColors[3] = 'orange'; // left\r\n             pieceColors[4] = 'blue';   // top\r\n             pieceColors[5] = 'green';  // bottom\r\n           } else if (x === 0 && y === 0) {\r\n             // Edge pieces (center of edges)\r\n             if (z === 1) pieceColors[0] = 'white';\r\n             if (z === -1) pieceColors[1] = 'yellow';\r\n             pieceColors[2] = 'red';\r\n             pieceColors[3] = 'orange';\r\n             pieceColors[4] = 'blue';\r\n             pieceColors[5] = 'green';\r\n           } else if (x === 0 && z === 0) {\r\n             // Edge pieces (center of edges)\r\n             pieceColors[0] = 'white';\r\n             pieceColors[1] = 'yellow';\r\n             pieceColors[2] = 'red';\r\n             pieceColors[3] = 'orange';\r\n             if (y === 1) pieceColors[4] = 'blue';\r\n             if (y === -1) pieceColors[5] = 'green';\r\n           } else if (y === 0 && z === 0) {\r\n             // Edge pieces (center of edges)\r\n             pieceColors[0] = 'white';\r\n             pieceColors[1] = 'yellow';\r\n             if (x === 1) pieceColors[2] = 'red';\r\n             if (x === -1) pieceColors[3] = 'orange';\r\n             pieceColors[4] = 'blue';\r\n             pieceColors[5] = 'green';\r\n           }\r\n          \r\n          pieces.push({\r\n            position,\r\n            colors: pieceColors\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return pieces;\r\n  }, []);\r\n\r\n  return (\r\n    <group ref={groupRef}>\r\n      {cubePieces.map((piece, index) => (\r\n        <CubePiece\r\n          key={index}\r\n          position={piece.position}\r\n          colors={piece.colors}\r\n        />\r\n      ))}\r\n    </group>\r\n  );\r\n}\r\n\r\n// Main Rubik's Cube component\r\nfunction RubiksCube({ isRotating, autoRotate = false }) {\r\n  return (\r\n    <Canvas\r\n      camera={{ position: [6, 6, 6], fov: 60 }}\r\n      style={{ width: '100%', height: '100%' }}\r\n      gl={{ antialias: true, alpha: true }}\r\n    >\r\n      {/* Enhanced Lighting */}\r\n      <ambientLight intensity={0.3} />\r\n      <directionalLight \r\n        position={[10, 10, 5]} \r\n        intensity={1.2}\r\n        castShadow\r\n        shadow-mapSize-width={2048}\r\n        shadow-mapSize-height={2048}\r\n      />\r\n      <pointLight position={[-10, -10, -5]} intensity={0.8} />\r\n      <spotLight\r\n        position={[0, 10, 0]}\r\n        angle={0.3}\r\n        penumbra={1}\r\n        intensity={0.5}\r\n        castShadow\r\n      />\r\n      \r\n      {/* Environment */}\r\n      <Environment preset=\"city\" />\r\n      \r\n      {/* Cube */}\r\n      <CubeGroup isRotating={isRotating} autoRotate={autoRotate} />\r\n      \r\n      {/* Controls */}\r\n      <OrbitControls \r\n        enablePan={true}\r\n        enableZoom={true}\r\n        enableRotate={true}\r\n        autoRotate={false}\r\n        autoRotateSpeed={1}\r\n        minDistance={3}\r\n        maxDistance={15}\r\n        dampingFactor={0.05}\r\n        enableDamping={true}\r\n      />\r\n    </Canvas>\r\n  );\r\n}\r\n\r\nexport default RubiksCube; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}