{"ast":null,"code":"var _jsxFileName = \"C:\\\\Repo\\\\GitHub\\\\rubiks-cube\\\\src\\\\components\\\\RubiksCube.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport React, { useRef, useMemo, useState, useCallback } from 'react';\nimport { Canvas, useFrame } from '@react-three/fiber';\nimport { OrbitControls, Environment } from '@react-three/drei';\nimport * as THREE from 'three';\n\n// Individual cube piece component with proper multi-colored faces\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction CubePiece({\n  position,\n  colors,\n  size = 0.95\n}) {\n  _s();\n  const meshRef = useRef();\n  const colorMap = {\n    'white': '#ffffff',\n    'yellow': '#ffff00',\n    'red': '#ff0000',\n    'orange': '#ff6600',\n    'blue': '#0066ff',\n    'green': '#00ff00',\n    'black': '#1a1a1a'\n  };\n\n  // Create individual face geometries for each side\n  const faceSize = size / 2;\n  const faceGeometry = useMemo(() => new THREE.PlaneGeometry(size, size), [size]);\n\n  // Face positions and rotations for a cube\n  // Each face has a fixed color that doesn't change when the piece moves\n  const faces = [{\n    position: [0, 0, size / 2],\n    rotation: [0, 0, 0],\n    color: colors[0]\n  },\n  // Front\n  {\n    position: [0, 0, -size / 2],\n    rotation: [0, Math.PI, 0],\n    color: colors[1]\n  },\n  // Back\n  {\n    position: [size / 2, 0, 0],\n    rotation: [0, Math.PI / 2, 0],\n    color: colors[2]\n  },\n  // Right\n  {\n    position: [-size / 2, 0, 0],\n    rotation: [0, -Math.PI / 2, 0],\n    color: colors[3]\n  },\n  // Left\n  {\n    position: [0, size / 2, 0],\n    rotation: [-Math.PI / 2, 0, 0],\n    color: colors[4]\n  },\n  // Top\n  {\n    position: [0, -size / 2, 0],\n    rotation: [Math.PI / 2, 0, 0],\n    color: colors[5]\n  } // Bottom\n  ];\n  return /*#__PURE__*/_jsxDEV(\"group\", {\n    ref: meshRef,\n    position: position,\n    children: faces.map((face, index) => /*#__PURE__*/_jsxDEV(\"mesh\", {\n      position: face.position,\n      rotation: face.rotation,\n      children: [/*#__PURE__*/_jsxDEV(\"primitive\", {\n        object: faceGeometry\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 39,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"meshPhongMaterial\", {\n        color: colorMap[face.color] || colorMap['black'],\n        side: THREE.DoubleSide,\n        shininess: 30,\n        specular: 0x444444\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 40,\n        columnNumber: 11\n      }, this)]\n    }, index, true, {\n      fileName: _jsxFileName,\n      lineNumber: 38,\n      columnNumber: 9\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 36,\n    columnNumber: 5\n  }, this);\n}\n\n// Cube state management and rotation logic\n_s(CubePiece, \"1V7NXo1rSueTkDom11McK+eg0xc=\");\n_c = CubePiece;\nfunction useCubeState() {\n  _s2();\n  const [cubeState, setCubeState] = useState(() => {\n    // Initialize solved cube state\n    const state = [];\n    for (let x = -1; x <= 1; x++) {\n      for (let y = -1; y <= 1; y++) {\n        for (let z = -1; z <= 1; z++) {\n          const position = [x, y, z];\n          const colors = ['black', 'black', 'black', 'black', 'black', 'black'];\n\n          // Assign colors based on position - these colors stay fixed to the piece\n          if (z === 1) colors[0] = 'white'; // Front\n          if (z === -1) colors[1] = 'yellow'; // Back\n          if (x === 1) colors[2] = 'red'; // Right\n          if (x === -1) colors[3] = 'orange'; // Left\n          if (y === 1) colors[4] = 'blue'; // Top\n          if (y === -1) colors[5] = 'green'; // Bottom\n\n          state.push({\n            position: [...position],\n            colors: [...colors]\n          });\n        }\n      }\n    }\n    return state;\n  });\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [animationQueue, setAnimationQueue] = useState([]);\n\n  // Rotation functions for each face\n  const rotateFace = useCallback((face, direction) => {\n    if (isAnimating) return;\n    setIsAnimating(true);\n    const newState = [...cubeState];\n\n    // Define which pieces belong to each face\n    const facePieces = {\n      'F': newState.filter(p => p.position[2] === 1),\n      // Front face\n      'B': newState.filter(p => p.position[2] === -1),\n      // Back face\n      'R': newState.filter(p => p.position[0] === 1),\n      // Right face\n      'L': newState.filter(p => p.position[0] === -1),\n      // Left face\n      'U': newState.filter(p => p.position[1] === 1),\n      // Up face\n      'D': newState.filter(p => p.position[1] === -1) // Down face\n    };\n    const pieces = facePieces[face];\n    if (!pieces) return;\n\n    // Apply rotation based on face and direction\n    pieces.forEach(piece => {\n      const [x, y, z] = piece.position;\n      let newX = x,\n        newY = y,\n        newZ = z;\n      switch (face) {\n        case 'F':\n          // Front face rotation\n          if (direction === 'clockwise') {\n            newX = -y;\n            newY = x;\n          } else {\n            newX = y;\n            newY = -x;\n          }\n          break;\n        case 'B':\n          // Back face rotation\n          if (direction === 'clockwise') {\n            newX = y;\n            newY = -x;\n          } else {\n            newX = -y;\n            newY = x;\n          }\n          break;\n        case 'R':\n          // Right face rotation\n          if (direction === 'clockwise') {\n            newZ = -y;\n            newY = z;\n          } else {\n            newZ = y;\n            newY = -z;\n          }\n          break;\n        case 'L':\n          // Left face rotation\n          if (direction === 'clockwise') {\n            newZ = y;\n            newY = -z;\n          } else {\n            newZ = -y;\n            newY = z;\n          }\n          break;\n        case 'U':\n          // Up face rotation\n          if (direction === 'clockwise') {\n            newX = z;\n            newZ = -x;\n          } else {\n            newX = -z;\n            newZ = x;\n          }\n          break;\n        case 'D':\n          // Down face rotation\n          if (direction === 'clockwise') {\n            newX = -z;\n            newZ = x;\n          } else {\n            newX = z;\n            newZ = -x;\n          }\n          break;\n      }\n      piece.position = [newX, newY, newZ];\n      // Colors stay the same - they are tied to the piece, not the position\n    });\n    setCubeState(newState);\n\n    // Animation delay\n    setTimeout(() => setIsAnimating(false), 300);\n  }, [cubeState, isAnimating]);\n\n  // Scramble function using standard notation\n  const scramble = useCallback(() => {\n    if (isAnimating) return;\n    const moves = ['F', 'B', 'R', 'L', 'U', 'D'];\n    const directions = ['clockwise', 'counterclockwise'];\n    const scrambleLength = 20;\n    let currentQueue = [];\n    let lastMove = '';\n    for (let i = 0; i < scrambleLength; i++) {\n      let move;\n      let direction;\n\n      // Avoid doing the same move twice in a row\n      do {\n        move = moves[Math.floor(Math.random() * moves.length)];\n      } while (move === lastMove);\n      direction = directions[Math.floor(Math.random() * directions.length)];\n      lastMove = move;\n      currentQueue.push({\n        move,\n        direction\n      });\n    }\n    setAnimationQueue(currentQueue);\n    executeScramble(currentQueue);\n  }, [isAnimating]);\n  const executeScramble = useCallback(queue => {\n    if (queue.length === 0) return;\n    const {\n      move,\n      direction\n    } = queue[0];\n    rotateFace(move, direction);\n    setTimeout(() => {\n      executeScramble(queue.slice(1));\n    }, 350);\n  }, [rotateFace]);\n\n  // Reset function\n  const reset = useCallback(() => {\n    if (isAnimating) return;\n    setCubeState(() => {\n      const state = [];\n      for (let x = -1; x <= 1; x++) {\n        for (let y = -1; y <= 1; y++) {\n          for (let z = -1; z <= 1; z++) {\n            const position = [x, y, z];\n            const colors = ['black', 'black', 'black', 'black', 'black', 'black'];\n            if (z === 1) colors[0] = 'white';\n            if (z === -1) colors[1] = 'yellow';\n            if (x === 1) colors[2] = 'red';\n            if (x === -1) colors[3] = 'orange';\n            if (y === 1) colors[4] = 'blue';\n            if (y === -1) colors[5] = 'green';\n            state.push({\n              position: [...position],\n              colors: [...colors]\n            });\n          }\n        }\n      }\n      return state;\n    });\n  }, [isAnimating]);\n  return {\n    cubeState,\n    isAnimating,\n    rotateFace,\n    scramble,\n    reset\n  };\n}\n\n// Main cube group component with enhanced structure\n_s2(useCubeState, \"OoC+Xiw8lZrzWWYbQOi9dyECF0Y=\");\nfunction CubeGroup({\n  isRotating,\n  autoRotate = false,\n  onScramble,\n  onReset\n}) {\n  _s3();\n  const groupRef = useRef();\n  const [rotationSpeed] = useState({\n    x: 0.005,\n    y: 0.01\n  });\n  const {\n    cubeState,\n    isAnimating,\n    rotateFace,\n    scramble,\n    reset\n  } = useCubeState();\n\n  // Expose functions to parent\n  React.useEffect(() => {\n    if (onScramble) onScramble(scramble);\n    if (onReset) onReset(reset);\n  }, [onScramble, onReset, scramble, reset]);\n  useFrame(state => {\n    if (autoRotate && groupRef.current && !isAnimating) {\n      groupRef.current.rotation.y += rotationSpeed.y;\n      groupRef.current.rotation.x += rotationSpeed.x;\n    }\n  });\n  return /*#__PURE__*/_jsxDEV(\"group\", {\n    ref: groupRef,\n    children: cubeState.map((piece, index) => /*#__PURE__*/_jsxDEV(CubePiece, {\n      position: piece.position,\n      colors: piece.colors\n    }, index, false, {\n      fileName: _jsxFileName,\n      lineNumber: 273,\n      columnNumber: 9\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 271,\n    columnNumber: 5\n  }, this);\n}\n\n// Main Rubik's Cube component\n_s3(CubeGroup, \"4ehKp0Jd2vChjTIyWIyZQmjvX+4=\", false, function () {\n  return [useCubeState, useFrame];\n});\n_c2 = CubeGroup;\nfunction RubiksCube({\n  isRotating,\n  autoRotate = false,\n  onScramble,\n  onReset\n}) {\n  return /*#__PURE__*/_jsxDEV(Canvas, {\n    camera: {\n      position: [6, 6, 6],\n      fov: 60\n    },\n    style: {\n      width: '100%',\n      height: '100%'\n    },\n    gl: {\n      antialias: true,\n      alpha: true\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"ambientLight\", {\n      intensity: 0.6\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 292,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"directionalLight\", {\n      position: [10, 10, 5],\n      intensity: 1.5,\n      castShadow: true,\n      \"shadow-mapSize-width\": 2048,\n      \"shadow-mapSize-height\": 2048\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 293,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"pointLight\", {\n      position: [-10, -10, -5],\n      intensity: 1.0\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 300,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"spotLight\", {\n      position: [0, 10, 0],\n      angle: 0.3,\n      penumbra: 1,\n      intensity: 0.8,\n      castShadow: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 301,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Environment, {\n      preset: \"city\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 310,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(CubeGroup, {\n      isRotating: isRotating,\n      autoRotate: autoRotate,\n      onScramble: onScramble,\n      onReset: onReset\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 313,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(OrbitControls, {\n      enablePan: true,\n      enableZoom: true,\n      enableRotate: true,\n      autoRotate: false,\n      autoRotateSpeed: 1,\n      minDistance: 3,\n      maxDistance: 15,\n      dampingFactor: 0.05,\n      enableDamping: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 321,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 286,\n    columnNumber: 5\n  }, this);\n}\n_c3 = RubiksCube;\nexport default RubiksCube;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"CubePiece\");\n$RefreshReg$(_c2, \"CubeGroup\");\n$RefreshReg$(_c3, \"RubiksCube\");","map":{"version":3,"names":["React","useRef","useMemo","useState","useCallback","Canvas","useFrame","OrbitControls","Environment","THREE","jsxDEV","_jsxDEV","CubePiece","position","colors","size","_s","meshRef","colorMap","faceSize","faceGeometry","PlaneGeometry","faces","rotation","color","Math","PI","ref","children","map","face","index","object","fileName","_jsxFileName","lineNumber","columnNumber","side","DoubleSide","shininess","specular","_c","useCubeState","_s2","cubeState","setCubeState","state","x","y","z","push","isAnimating","setIsAnimating","animationQueue","setAnimationQueue","rotateFace","direction","newState","facePieces","filter","p","pieces","forEach","piece","newX","newY","newZ","setTimeout","scramble","moves","directions","scrambleLength","currentQueue","lastMove","i","move","floor","random","length","executeScramble","queue","slice","reset","CubeGroup","isRotating","autoRotate","onScramble","onReset","_s3","groupRef","rotationSpeed","useEffect","current","_c2","RubiksCube","camera","fov","style","width","height","gl","antialias","alpha","intensity","castShadow","angle","penumbra","preset","enablePan","enableZoom","enableRotate","autoRotateSpeed","minDistance","maxDistance","dampingFactor","enableDamping","_c3","$RefreshReg$"],"sources":["C:/Repo/GitHub/rubiks-cube/src/components/RubiksCube.js"],"sourcesContent":["import React, { useRef, useMemo, useState, useCallback } from 'react';\r\nimport { Canvas, useFrame } from '@react-three/fiber';\r\nimport { OrbitControls, Environment } from '@react-three/drei';\r\nimport * as THREE from 'three';\r\n\r\n// Individual cube piece component with proper multi-colored faces\r\nfunction CubePiece({ position, colors, size = 0.95 }) {\r\n  const meshRef = useRef();\r\n  \r\n  const colorMap = {\r\n    'white': '#ffffff',\r\n    'yellow': '#ffff00',\r\n    'red': '#ff0000',\r\n    'orange': '#ff6600',\r\n    'blue': '#0066ff',\r\n    'green': '#00ff00',\r\n    'black': '#1a1a1a'\r\n  };\r\n\r\n  // Create individual face geometries for each side\r\n  const faceSize = size / 2;\r\n  const faceGeometry = useMemo(() => new THREE.PlaneGeometry(size, size), [size]);\r\n\r\n  // Face positions and rotations for a cube\r\n  // Each face has a fixed color that doesn't change when the piece moves\r\n  const faces = [\r\n    { position: [0, 0, size/2], rotation: [0, 0, 0], color: colors[0] }, // Front\r\n    { position: [0, 0, -size/2], rotation: [0, Math.PI, 0], color: colors[1] }, // Back\r\n    { position: [size/2, 0, 0], rotation: [0, Math.PI/2, 0], color: colors[2] }, // Right\r\n    { position: [-size/2, 0, 0], rotation: [0, -Math.PI/2, 0], color: colors[3] }, // Left\r\n    { position: [0, size/2, 0], rotation: [-Math.PI/2, 0, 0], color: colors[4] }, // Top\r\n    { position: [0, -size/2, 0], rotation: [Math.PI/2, 0, 0], color: colors[5] }  // Bottom\r\n  ];\r\n\r\n  return (\r\n    <group ref={meshRef} position={position}>\r\n      {faces.map((face, index) => (\r\n        <mesh key={index} position={face.position} rotation={face.rotation}>\r\n          <primitive object={faceGeometry} />\r\n          <meshPhongMaterial \r\n            color={colorMap[face.color] || colorMap['black']}\r\n            side={THREE.DoubleSide}\r\n            shininess={30}\r\n            specular={0x444444}\r\n          />\r\n        </mesh>\r\n      ))}\r\n    </group>\r\n  );\r\n}\r\n\r\n// Cube state management and rotation logic\r\nfunction useCubeState() {\r\n  const [cubeState, setCubeState] = useState(() => {\r\n    // Initialize solved cube state\r\n    const state = [];\r\n    for (let x = -1; x <= 1; x++) {\r\n      for (let y = -1; y <= 1; y++) {\r\n        for (let z = -1; z <= 1; z++) {\r\n          const position = [x, y, z];\r\n          const colors = ['black', 'black', 'black', 'black', 'black', 'black'];\r\n          \r\n          // Assign colors based on position - these colors stay fixed to the piece\r\n          if (z === 1) colors[0] = 'white'; // Front\r\n          if (z === -1) colors[1] = 'yellow'; // Back\r\n          if (x === 1) colors[2] = 'red'; // Right\r\n          if (x === -1) colors[3] = 'orange'; // Left\r\n          if (y === 1) colors[4] = 'blue'; // Top\r\n          if (y === -1) colors[5] = 'green'; // Bottom\r\n          \r\n          state.push({ position: [...position], colors: [...colors] });\r\n        }\r\n      }\r\n    }\r\n    return state;\r\n  });\r\n\r\n  const [isAnimating, setIsAnimating] = useState(false);\r\n  const [animationQueue, setAnimationQueue] = useState([]);\r\n\r\n  // Rotation functions for each face\r\n  const rotateFace = useCallback((face, direction) => {\r\n    if (isAnimating) return;\r\n    \r\n    setIsAnimating(true);\r\n    const newState = [...cubeState];\r\n    \r\n    // Define which pieces belong to each face\r\n    const facePieces = {\r\n      'F': newState.filter(p => p.position[2] === 1), // Front face\r\n      'B': newState.filter(p => p.position[2] === -1), // Back face\r\n      'R': newState.filter(p => p.position[0] === 1), // Right face\r\n      'L': newState.filter(p => p.position[0] === -1), // Left face\r\n      'U': newState.filter(p => p.position[1] === 1), // Up face\r\n      'D': newState.filter(p => p.position[1] === -1) // Down face\r\n    };\r\n\r\n    const pieces = facePieces[face];\r\n    if (!pieces) return;\r\n\r\n    // Apply rotation based on face and direction\r\n    pieces.forEach(piece => {\r\n      const [x, y, z] = piece.position;\r\n      let newX = x, newY = y, newZ = z;\r\n      \r\n      switch (face) {\r\n        case 'F': // Front face rotation\r\n          if (direction === 'clockwise') {\r\n            newX = -y;\r\n            newY = x;\r\n          } else {\r\n            newX = y;\r\n            newY = -x;\r\n          }\r\n          break;\r\n        case 'B': // Back face rotation\r\n          if (direction === 'clockwise') {\r\n            newX = y;\r\n            newY = -x;\r\n          } else {\r\n            newX = -y;\r\n            newY = x;\r\n          }\r\n          break;\r\n        case 'R': // Right face rotation\r\n          if (direction === 'clockwise') {\r\n            newZ = -y;\r\n            newY = z;\r\n          } else {\r\n            newZ = y;\r\n            newY = -z;\r\n          }\r\n          break;\r\n        case 'L': // Left face rotation\r\n          if (direction === 'clockwise') {\r\n            newZ = y;\r\n            newY = -z;\r\n          } else {\r\n            newZ = -y;\r\n            newY = z;\r\n          }\r\n          break;\r\n        case 'U': // Up face rotation\r\n          if (direction === 'clockwise') {\r\n            newX = z;\r\n            newZ = -x;\r\n          } else {\r\n            newX = -z;\r\n            newZ = x;\r\n          }\r\n          break;\r\n        case 'D': // Down face rotation\r\n          if (direction === 'clockwise') {\r\n            newX = -z;\r\n            newZ = x;\r\n          } else {\r\n            newX = z;\r\n            newZ = -x;\r\n          }\r\n          break;\r\n      }\r\n      \r\n      piece.position = [newX, newY, newZ];\r\n      // Colors stay the same - they are tied to the piece, not the position\r\n    });\r\n\r\n    setCubeState(newState);\r\n    \r\n    // Animation delay\r\n    setTimeout(() => setIsAnimating(false), 300);\r\n  }, [cubeState, isAnimating]);\r\n\r\n  // Scramble function using standard notation\r\n  const scramble = useCallback(() => {\r\n    if (isAnimating) return;\r\n    \r\n    const moves = ['F', 'B', 'R', 'L', 'U', 'D'];\r\n    const directions = ['clockwise', 'counterclockwise'];\r\n    const scrambleLength = 20;\r\n    \r\n    let currentQueue = [];\r\n    let lastMove = '';\r\n    \r\n    for (let i = 0; i < scrambleLength; i++) {\r\n      let move;\r\n      let direction;\r\n      \r\n      // Avoid doing the same move twice in a row\r\n      do {\r\n        move = moves[Math.floor(Math.random() * moves.length)];\r\n      } while (move === lastMove);\r\n      \r\n      direction = directions[Math.floor(Math.random() * directions.length)];\r\n      lastMove = move;\r\n      \r\n      currentQueue.push({ move, direction });\r\n    }\r\n    \r\n    setAnimationQueue(currentQueue);\r\n    executeScramble(currentQueue);\r\n  }, [isAnimating]);\r\n\r\n  const executeScramble = useCallback((queue) => {\r\n    if (queue.length === 0) return;\r\n    \r\n    const { move, direction } = queue[0];\r\n    rotateFace(move, direction);\r\n    \r\n    setTimeout(() => {\r\n      executeScramble(queue.slice(1));\r\n    }, 350);\r\n  }, [rotateFace]);\r\n\r\n  // Reset function\r\n  const reset = useCallback(() => {\r\n    if (isAnimating) return;\r\n    \r\n    setCubeState(() => {\r\n      const state = [];\r\n      for (let x = -1; x <= 1; x++) {\r\n        for (let y = -1; y <= 1; y++) {\r\n          for (let z = -1; z <= 1; z++) {\r\n            const position = [x, y, z];\r\n            const colors = ['black', 'black', 'black', 'black', 'black', 'black'];\r\n            \r\n            if (z === 1) colors[0] = 'white';\r\n            if (z === -1) colors[1] = 'yellow';\r\n            if (x === 1) colors[2] = 'red';\r\n            if (x === -1) colors[3] = 'orange';\r\n            if (y === 1) colors[4] = 'blue';\r\n            if (y === -1) colors[5] = 'green';\r\n            \r\n            state.push({ position: [...position], colors: [...colors] });\r\n          }\r\n        }\r\n      }\r\n      return state;\r\n    });\r\n  }, [isAnimating]);\r\n\r\n  return {\r\n    cubeState,\r\n    isAnimating,\r\n    rotateFace,\r\n    scramble,\r\n    reset\r\n  };\r\n}\r\n\r\n// Main cube group component with enhanced structure\r\nfunction CubeGroup({ isRotating, autoRotate = false, onScramble, onReset }) {\r\n  const groupRef = useRef();\r\n  const [rotationSpeed] = useState({ x: 0.005, y: 0.01 });\r\n  \r\n  const { cubeState, isAnimating, rotateFace, scramble, reset } = useCubeState();\r\n  \r\n  // Expose functions to parent\r\n  React.useEffect(() => {\r\n    if (onScramble) onScramble(scramble);\r\n    if (onReset) onReset(reset);\r\n  }, [onScramble, onReset, scramble, reset]);\r\n  \r\n  useFrame((state) => {\r\n    if (autoRotate && groupRef.current && !isAnimating) {\r\n      groupRef.current.rotation.y += rotationSpeed.y;\r\n      groupRef.current.rotation.x += rotationSpeed.x;\r\n    }\r\n  });\r\n\r\n  return (\r\n    <group ref={groupRef}>\r\n      {cubeState.map((piece, index) => (\r\n        <CubePiece\r\n          key={index}\r\n          position={piece.position}\r\n          colors={piece.colors}\r\n        />\r\n      ))}\r\n    </group>\r\n  );\r\n}\r\n\r\n// Main Rubik's Cube component\r\nfunction RubiksCube({ isRotating, autoRotate = false, onScramble, onReset }) {\r\n  return (\r\n    <Canvas\r\n      camera={{ position: [6, 6, 6], fov: 60 }}\r\n      style={{ width: '100%', height: '100%' }}\r\n      gl={{ antialias: true, alpha: true }}\r\n    >\r\n      {/* Enhanced Lighting */}\r\n      <ambientLight intensity={0.6} />\r\n      <directionalLight \r\n        position={[10, 10, 5]} \r\n        intensity={1.5}\r\n        castShadow\r\n        shadow-mapSize-width={2048}\r\n        shadow-mapSize-height={2048}\r\n      />\r\n      <pointLight position={[-10, -10, -5]} intensity={1.0} />\r\n      <spotLight\r\n        position={[0, 10, 0]}\r\n        angle={0.3}\r\n        penumbra={1}\r\n        intensity={0.8}\r\n        castShadow\r\n      />\r\n      \r\n      {/* Environment */}\r\n      <Environment preset=\"city\" />\r\n      \r\n      {/* Cube */}\r\n      <CubeGroup \r\n        isRotating={isRotating} \r\n        autoRotate={autoRotate}\r\n        onScramble={onScramble}\r\n        onReset={onReset}\r\n      />\r\n      \r\n      {/* Controls */}\r\n      <OrbitControls \r\n        enablePan={true}\r\n        enableZoom={true}\r\n        enableRotate={true}\r\n        autoRotate={false}\r\n        autoRotateSpeed={1}\r\n        minDistance={3}\r\n        maxDistance={15}\r\n        dampingFactor={0.05}\r\n        enableDamping={true}\r\n      />\r\n    </Canvas>\r\n  );\r\n}\r\n\r\nexport default RubiksCube; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}