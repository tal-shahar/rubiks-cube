{"ast":null,"code":"var _jsxFileName = \"C:\\\\Repo\\\\GitHub\\\\rubiks-cube\\\\src\\\\components\\\\IdentifyIncorrectShapes.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport styled from 'styled-components';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst IdentifyContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 20px;\n  padding: 20px;\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 15px;\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);\n  max-height: 500px;\n  overflow-y: auto;\n`;\n_c = IdentifyContainer;\nconst SectionTitle = styled.h3`\n  color: white;\n  text-align: center;\n  margin: 0 0 15px 0;\n  font-size: 1.3rem;\n  font-weight: 600;\n  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\n`;\n_c2 = SectionTitle;\nconst ButtonGrid = styled.div`\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  gap: 15px;\n  margin-bottom: 20px;\n`;\n_c3 = ButtonGrid;\nconst IdentifyButton = styled.button`\n  padding: 12px 16px;\n  border: 2px solid ${props => {\n  if (props.$isActive) return '#4CAF50';\n  if (props.$hasIncorrect) return '#ff4757';\n  return 'rgba(255, 255, 255, 0.3)';\n}};\n  border-radius: 10px;\n  font-size: 14px;\n  font-weight: 600;\n  cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};\n  transition: all 0.3s ease;\n  background: ${props => {\n  if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\n  if (props.$isActive) return 'rgba(76, 175, 80, 0.2)';\n  if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.2)';\n  return 'rgba(255, 255, 255, 0.1)';\n}};\n  color: ${props => {\n  if (props.disabled) return '#666';\n  if (props.$isActive) return '#4CAF50';\n  if (props.$hasIncorrect) return '#ff4757';\n  return 'white';\n}};\n  opacity: ${props => props.disabled ? 0.5 : 1};\n  \n  &:hover {\n    transform: ${props => props.disabled ? 'none' : 'translateY(-2px)'};\n    box-shadow: ${props => props.disabled ? 'none' : '0 4px 12px rgba(0, 0, 0, 0.3)'};\n    background: ${props => {\n  if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\n  if (props.$isActive) return 'rgba(76, 175, 80, 0.3)';\n  if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.3)';\n  return 'rgba(255, 255, 255, 0.2)';\n}};\n  }\n  \n  &:active {\n    transform: ${props => props.disabled ? 'none' : 'translateY(0)'};\n  }\n`;\n_c4 = IdentifyButton;\nconst ButtonContent = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 4px;\n  width: 100%;\n  height: 100%;\n  position: relative;\n`;\n_c5 = ButtonContent;\nconst ShapeContainer = styled.div`\n  width: 60px;\n  height: 60px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n  margin: 8px 0;\n`;\n_c6 = ShapeContainer;\nconst ShapeVisual = styled.div`\n  width: 50px;\n  height: 50px;\n  background: ${props => props.$shapeColor};\n  border: 3px solid ${props => props.$borderColor};\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  \n  /* Shape-specific styling */\n  border-radius: ${props => {\n  if (props.$shapeType === 'Circle') return '50%';\n  if (props.$shapeType === 'Diamond') return '0';\n  return '0';\n}};\n  \n  transform: ${props => {\n  if (props.$shapeType === 'Diamond') return 'rotate(45deg)';\n  return 'none';\n}};\n  \n  /* Triangle shape using CSS */\n  ${props => props.$shapeType === 'Triangle' && `\n    width: 0;\n    height: 0;\n    background: transparent;\n    border: none;\n    border-left: 25px solid transparent;\n    border-right: 25px solid transparent;\n    border-bottom: 43px solid ${props.$shapeColor};\n    position: relative;\n  `}\n`;\n_c7 = ShapeVisual;\nconst CountBadge = styled.span`\n  background: ${props => props.$hasIncorrect ? '#ff4757' : '#4CAF50'};\n  color: white;\n  border-radius: 50%;\n  width: 20px;\n  height: 20px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 10px;\n  font-weight: bold;\n  position: absolute;\n  top: -5px;\n  right: -5px;\n  z-index: 10;\n`;\n_c8 = CountBadge;\nconst ButtonTitle = styled.span`\n  font-size: 12px;\n  font-weight: 600;\n  color: white;\n  text-align: center;\n  margin-top: 4px;\n`;\n_c9 = ButtonTitle;\nconst ButtonSubtitle = styled.div`\n  font-size: 10px;\n  color: rgba(255, 255, 255, 0.8);\n  text-align: center;\n  margin-top: 2px;\n  line-height: 1.2;\n`;\n_c0 = ButtonSubtitle;\nconst Instructions = styled.p`\n  color: rgba(255, 255, 255, 0.8);\n  font-size: 13px;\n  text-align: center;\n  margin: 0 0 15px 0;\n  line-height: 1.4;\n`;\n_c1 = Instructions;\nconst StatusMessage = styled.div`\n  padding: 10px;\n  border-radius: 8px;\n  text-align: center;\n  font-size: 12px;\n  font-weight: 600;\n  background: ${props => {\n  if (props.$type === 'success') return 'rgba(76, 175, 80, 0.2)';\n  if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.2)';\n  if (props.$type === 'error') return 'rgba(244, 67, 54, 0.2)';\n  return 'rgba(33, 150, 243, 0.2)';\n}};\n  color: ${props => {\n  if (props.$type === 'success') return '#4CAF50';\n  if (props.$type === 'warning') return '#FFC107';\n  if (props.$type === 'error') return '#f44336';\n  return '#2196F3';\n}};\n  border: 1px solid ${props => {\n  if (props.$type === 'success') return 'rgba(76, 175, 80, 0.3)';\n  if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.3)';\n  if (props.$type === 'error') return 'rgba(244, 67, 54, 0.3)';\n  return 'rgba(33, 150, 243, 0.3)';\n}};\n`;\n\n// Custom logging function\n_c10 = StatusMessage;\nconst logToTerminal = (message, data = null) => {\n  console.log(`\\n🎯 ${message}`);\n  if (data) {\n    console.log(JSON.stringify(data, null, 2));\n  }\n  console.log('='.repeat(80) + '\\n');\n\n  // Try to send to log server, but don't fail if it's not available\n  const sendToLogServer = async () => {\n    try {\n      const response = await fetch('http://localhost:3001/log', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message: message,\n          data: data\n        }),\n        // Add timeout to prevent hanging\n        signal: AbortSignal.timeout(1000)\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      console.log('✅ Log sent to terminal successfully');\n    } catch (error) {\n      // Silently fail - logging server is optional\n      console.log('💡 Log server not available - logging to console only');\n    }\n  };\n\n  // Execute without blocking\n  sendToLogServer();\n};\nfunction IdentifyIncorrectShapes({\n  isScrambling,\n  cubeState,\n  onIdentification,\n  setCubeState\n}) {\n  _s();\n  const [activeIdentification, setActiveIdentification] = useState(null);\n  const [identificationResults, setIdentificationResults] = useState({});\n  if (!cubeState) {\n    console.log('🚨 SHOWING LOADING MESSAGE - no cubeState');\n    return /*#__PURE__*/_jsxDEV(IdentifyContainer, {\n      children: [/*#__PURE__*/_jsxDEV(SectionTitle, {\n        children: \"Identify Incorrect Shapes\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 244,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(StatusMessage, {\n        $type: \"warning\",\n        children: \"Loading cube state... Please scramble the cube first to identify incorrect shapes.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 245,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 243,\n      columnNumber: 7\n    }, this);\n  }\n\n  // Helper functions\n  const getShapeType = pieceId => {\n    const shapeTypes = ['Square', 'Square', 'Square', 'Square', 'Square', 'Circle', 'Circle', 'Circle', 'Circle', 'Circle', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle'];\n    return shapeTypes[pieceId] || 'Unknown';\n  };\n  const getShapeColor = pieceId => {\n    const shapeColors = ['Red', 'Blue', 'Green', 'Orange', 'Purple', 'Red', 'Blue', 'Green', 'Orange', 'Yellow', 'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple', 'Red', 'Blue', 'Green', 'Orange', 'Purple', 'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple', 'Yellow'];\n    return shapeColors[pieceId] || 'Unknown';\n  };\n  const getExpectedPosition = pieceId => {\n    const positions = [];\n    for (let x = -1; x <= 1; x++) {\n      for (let y = -1; y <= 1; y++) {\n        for (let z = -1; z <= 1; z++) {\n          if (x === 0 && y === 0 && z === 0) continue;\n          positions.push([x, y, z]);\n        }\n      }\n    }\n    return positions[pieceId];\n  };\n  const isPieceInCorrectPosition = (piece, pieceId) => {\n    if (!piece || !piece.position) return false;\n    const expectedPosition = getExpectedPosition(pieceId);\n    return JSON.stringify(piece.position) === JSON.stringify(expectedPosition);\n  };\n  const getExpectedBorderColor = faceIndex => {\n    const borderColors = ['#FFFFFF',\n    // Face 0 (front) - White\n    '#FF8C00',\n    // Face 1 (back) - Orange  \n    '#00FF00',\n    // Face 2 (right) - Green\n    '#DC143C',\n    // Face 3 (left) - Red\n    '#0000FF',\n    // Face 4 (top) - Blue\n    '#FFD700' // Face 5 (bottom) - Yellow\n    ];\n    return borderColors[faceIndex] || '#000000';\n  };\n  const getBorderColorName = faceIndex => {\n    const colorNames = ['White', 'Orange', 'Green', 'Red', 'Blue', 'Yellow'];\n    return colorNames[faceIndex] || 'Unknown';\n  };\n  const getShapeColorHex = shapeColor => {\n    const colorMap = {\n      'Red': '#DC143C',\n      'Blue': '#0000FF',\n      'Green': '#00FF00',\n      'Orange': '#FF8C00',\n      'Purple': '#800080',\n      'Yellow': '#FFD700',\n      'Cyan': '#00FFFF',\n      'Magenta': '#FF00FF',\n      'Lime': '#00FF00',\n      'Pink': '#FFC0CB'\n    };\n    return colorMap[shapeColor] || '#000000';\n  };\n\n  // Get pieces data\n  const getPieces = () => {\n    if (Array.isArray(cubeState)) {\n      return cubeState.map((piece, index) => ({\n        pieceId: index,\n        position: piece.position,\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory || []\n      }));\n    } else if (cubeState !== null && cubeState !== void 0 && cubeState.pieces) {\n      return cubeState.pieces;\n    }\n    return [];\n  };\n  const pieces = getPieces();\n\n  // Identify incorrect shapes by type\n  const identifyIncorrectShapesByType = shapeType => {\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const actualShapeType = getShapeType(pieceId);\n      return actualShapeType === shapeType && !isPieceInCorrectPosition(piece, pieceId);\n    });\n    const result = {\n      type: 'shape',\n      shapeType,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`shape-${shapeType}`]: result\n    }));\n    logToTerminal(`🔍 IDENTIFIED INCORRECT ${shapeType.toUpperCase()} SHAPES`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n\n  // Identify incorrect shapes by color\n  const identifyIncorrectShapesByColor = shapeColor => {\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const actualShapeColor = getShapeColor(pieceId);\n      return actualShapeColor === shapeColor && !isPieceInCorrectPosition(piece, pieceId);\n    });\n    const result = {\n      type: 'color',\n      shapeColor,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`color-${shapeColor}`]: result\n    }));\n    logToTerminal(`🎨 IDENTIFIED INCORRECT ${shapeColor.toUpperCase()} SHAPES`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n\n  // Identify incorrect border colors\n  const identifyIncorrectBorderColors = faceIndex => {\n    const borderColorName = getBorderColorName(faceIndex);\n    const borderColorHex = getExpectedBorderColor(faceIndex);\n    const incorrectPieces = pieces.filter(piece => {\n      const pieceId = piece.pieceId;\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\n\n      // Check if this piece should have this border color in its current position\n      const [x, y, z] = piece.position;\n      let shouldHaveBorderColor = false;\n      switch (faceIndex) {\n        case 0:\n          // Front face (Z+) - White\n          shouldHaveBorderColor = z === 1;\n          break;\n        case 1:\n          // Back face (Z-) - Orange\n          shouldHaveBorderColor = z === -1;\n          break;\n        case 2:\n          // Right face (X+) - Green\n          shouldHaveBorderColor = x === 1;\n          break;\n        case 3:\n          // Left face (X-) - Red\n          shouldHaveBorderColor = x === -1;\n          break;\n        case 4:\n          // Top face (Y+) - Blue\n          shouldHaveBorderColor = y === 1;\n          break;\n        case 5:\n          // Bottom face (Y-) - Yellow\n          shouldHaveBorderColor = y === -1;\n          break;\n      }\n\n      // Piece is incorrect if it should have this border color but is not in correct position\n      return shouldHaveBorderColor && !isInCorrectPosition;\n    });\n    const result = {\n      type: 'border',\n      faceIndex,\n      borderColorName,\n      borderColorHex,\n      incorrectPieces: incorrectPieces.map(piece => ({\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory\n      })),\n      count: incorrectPieces.length\n    };\n    setIdentificationResults(prev => ({\n      ...prev,\n      [`border-${faceIndex}`]: result\n    }));\n    logToTerminal(`🎭 IDENTIFIED INCORRECT ${borderColorName.toUpperCase()} BORDER COLORS`, result);\n    if (onIdentification) {\n      onIdentification(result);\n    }\n    return result;\n  };\n\n  // Identify pieces with black faces that should be visible\n  const identifyPiecesWithBlackFaces = () => {\n    logToTerminal('🔍 ========== STARTING BLACK FACES IDENTIFICATION ==========');\n    logToTerminal('🔍 cubeState type:', typeof cubeState);\n    logToTerminal('🔍 cubeState length:', cubeState ? cubeState.length : 'null');\n    logToTerminal('🔍 cubeState is null:', cubeState === null);\n    logToTerminal('🔍 cubeState is undefined:', cubeState === undefined);\n    if (!cubeState || cubeState.length === 0) {\n      logToTerminal('🔍 ❌ No cube state available for identification');\n      return {\n        type: 'blackFaces',\n        incorrectPieces: [],\n        count: 0,\n        totalBlackFaces: 0\n      };\n    }\n    logToTerminal('🔍 ✅ Cube state available, checking', cubeState.length, 'pieces...');\n    const incorrectPieces = [];\n    let totalBlackFaces = 0;\n    let piecesChecked = 0;\n    let piecesWithColors = 0;\n    let piecesWithPosition = 0;\n\n    // Log detailed structure of first few pieces\n    logToTerminal('🔍 ========== PIECE STRUCTURE ANALYSIS ==========');\n    cubeState.slice(0, 5).forEach((piece, index) => {\n      logToTerminal(`🔍 Piece ${index}:`, {\n        pieceId: piece.pieceId,\n        hasPosition: Array.isArray(piece.position),\n        position: piece.position,\n        hasColors: typeof piece.colors === 'object' && piece.colors !== null,\n        colors: piece.colors,\n        allKeys: Object.keys(piece)\n      });\n    });\n    logToTerminal('🔍 ========== CHECKING ALL PIECES ==========');\n    cubeState.forEach((piece, index) => {\n      piecesChecked++;\n      const pieceId = piece.pieceId || index;\n\n      // Check if piece has position\n      if (!Array.isArray(piece.position)) {\n        logToTerminal(`🔍 ❌ Piece ${pieceId} has invalid position:`, piece.position);\n        return;\n      }\n      piecesWithPosition++;\n\n      // Check if piece has colors\n      if (!piece.colors || typeof piece.colors !== 'object') {\n        logToTerminal(`🔍 ❌ Piece ${pieceId} has invalid colors:`, piece.colors);\n        return;\n      }\n      piecesWithColors++;\n      const [x, y, z] = piece.position;\n      logToTerminal(`🔍 Checking piece ${pieceId} at position [${x}, ${y}, ${z}]`);\n      logToTerminal(`🔍 Piece colors object:`, piece.colors);\n      logToTerminal(`🔍 Color keys:`, Object.keys(piece.colors));\n\n      // Determine which faces should be visible based on current position\n      const visibleFaces = [];\n      if (x === 1) visibleFaces.push('right');\n      if (x === -1) visibleFaces.push('left');\n      if (y === 1) visibleFaces.push('top');\n      if (y === -1) visibleFaces.push('bottom');\n      if (z === 1) visibleFaces.push('front');\n      if (z === -1) visibleFaces.push('back');\n      logToTerminal(`🔍 Visible faces for piece ${pieceId}:`, visibleFaces);\n\n      // Check if any visible faces are black/gray\n      const blackVisibleFaces = [];\n      visibleFaces.forEach(face => {\n        const faceColor = piece.colors[face];\n        logToTerminal(`🔍 Face ${face} color: \"${faceColor}\" (type: ${typeof faceColor})`);\n\n        // Check for both #444444 and 'black' values\n        if (faceColor === '#444444' || faceColor === 'black' || faceColor === '#000000') {\n          blackVisibleFaces.push(face);\n          totalBlackFaces++;\n          logToTerminal(`🔍 ✅ FOUND BLACK/GRAY FACE: ${face} on piece ${pieceId} with color \"${faceColor}\"`);\n        } else {\n          logToTerminal(`🔍 Face ${face} is not black/gray (color: \"${faceColor}\")`);\n        }\n      });\n      if (blackVisibleFaces.length > 0) {\n        incorrectPieces.push({\n          pieceId: pieceId,\n          currentPosition: piece.position,\n          blackVisibleFaces: blackVisibleFaces\n        });\n        logToTerminal(`🔍 ✅ Added piece ${pieceId} to incorrect pieces with ${blackVisibleFaces.length} black faces:`, blackVisibleFaces);\n      } else {\n        logToTerminal(`🔍 Piece ${pieceId} has no black visible faces`);\n      }\n    });\n    logToTerminal('🔍 ========== IDENTIFICATION SUMMARY ==========');\n    logToTerminal('🔍 Total pieces checked:', piecesChecked);\n    logToTerminal('🔍 Pieces with valid position:', piecesWithPosition);\n    logToTerminal('🔍 Pieces with valid colors:', piecesWithColors);\n    logToTerminal('🔍 Pieces with black faces:', incorrectPieces.length);\n    logToTerminal('🔍 Total black faces found:', totalBlackFaces);\n    logToTerminal('🔍 Incorrect pieces details:', incorrectPieces);\n    const result = {\n      type: 'blackFaces',\n      incorrectPieces: incorrectPieces,\n      count: incorrectPieces.length,\n      totalBlackFaces: totalBlackFaces\n    };\n    logToTerminal('🔍 ========== RETURNING RESULT ==========');\n    logToTerminal('🔍 Result:', result);\n    setIdentificationResults(prev => {\n      const newResults = {\n        ...prev,\n        'blackFaces': result\n      };\n      logToTerminal('🔧 UPDATING identificationResults:', newResults);\n      return newResults;\n    });\n    return result;\n  };\n  const result = {\n    type: 'blackFaces',\n    incorrectPieces: piecesWithBlackFaces.map(piece => {\n      const [x, y, z] = piece.position;\n      const visibleFaces = [];\n      if (x === 1) visibleFaces.push('right');\n      if (x === -1) visibleFaces.push('left');\n      if (y === 1) visibleFaces.push('top');\n      if (y === -1) visibleFaces.push('bottom');\n      if (z === 1) visibleFaces.push('front');\n      if (z === -1) visibleFaces.push('back');\n      const blackVisibleFaces = visibleFaces.filter(face => piece.colors[face] === '#444444');\n      return {\n        pieceId: piece.pieceId,\n        shapeType: getShapeType(piece.pieceId),\n        shapeColor: getShapeColor(piece.pieceId),\n        currentPosition: piece.position,\n        expectedPosition: getExpectedPosition(piece.pieceId),\n        colors: piece.colors,\n        rotationHistory: piece.rotationHistory,\n        blackVisibleFaces: blackVisibleFaces,\n        visibleFaces: visibleFaces\n      };\n    }),\n    count: piecesWithBlackFaces.length,\n    totalBlackFaces: piecesWithBlackFaces.reduce((total, piece) => {\n      const [x, y, z] = piece.position;\n      const visibleFaces = [];\n      if (x === 1) visibleFaces.push('right');\n      if (x === -1) visibleFaces.push('left');\n      if (y === 1) visibleFaces.push('top');\n      if (y === -1) visibleFaces.push('bottom');\n      if (z === 1) visibleFaces.push('front');\n      if (z === -1) visibleFaces.push('back');\n      return total + visibleFaces.filter(face => piece.colors[face] === '#444444').length;\n    }, 0)\n  };\n  setIdentificationResults(prev => {\n    const newResults = {\n      ...prev,\n      'blackFaces': result\n    };\n    logToTerminal('🔧 UPDATING identificationResults:', newResults);\n    return newResults;\n  });\n  logToTerminal(`⚫ IDENTIFIED PIECES WITH DARK GRAY FACES`, result);\n  if (onIdentification) {\n    onIdentification(result);\n  }\n  return result;\n}\n_s(IdentifyIncorrectShapes, \"ii/H1hjjocRwhM9agB/LU82OhuE=\");\n_c11 = IdentifyIncorrectShapes;\n;\nconst handleButtonClick = (type, identifier) => {\n  if (isScrambling) return;\n  setActiveIdentification(`${type}-${identifier}`);\n  let result;\n  switch (type) {\n    case 'shape':\n      result = identifyIncorrectShapesByType(identifier);\n      break;\n    case 'color':\n      result = identifyIncorrectShapesByColor(identifier);\n      break;\n    case 'border':\n      result = identifyIncorrectBorderColors(identifier);\n      break;\n    case 'blackFaces':\n      result = identifyPiecesWithBlackFaces();\n      break;\n  }\n\n  // Reset active state after a short delay\n  setTimeout(() => {\n    setActiveIdentification(null);\n  }, 2000);\n};\nconst handleFindAndFixGrayFaces = () => {\n  logToTerminal('🔧 FIND AND FIX GRAY FACES BUTTON CLICKED!');\n  logToTerminal('🔧 isScrambling:', isScrambling);\n  if (isScrambling) {\n    logToTerminal('🔧 Button disabled - cube is scrambling');\n    return;\n  }\n\n  // First identify the pieces with black faces\n  const blackFacesResult = identifyPiecesWithBlackFaces();\n  if (blackFacesResult.count === 0) {\n    logToTerminal('No gray faces to fix');\n    return;\n  }\n  logToTerminal('🔧 FOUND AND FIXING GRAY FACES:', blackFacesResult.incorrectPieces.length, 'pieces');\n  logToTerminal('🔧 Pieces to fix:', blackFacesResult.incorrectPieces.map(p => `${p.pieceId} at [${p.currentPosition.join(', ')}]`));\n\n  // Update the cube state to fix the colors\n  setCubeState(prevState => {\n    logToTerminal('🔧 setCubeState called with prevState length:', prevState.length);\n    const newState = [...prevState];\n    blackFacesResult.incorrectPieces.forEach(incorrectPiece => {\n      logToTerminal(`🔧 Processing piece ${incorrectPiece.pieceId}...`);\n      const pieceIndex = newState.findIndex(p => p.pieceId === incorrectPiece.pieceId);\n      logToTerminal(`🔧 Found piece at index ${pieceIndex}`);\n      if (pieceIndex !== -1) {\n        const piece = newState[pieceIndex];\n        const [x, y, z] = piece.position;\n        logToTerminal(`🔧 Piece ${piece.pieceId} at position [${x}, ${y}, ${z}]`);\n        logToTerminal(`🔧 Current colors:`, piece.colors);\n\n        // Determine which faces should be visible based on current position\n        const visibleFaces = [];\n        if (x === 1) visibleFaces.push('right');\n        if (x === -1) visibleFaces.push('left');\n        if (y === 1) visibleFaces.push('top');\n        if (y === -1) visibleFaces.push('bottom');\n        if (z === 1) visibleFaces.push('front');\n        if (z === -1) visibleFaces.push('back');\n        logToTerminal(`🔧 Visible faces:`, visibleFaces);\n\n        // Fix the colors for visible faces that are currently black/gray\n        const updatedColors = {\n          ...piece.colors\n        };\n        let fixedAny = false;\n        visibleFaces.forEach(face => {\n          logToTerminal(`🔧 Checking face ${face}: current color = ${updatedColors[face]}`);\n          if (updatedColors[face] === '#444444') {\n            // Set the correct color based on the face\n            switch (face) {\n              case 'front':\n                updatedColors[face] = '#FFFFFF'; // White\n                break;\n              case 'back':\n                updatedColors[face] = '#FFD700'; // Yellow\n                break;\n              case 'right':\n                updatedColors[face] = '#DC143C'; // Red\n                break;\n              case 'left':\n                updatedColors[face] = '#FF8C00'; // Orange\n                break;\n              case 'top':\n                updatedColors[face] = '#0000FF'; // Blue\n                break;\n              case 'bottom':\n                updatedColors[face] = '#00FF00'; // Green\n                break;\n            }\n            logToTerminal(`🔧 Fixed face ${face} to ${updatedColors[face]}`);\n            fixedAny = true;\n          }\n        });\n        if (fixedAny) {\n          newState[pieceIndex] = {\n            ...piece,\n            colors: updatedColors\n          };\n          logToTerminal(`🔧 Updated piece ${piece.pieceId} with new colors:`, updatedColors);\n        } else {\n          logToTerminal(`🔧 No changes needed for piece ${piece.pieceId}`);\n        }\n      } else {\n        logToTerminal(`🔧 ERROR: Could not find piece ${incorrectPiece.pieceId} in cube state`);\n      }\n    });\n    logToTerminal('✅ Gray faces find and fix completed!');\n    logToTerminal('🔧 New state length:', newState.length);\n    return newState;\n  });\n\n  // Clear the identification results since we've fixed the issue\n  setIdentificationResults(prev => ({\n    ...prev,\n    blackFaces: null\n  }));\n\n  // Clear the highlighting by calling onIdentification with empty result\n  if (onIdentification) {\n    onIdentification({\n      type: 'blackFaces',\n      count: 0,\n      totalBlackFaces: 0,\n      incorrectPieces: []\n    });\n  }\n};\nconst getButtonState = (type, identifier) => {\n  const key = `${type}-${identifier}`;\n  const result = identificationResults[key];\n  const isActive = activeIdentification === key;\n  return {\n    isActive,\n    hasIncorrect: result && result.count > 0,\n    count: result ? result.count : 0\n  };\n};\n\n// Generate all possible combinations of shape+color+border\nconst generateCombinations = () => {\n  const shapeTypes = ['Square', 'Circle', 'Triangle', 'Diamond'];\n  const shapeColors = ['Red', 'Blue', 'Green', 'Orange', 'Purple', 'Yellow', 'Cyan', 'Magenta', 'Lime', 'Pink'];\n  const borderColors = [{\n    name: 'White',\n    hex: '#FFFFFF',\n    faceIndex: 0\n  }, {\n    name: 'Orange',\n    hex: '#FF8C00',\n    faceIndex: 1\n  }, {\n    name: 'Green',\n    hex: '#00FF00',\n    faceIndex: 2\n  }, {\n    name: 'Red',\n    hex: '#DC143C',\n    faceIndex: 3\n  }, {\n    name: 'Blue',\n    hex: '#0000FF',\n    faceIndex: 4\n  }, {\n    name: 'Yellow',\n    hex: '#FFD700',\n    faceIndex: 5\n  }];\n  const combinations = [];\n  shapeTypes.forEach(shapeType => {\n    shapeColors.forEach(shapeColor => {\n      borderColors.forEach(borderColor => {\n        combinations.push({\n          id: `${shapeType}-${shapeColor}-${borderColor.name}`,\n          shapeType,\n          shapeColor,\n          borderColor: borderColor.name,\n          borderColorHex: borderColor.hex,\n          faceIndex: borderColor.faceIndex\n        });\n      });\n    });\n  });\n  return combinations;\n};\n\n// Identify incorrect pieces by combination\nconst identifyIncorrectCombination = combination => {\n  const incorrectPieces = pieces.filter(piece => {\n    const pieceId = piece.pieceId;\n    const actualShapeType = getShapeType(pieceId);\n    const actualShapeColor = getShapeColor(pieceId);\n    const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\n\n    // Check if this piece matches the combination\n    const matchesShape = actualShapeType === combination.shapeType;\n    const matchesColor = actualShapeColor === combination.shapeColor;\n\n    // Check if this piece should have this border color in its current position\n    const [x, y, z] = piece.position;\n    let shouldHaveBorderColor = false;\n    switch (combination.faceIndex) {\n      case 0:\n        // Front face (Z+) - White\n        shouldHaveBorderColor = z === 1;\n        break;\n      case 1:\n        // Back face (Z-) - Orange\n        shouldHaveBorderColor = z === -1;\n        break;\n      case 2:\n        // Right face (X+) - Green\n        shouldHaveBorderColor = x === 1;\n        break;\n      case 3:\n        // Left face (X-) - Red\n        shouldHaveBorderColor = x === -1;\n        break;\n      case 4:\n        // Top face (Y+) - Blue\n        shouldHaveBorderColor = y === 1;\n        break;\n      case 5:\n        // Bottom face (Y-) - Yellow\n        shouldHaveBorderColor = y === -1;\n        break;\n    }\n\n    // Piece is incorrect if it matches the combination but is not in correct position\n    return matchesShape && matchesColor && shouldHaveBorderColor && !isInCorrectPosition;\n  });\n  const result = {\n    type: 'combination',\n    combination,\n    incorrectPieces: incorrectPieces.map(piece => ({\n      pieceId: piece.pieceId,\n      shapeType: getShapeType(piece.pieceId),\n      shapeColor: getShapeColor(piece.pieceId),\n      currentPosition: piece.position,\n      expectedPosition: getExpectedPosition(piece.pieceId),\n      colors: piece.colors,\n      rotationHistory: piece.rotationHistory\n    })),\n    count: incorrectPieces.length\n  };\n  setIdentificationResults(prev => ({\n    ...prev,\n    [`combination-${combination.id}`]: result\n  }));\n  logToTerminal(`🎯 IDENTIFIED INCORRECT ${combination.shapeColor} ${combination.shapeType} with ${combination.borderColor} border`, result);\n  if (onIdentification) {\n    onIdentification(result);\n  }\n  return result;\n};\nconst handleCombinationClick = combination => {\n  if (isScrambling) return;\n  setActiveIdentification(`combination-${combination.id}`);\n  const result = identifyIncorrectCombination(combination);\n\n  // Reset active state after a short delay\n  setTimeout(() => {\n    setActiveIdentification(null);\n  }, 2000);\n};\nconst getCombinationButtonState = combination => {\n  const key = `combination-${combination.id}`;\n  const result = identificationResults[key];\n  const isActive = activeIdentification === key;\n  return {\n    isActive,\n    hasIncorrect: result && result.count > 0,\n    count: result ? result.count : 0\n  };\n  const combinations = generateCombinations();\n  return /*#__PURE__*/_jsxDEV(IdentifyContainer, {\n    children: [/*#__PURE__*/_jsxDEV(SectionTitle, {\n      children: \"Identify Incorrect Shapes\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 962,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Instructions, {\n      children: \"Click any button below to identify pieces with that specific combination of shape+color+border that are in incorrect positions. Buttons show the count of incorrect pieces found for each combination.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 963,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n        style: {\n          color: 'white',\n          marginBottom: '10px',\n          fontSize: '16px'\n        },\n        children: \"Special Issues\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 970,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ButtonGrid, {\n        style: {\n          gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',\n          marginBottom: '20px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(IdentifyButton, {\n          onClick: () => handleButtonClick('blackFaces', 'all'),\n          disabled: isScrambling,\n          $isActive: activeIdentification === 'blackFaces-all',\n          $hasIncorrect: identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0,\n          style: {\n            background: 'rgba(255, 0, 0, 0.2)',\n            borderColor: '#ff0000',\n            borderWidth: '3px',\n            display: 'none' // Hide the button but keep functionality\n          },\n          children: /*#__PURE__*/_jsxDEV(ButtonContent, {\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              style: {\n                fontSize: '24px',\n                marginBottom: '8px'\n              },\n              children: \"\\u26AB\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 985,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonTitle, {\n              style: {\n                color: '#ff0000',\n                fontWeight: 'bold'\n              },\n              children: \"Dark Gray Faces\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 986,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonSubtitle, {\n              children: \"Find pieces with dark gray faces (highlighted in pink)\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 989,\n              columnNumber: 15\n            }, this), identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0 && /*#__PURE__*/_jsxDEV(CountBadge, {\n              $hasIncorrect: true,\n              children: [identificationResults['blackFaces'].count, \" pieces\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 995,\n                columnNumber: 19\n              }, this), identificationResults['blackFaces'].totalBlackFaces, \" faces\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 993,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 984,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 972,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(IdentifyButton, {\n          onClick: () => {\n            logToTerminal('🔧 BUTTON CLICKED - onClick handler triggered');\n            logToTerminal('🔧 isScrambling:', isScrambling);\n            handleFindAndFixGrayFaces();\n          },\n          disabled: isScrambling,\n          $isActive: false,\n          $hasIncorrect: false,\n          style: {\n            borderColor: '#FF6B6B',\n            borderWidth: '3px',\n            background: 'rgba(255, 107, 107, 0.2)'\n          },\n          children: /*#__PURE__*/_jsxDEV(ButtonContent, {\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              style: {\n                fontSize: '24px',\n                marginBottom: '8px'\n              },\n              children: \"\\uD83D\\uDD27\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1019,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonTitle, {\n              style: {\n                color: '#FF6B6B',\n                fontWeight: 'bold'\n              },\n              children: \"Find & Fix Gray Faces\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1020,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(ButtonSubtitle, {\n              children: \"Identify and automatically correct dark gray faces to proper colors\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1023,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1018,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1003,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 971,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 969,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n        style: {\n          color: 'white',\n          marginBottom: '15px',\n          fontSize: '16px'\n        },\n        children: \"By Shape + Color + Border Combinations\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1033,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ButtonGrid, {\n        style: {\n          gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))'\n        },\n        children: combinations.map(combination => {\n          const state = getCombinationButtonState(combination);\n          return /*#__PURE__*/_jsxDEV(IdentifyButton, {\n            onClick: () => handleCombinationClick(combination),\n            disabled: isScrambling,\n            $isActive: state.isActive,\n            $hasIncorrect: state.hasIncorrect,\n            style: {\n              borderColor: state.hasIncorrect ? '#ff4757' : combination.borderColorHex,\n              borderWidth: '3px'\n            },\n            children: /*#__PURE__*/_jsxDEV(ButtonContent, {\n              children: [/*#__PURE__*/_jsxDEV(ShapeContainer, {\n                children: [combination.shapeType === 'Triangle' ? /*#__PURE__*/_jsxDEV(\"svg\", {\n                  width: \"50\",\n                  height: \"50\",\n                  viewBox: \"0 0 50 50\",\n                  children: /*#__PURE__*/_jsxDEV(\"polygon\", {\n                    points: \"25,5 45,40 5,40\",\n                    fill: getShapeColorHex(combination.shapeColor),\n                    stroke: combination.borderColorHex,\n                    strokeWidth: \"3\"\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 1054,\n                    columnNumber: 25\n                  }, this)\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1053,\n                  columnNumber: 23\n                }, this) : /*#__PURE__*/_jsxDEV(ShapeVisual, {\n                  $shapeType: combination.shapeType,\n                  $shapeColor: getShapeColorHex(combination.shapeColor),\n                  $borderColor: combination.borderColorHex\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1062,\n                  columnNumber: 23\n                }, this), state.count > 0 && /*#__PURE__*/_jsxDEV(CountBadge, {\n                  $hasIncorrect: state.hasIncorrect,\n                  children: state.count\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1069,\n                  columnNumber: 23\n                }, this)]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 1051,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(ButtonTitle, {\n                children: [combination.shapeColor, \" \", combination.shapeType]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 1074,\n                columnNumber: 19\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1050,\n              columnNumber: 17\n            }, this)\n          }, `combination-${combination.id}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1039,\n            columnNumber: 15\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1034,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1032,\n      columnNumber: 7\n    }, this), activeIdentification && /*#__PURE__*/_jsxDEV(StatusMessage, {\n      $type: \"success\",\n      children: \"Combination identification complete! Check the terminal for detailed results.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1086,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 961,\n    columnNumber: 5\n  }, this);\n};\nexport default IdentifyIncorrectShapes;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c0, _c1, _c10, _c11;\n$RefreshReg$(_c, \"IdentifyContainer\");\n$RefreshReg$(_c2, \"SectionTitle\");\n$RefreshReg$(_c3, \"ButtonGrid\");\n$RefreshReg$(_c4, \"IdentifyButton\");\n$RefreshReg$(_c5, \"ButtonContent\");\n$RefreshReg$(_c6, \"ShapeContainer\");\n$RefreshReg$(_c7, \"ShapeVisual\");\n$RefreshReg$(_c8, \"CountBadge\");\n$RefreshReg$(_c9, \"ButtonTitle\");\n$RefreshReg$(_c0, \"ButtonSubtitle\");\n$RefreshReg$(_c1, \"Instructions\");\n$RefreshReg$(_c10, \"StatusMessage\");\n$RefreshReg$(_c11, \"IdentifyIncorrectShapes\");","map":{"version":3,"names":["React","useState","styled","jsxDEV","_jsxDEV","IdentifyContainer","div","_c","SectionTitle","h3","_c2","ButtonGrid","_c3","IdentifyButton","button","props","$isActive","$hasIncorrect","disabled","_c4","ButtonContent","_c5","ShapeContainer","_c6","ShapeVisual","$shapeColor","$borderColor","$shapeType","_c7","CountBadge","span","_c8","ButtonTitle","_c9","ButtonSubtitle","_c0","Instructions","p","_c1","StatusMessage","$type","_c10","logToTerminal","message","data","console","log","JSON","stringify","repeat","sendToLogServer","response","fetch","method","headers","body","signal","AbortSignal","timeout","ok","Error","status","error","IdentifyIncorrectShapes","isScrambling","cubeState","onIdentification","setCubeState","_s","activeIdentification","setActiveIdentification","identificationResults","setIdentificationResults","children","fileName","_jsxFileName","lineNumber","columnNumber","getShapeType","pieceId","shapeTypes","getShapeColor","shapeColors","getExpectedPosition","positions","x","y","z","push","isPieceInCorrectPosition","piece","position","expectedPosition","getExpectedBorderColor","faceIndex","borderColors","getBorderColorName","colorNames","getShapeColorHex","shapeColor","colorMap","getPieces","Array","isArray","map","index","colors","rotationHistory","pieces","identifyIncorrectShapesByType","shapeType","incorrectPieces","filter","actualShapeType","result","type","currentPosition","count","length","prev","toUpperCase","identifyIncorrectShapesByColor","actualShapeColor","identifyIncorrectBorderColors","borderColorName","borderColorHex","isInCorrectPosition","shouldHaveBorderColor","identifyPiecesWithBlackFaces","undefined","totalBlackFaces","piecesChecked","piecesWithColors","piecesWithPosition","slice","forEach","hasPosition","hasColors","allKeys","Object","keys","visibleFaces","blackVisibleFaces","face","faceColor","newResults","piecesWithBlackFaces","reduce","total","_c11","handleButtonClick","identifier","setTimeout","handleFindAndFixGrayFaces","blackFacesResult","join","prevState","newState","incorrectPiece","pieceIndex","findIndex","updatedColors","fixedAny","blackFaces","getButtonState","key","isActive","hasIncorrect","generateCombinations","name","hex","combinations","borderColor","id","identifyIncorrectCombination","combination","matchesShape","matchesColor","handleCombinationClick","getCombinationButtonState","style","color","marginBottom","fontSize","gridTemplateColumns","onClick","background","borderWidth","display","fontWeight","state","width","height","viewBox","points","fill","stroke","strokeWidth","$RefreshReg$"],"sources":["C:/Repo/GitHub/rubiks-cube/src/components/IdentifyIncorrectShapes.js"],"sourcesContent":["import React, { useState } from 'react';\r\nimport styled from 'styled-components';\r\n\r\nconst IdentifyContainer = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 20px;\r\n  padding: 20px;\r\n  background: rgba(255, 255, 255, 0.1);\r\n  border-radius: 15px;\r\n  backdrop-filter: blur(10px);\r\n  border: 1px solid rgba(255, 255, 255, 0.2);\r\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);\r\n  max-height: 500px;\r\n  overflow-y: auto;\r\n`;\r\n\r\nconst SectionTitle = styled.h3`\r\n  color: white;\r\n  text-align: center;\r\n  margin: 0 0 15px 0;\r\n  font-size: 1.3rem;\r\n  font-weight: 600;\r\n  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\r\n`;\r\n\r\nconst ButtonGrid = styled.div`\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\r\n  gap: 15px;\r\n  margin-bottom: 20px;\r\n`;\r\n\r\nconst IdentifyButton = styled.button`\r\n  padding: 12px 16px;\r\n  border: 2px solid ${props => {\r\n    if (props.$isActive) return '#4CAF50';\r\n    if (props.$hasIncorrect) return '#ff4757';\r\n    return 'rgba(255, 255, 255, 0.3)';\r\n  }};\r\n  border-radius: 10px;\r\n  font-size: 14px;\r\n  font-weight: 600;\r\n  cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};\r\n  transition: all 0.3s ease;\r\n  background: ${props => {\r\n    if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\r\n    if (props.$isActive) return 'rgba(76, 175, 80, 0.2)';\r\n    if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.2)';\r\n    return 'rgba(255, 255, 255, 0.1)';\r\n  }};\r\n  color: ${props => {\r\n    if (props.disabled) return '#666';\r\n    if (props.$isActive) return '#4CAF50';\r\n    if (props.$hasIncorrect) return '#ff4757';\r\n    return 'white';\r\n  }};\r\n  opacity: ${props => props.disabled ? 0.5 : 1};\r\n  \r\n  &:hover {\r\n    transform: ${props => props.disabled ? 'none' : 'translateY(-2px)'};\r\n    box-shadow: ${props => props.disabled ? 'none' : '0 4px 12px rgba(0, 0, 0, 0.3)'};\r\n    background: ${props => {\r\n      if (props.disabled) return 'rgba(100, 100, 100, 0.3)';\r\n      if (props.$isActive) return 'rgba(76, 175, 80, 0.3)';\r\n      if (props.$hasIncorrect) return 'rgba(255, 71, 87, 0.3)';\r\n      return 'rgba(255, 255, 255, 0.2)';\r\n    }};\r\n  }\r\n  \r\n  &:active {\r\n    transform: ${props => props.disabled ? 'none' : 'translateY(0)'};\r\n  }\r\n`;\r\n\r\nconst ButtonContent = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  gap: 4px;\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n`;\r\n\r\nconst ShapeContainer = styled.div`\r\n  width: 60px;\r\n  height: 60px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  position: relative;\r\n  margin: 8px 0;\r\n`;\r\n\r\nconst ShapeVisual = styled.div`\r\n  width: 50px;\r\n  height: 50px;\r\n  background: ${props => props.$shapeColor};\r\n  border: 3px solid ${props => props.$borderColor};\r\n  position: relative;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  \r\n  /* Shape-specific styling */\r\n  border-radius: ${props => {\r\n    if (props.$shapeType === 'Circle') return '50%';\r\n    if (props.$shapeType === 'Diamond') return '0';\r\n    return '0';\r\n  }};\r\n  \r\n  transform: ${props => {\r\n    if (props.$shapeType === 'Diamond') return 'rotate(45deg)';\r\n    return 'none';\r\n  }};\r\n  \r\n  /* Triangle shape using CSS */\r\n  ${props => props.$shapeType === 'Triangle' && `\r\n    width: 0;\r\n    height: 0;\r\n    background: transparent;\r\n    border: none;\r\n    border-left: 25px solid transparent;\r\n    border-right: 25px solid transparent;\r\n    border-bottom: 43px solid ${props.$shapeColor};\r\n    position: relative;\r\n  `}\r\n`;\r\n\r\nconst CountBadge = styled.span`\r\n  background: ${props => props.$hasIncorrect ? '#ff4757' : '#4CAF50'};\r\n  color: white;\r\n  border-radius: 50%;\r\n  width: 20px;\r\n  height: 20px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  font-size: 10px;\r\n  font-weight: bold;\r\n  position: absolute;\r\n  top: -5px;\r\n  right: -5px;\r\n  z-index: 10;\r\n`;\r\n\r\nconst ButtonTitle = styled.span`\r\n  font-size: 12px;\r\n  font-weight: 600;\r\n  color: white;\r\n  text-align: center;\r\n  margin-top: 4px;\r\n`;\r\n\r\nconst ButtonSubtitle = styled.div`\r\n  font-size: 10px;\r\n  color: rgba(255, 255, 255, 0.8);\r\n  text-align: center;\r\n  margin-top: 2px;\r\n  line-height: 1.2;\r\n`;\r\n\r\nconst Instructions = styled.p`\r\n  color: rgba(255, 255, 255, 0.8);\r\n  font-size: 13px;\r\n  text-align: center;\r\n  margin: 0 0 15px 0;\r\n  line-height: 1.4;\r\n`;\r\n\r\nconst StatusMessage = styled.div`\r\n  padding: 10px;\r\n  border-radius: 8px;\r\n  text-align: center;\r\n  font-size: 12px;\r\n  font-weight: 600;\r\n  background: ${props => {\r\n    if (props.$type === 'success') return 'rgba(76, 175, 80, 0.2)';\r\n    if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.2)';\r\n    if (props.$type === 'error') return 'rgba(244, 67, 54, 0.2)';\r\n    return 'rgba(33, 150, 243, 0.2)';\r\n  }};\r\n  color: ${props => {\r\n    if (props.$type === 'success') return '#4CAF50';\r\n    if (props.$type === 'warning') return '#FFC107';\r\n    if (props.$type === 'error') return '#f44336';\r\n    return '#2196F3';\r\n  }};\r\n  border: 1px solid ${props => {\r\n    if (props.$type === 'success') return 'rgba(76, 175, 80, 0.3)';\r\n    if (props.$type === 'warning') return 'rgba(255, 193, 7, 0.3)';\r\n    if (props.$type === 'error') return 'rgba(244, 67, 54, 0.3)';\r\n    return 'rgba(33, 150, 243, 0.3)';\r\n  }};\r\n`;\r\n\r\n// Custom logging function\r\nconst logToTerminal = (message, data = null) => {\r\n  console.log(`\\n🎯 ${message}`);\r\n  if (data) {\r\n    console.log(JSON.stringify(data, null, 2));\r\n  }\r\n  console.log('='.repeat(80) + '\\n');\r\n  \r\n  // Try to send to log server, but don't fail if it's not available\r\n  const sendToLogServer = async () => {\r\n    try {\r\n      const response = await fetch('http://localhost:3001/log', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          message: message,\r\n          data: data\r\n        }),\r\n        // Add timeout to prevent hanging\r\n        signal: AbortSignal.timeout(1000)\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      console.log('✅ Log sent to terminal successfully');\r\n    } catch (error) {\r\n      // Silently fail - logging server is optional\r\n      console.log('💡 Log server not available - logging to console only');\r\n    }\r\n  };\r\n  \r\n  // Execute without blocking\r\n  sendToLogServer();\r\n};\r\n\r\nfunction IdentifyIncorrectShapes({ isScrambling, cubeState, onIdentification, setCubeState }) {\r\n  const [activeIdentification, setActiveIdentification] = useState(null);\r\n  const [identificationResults, setIdentificationResults] = useState({});\r\n\r\n  if (!cubeState) {\r\n    console.log('🚨 SHOWING LOADING MESSAGE - no cubeState');\r\n    return (\r\n      <IdentifyContainer>\r\n        <SectionTitle>Identify Incorrect Shapes</SectionTitle>\r\n        <StatusMessage $type=\"warning\">\r\n          Loading cube state... Please scramble the cube first to identify incorrect shapes.\r\n        </StatusMessage>\r\n      </IdentifyContainer>\r\n    );\r\n  }\r\n\r\n  // Helper functions\r\n  const getShapeType = (pieceId) => {\r\n    const shapeTypes = [\r\n      'Square', 'Square', 'Square', 'Square', 'Square',\r\n      'Circle', 'Circle', 'Circle', 'Circle', 'Circle',\r\n      'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Diamond',\r\n      'Diamond', 'Diamond', 'Diamond', 'Diamond', 'Diamond',\r\n      'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle', 'Triangle'\r\n    ];\r\n    return shapeTypes[pieceId] || 'Unknown';\r\n  };\r\n\r\n  const getShapeColor = (pieceId) => {\r\n    const shapeColors = [\r\n      'Red', 'Blue', 'Green', 'Orange', 'Purple',\r\n      'Red', 'Blue', 'Green', 'Orange', 'Yellow',\r\n      'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple',\r\n      'Red', 'Blue', 'Green', 'Orange', 'Purple',\r\n      'Cyan', 'Magenta', 'Lime', 'Pink', 'Purple', 'Yellow'\r\n    ];\r\n    return shapeColors[pieceId] || 'Unknown';\r\n  };\r\n\r\n  const getExpectedPosition = (pieceId) => {\r\n    const positions = [];\r\n    for (let x = -1; x <= 1; x++) {\r\n      for (let y = -1; y <= 1; y++) {\r\n        for (let z = -1; z <= 1; z++) {\r\n          if (x === 0 && y === 0 && z === 0) continue;\r\n          positions.push([x, y, z]);\r\n        }\r\n      }\r\n    }\r\n    return positions[pieceId];\r\n  };\r\n\r\n  const isPieceInCorrectPosition = (piece, pieceId) => {\r\n    if (!piece || !piece.position) return false;\r\n    const expectedPosition = getExpectedPosition(pieceId);\r\n    return JSON.stringify(piece.position) === JSON.stringify(expectedPosition);\r\n  };\r\n\r\n  const getExpectedBorderColor = (faceIndex) => {\r\n    const borderColors = [\r\n      '#FFFFFF', // Face 0 (front) - White\r\n      '#FF8C00', // Face 1 (back) - Orange  \r\n      '#00FF00', // Face 2 (right) - Green\r\n      '#DC143C', // Face 3 (left) - Red\r\n      '#0000FF', // Face 4 (top) - Blue\r\n      '#FFD700'  // Face 5 (bottom) - Yellow\r\n    ];\r\n    return borderColors[faceIndex] || '#000000';\r\n  };\r\n\r\n  const getBorderColorName = (faceIndex) => {\r\n    const colorNames = ['White', 'Orange', 'Green', 'Red', 'Blue', 'Yellow'];\r\n    return colorNames[faceIndex] || 'Unknown';\r\n  };\r\n\r\n  const getShapeColorHex = (shapeColor) => {\r\n    const colorMap = {\r\n      'Red': '#DC143C',\r\n      'Blue': '#0000FF',\r\n      'Green': '#00FF00',\r\n      'Orange': '#FF8C00',\r\n      'Purple': '#800080',\r\n      'Yellow': '#FFD700',\r\n      'Cyan': '#00FFFF',\r\n      'Magenta': '#FF00FF',\r\n      'Lime': '#00FF00',\r\n      'Pink': '#FFC0CB'\r\n    };\r\n    return colorMap[shapeColor] || '#000000';\r\n  };\r\n\r\n  // Get pieces data\r\n  const getPieces = () => {\r\n    if (Array.isArray(cubeState)) {\r\n      return cubeState.map((piece, index) => ({\r\n        pieceId: index,\r\n        position: piece.position,\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory || []\r\n      }));\r\n    } else if (cubeState?.pieces) {\r\n      return cubeState.pieces;\r\n    }\r\n    return [];\r\n  };\r\n\r\n  const pieces = getPieces();\r\n\r\n  // Identify incorrect shapes by type\r\n  const identifyIncorrectShapesByType = (shapeType) => {\r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const actualShapeType = getShapeType(pieceId);\r\n      return actualShapeType === shapeType && !isPieceInCorrectPosition(piece, pieceId);\r\n    });\r\n\r\n    const result = {\r\n      type: 'shape',\r\n      shapeType,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`shape-${shapeType}`]: result\r\n    }));\r\n\r\n    logToTerminal(`🔍 IDENTIFIED INCORRECT ${shapeType.toUpperCase()} SHAPES`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  // Identify incorrect shapes by color\r\n  const identifyIncorrectShapesByColor = (shapeColor) => {\r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const actualShapeColor = getShapeColor(pieceId);\r\n      return actualShapeColor === shapeColor && !isPieceInCorrectPosition(piece, pieceId);\r\n    });\r\n\r\n    const result = {\r\n      type: 'color',\r\n      shapeColor,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`color-${shapeColor}`]: result\r\n    }));\r\n\r\n    logToTerminal(`🎨 IDENTIFIED INCORRECT ${shapeColor.toUpperCase()} SHAPES`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  // Identify incorrect border colors\r\n  const identifyIncorrectBorderColors = (faceIndex) => {\r\n    const borderColorName = getBorderColorName(faceIndex);\r\n    const borderColorHex = getExpectedBorderColor(faceIndex);\r\n    \r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\r\n      \r\n      // Check if this piece should have this border color in its current position\r\n      const [x, y, z] = piece.position;\r\n      let shouldHaveBorderColor = false;\r\n      \r\n      switch (faceIndex) {\r\n        case 0: // Front face (Z+) - White\r\n          shouldHaveBorderColor = z === 1;\r\n          break;\r\n        case 1: // Back face (Z-) - Orange\r\n          shouldHaveBorderColor = z === -1;\r\n          break;\r\n        case 2: // Right face (X+) - Green\r\n          shouldHaveBorderColor = x === 1;\r\n          break;\r\n        case 3: // Left face (X-) - Red\r\n          shouldHaveBorderColor = x === -1;\r\n          break;\r\n        case 4: // Top face (Y+) - Blue\r\n          shouldHaveBorderColor = y === 1;\r\n          break;\r\n        case 5: // Bottom face (Y-) - Yellow\r\n          shouldHaveBorderColor = y === -1;\r\n          break;\r\n      }\r\n      \r\n      // Piece is incorrect if it should have this border color but is not in correct position\r\n      return shouldHaveBorderColor && !isInCorrectPosition;\r\n    });\r\n\r\n    const result = {\r\n      type: 'border',\r\n      faceIndex,\r\n      borderColorName,\r\n      borderColorHex,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`border-${faceIndex}`]: result\r\n    }));\r\n\r\n    logToTerminal(`🎭 IDENTIFIED INCORRECT ${borderColorName.toUpperCase()} BORDER COLORS`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  // Identify pieces with black faces that should be visible\r\n  const identifyPiecesWithBlackFaces = () => {\r\n    logToTerminal('🔍 ========== STARTING BLACK FACES IDENTIFICATION ==========');\r\n    logToTerminal('🔍 cubeState type:', typeof cubeState);\r\n    logToTerminal('🔍 cubeState length:', cubeState ? cubeState.length : 'null');\r\n    logToTerminal('🔍 cubeState is null:', cubeState === null);\r\n    logToTerminal('🔍 cubeState is undefined:', cubeState === undefined);\r\n    \r\n    if (!cubeState || cubeState.length === 0) {\r\n      logToTerminal('🔍 ❌ No cube state available for identification');\r\n      return {\r\n        type: 'blackFaces',\r\n        incorrectPieces: [],\r\n        count: 0,\r\n        totalBlackFaces: 0\r\n      };\r\n    }\r\n\r\n    logToTerminal('🔍 ✅ Cube state available, checking', cubeState.length, 'pieces...');\r\n    \r\n    const incorrectPieces = [];\r\n    let totalBlackFaces = 0;\r\n    let piecesChecked = 0;\r\n    let piecesWithColors = 0;\r\n    let piecesWithPosition = 0;\r\n\r\n    // Log detailed structure of first few pieces\r\n    logToTerminal('🔍 ========== PIECE STRUCTURE ANALYSIS ==========');\r\n    cubeState.slice(0, 5).forEach((piece, index) => {\r\n      logToTerminal(`🔍 Piece ${index}:`, {\r\n        pieceId: piece.pieceId,\r\n        hasPosition: Array.isArray(piece.position),\r\n        position: piece.position,\r\n        hasColors: typeof piece.colors === 'object' && piece.colors !== null,\r\n        colors: piece.colors,\r\n        allKeys: Object.keys(piece)\r\n      });\r\n    });\r\n\r\n    logToTerminal('🔍 ========== CHECKING ALL PIECES ==========');\r\n    \r\n    cubeState.forEach((piece, index) => {\r\n      piecesChecked++;\r\n      const pieceId = piece.pieceId || index;\r\n      \r\n      // Check if piece has position\r\n      if (!Array.isArray(piece.position)) {\r\n        logToTerminal(`🔍 ❌ Piece ${pieceId} has invalid position:`, piece.position);\r\n        return;\r\n      }\r\n      piecesWithPosition++;\r\n      \r\n      // Check if piece has colors\r\n      if (!piece.colors || typeof piece.colors !== 'object') {\r\n        logToTerminal(`🔍 ❌ Piece ${pieceId} has invalid colors:`, piece.colors);\r\n        return;\r\n      }\r\n      piecesWithColors++;\r\n      \r\n      const [x, y, z] = piece.position;\r\n      \r\n      logToTerminal(`🔍 Checking piece ${pieceId} at position [${x}, ${y}, ${z}]`);\r\n      logToTerminal(`🔍 Piece colors object:`, piece.colors);\r\n      logToTerminal(`🔍 Color keys:`, Object.keys(piece.colors));\r\n      \r\n      // Determine which faces should be visible based on current position\r\n      const visibleFaces = [];\r\n      if (x === 1) visibleFaces.push('right');\r\n      if (x === -1) visibleFaces.push('left');\r\n      if (y === 1) visibleFaces.push('top');\r\n      if (y === -1) visibleFaces.push('bottom');\r\n      if (z === 1) visibleFaces.push('front');\r\n      if (z === -1) visibleFaces.push('back');\r\n      \r\n      logToTerminal(`🔍 Visible faces for piece ${pieceId}:`, visibleFaces);\r\n      \r\n      // Check if any visible faces are black/gray\r\n      const blackVisibleFaces = [];\r\n      visibleFaces.forEach(face => {\r\n        const faceColor = piece.colors[face];\r\n        logToTerminal(`🔍 Face ${face} color: \"${faceColor}\" (type: ${typeof faceColor})`);\r\n        \r\n        // Check for both #444444 and 'black' values\r\n        if (faceColor === '#444444' || faceColor === 'black' || faceColor === '#000000') {\r\n          blackVisibleFaces.push(face);\r\n          totalBlackFaces++;\r\n          logToTerminal(`🔍 ✅ FOUND BLACK/GRAY FACE: ${face} on piece ${pieceId} with color \"${faceColor}\"`);\r\n        } else {\r\n          logToTerminal(`🔍 Face ${face} is not black/gray (color: \"${faceColor}\")`);\r\n        }\r\n      });\r\n      \r\n      if (blackVisibleFaces.length > 0) {\r\n        incorrectPieces.push({\r\n          pieceId: pieceId,\r\n          currentPosition: piece.position,\r\n          blackVisibleFaces: blackVisibleFaces\r\n        });\r\n        logToTerminal(`🔍 ✅ Added piece ${pieceId} to incorrect pieces with ${blackVisibleFaces.length} black faces:`, blackVisibleFaces);\r\n      } else {\r\n        logToTerminal(`🔍 Piece ${pieceId} has no black visible faces`);\r\n      }\r\n    });\r\n\r\n    logToTerminal('🔍 ========== IDENTIFICATION SUMMARY ==========');\r\n    logToTerminal('🔍 Total pieces checked:', piecesChecked);\r\n    logToTerminal('🔍 Pieces with valid position:', piecesWithPosition);\r\n    logToTerminal('🔍 Pieces with valid colors:', piecesWithColors);\r\n    logToTerminal('🔍 Pieces with black faces:', incorrectPieces.length);\r\n    logToTerminal('🔍 Total black faces found:', totalBlackFaces);\r\n    logToTerminal('🔍 Incorrect pieces details:', incorrectPieces);\r\n\r\n    const result = {\r\n      type: 'blackFaces',\r\n      incorrectPieces: incorrectPieces,\r\n      count: incorrectPieces.length,\r\n      totalBlackFaces: totalBlackFaces\r\n    };\r\n    \r\n    logToTerminal('🔍 ========== RETURNING RESULT ==========');\r\n    logToTerminal('🔍 Result:', result);\r\n    \r\n    setIdentificationResults(prev => {\r\n      const newResults = {\r\n        ...prev,\r\n        'blackFaces': result\r\n      };\r\n      logToTerminal('🔧 UPDATING identificationResults:', newResults);\r\n      return newResults;\r\n    });\r\n\r\n    return result;\r\n  };\r\n\r\n    \r\n    const result = {\r\n      type: 'blackFaces',\r\n      incorrectPieces: piecesWithBlackFaces.map(piece => {\r\n        const [x, y, z] = piece.position;\r\n        const visibleFaces = [];\r\n        if (x === 1) visibleFaces.push('right');\r\n        if (x === -1) visibleFaces.push('left');\r\n        if (y === 1) visibleFaces.push('top');\r\n        if (y === -1) visibleFaces.push('bottom');\r\n        if (z === 1) visibleFaces.push('front');\r\n        if (z === -1) visibleFaces.push('back');\r\n        \r\n        const blackVisibleFaces = visibleFaces.filter(face => piece.colors[face] === '#444444');\r\n        \r\n        return {\r\n          pieceId: piece.pieceId,\r\n          shapeType: getShapeType(piece.pieceId),\r\n          shapeColor: getShapeColor(piece.pieceId),\r\n          currentPosition: piece.position,\r\n          expectedPosition: getExpectedPosition(piece.pieceId),\r\n          colors: piece.colors,\r\n          rotationHistory: piece.rotationHistory,\r\n          blackVisibleFaces: blackVisibleFaces,\r\n          visibleFaces: visibleFaces\r\n        };\r\n      }),\r\n      count: piecesWithBlackFaces.length,\r\n      totalBlackFaces: piecesWithBlackFaces.reduce((total, piece) => {\r\n        const [x, y, z] = piece.position;\r\n        const visibleFaces = [];\r\n        if (x === 1) visibleFaces.push('right');\r\n        if (x === -1) visibleFaces.push('left');\r\n        if (y === 1) visibleFaces.push('top');\r\n        if (y === -1) visibleFaces.push('bottom');\r\n        if (z === 1) visibleFaces.push('front');\r\n        if (z === -1) visibleFaces.push('back');\r\n        return total + visibleFaces.filter(face => piece.colors[face] === '#444444').length;\r\n      }, 0)\r\n    };\r\n\r\n    setIdentificationResults(prev => {\r\n      const newResults = {\r\n        ...prev,\r\n        'blackFaces': result\r\n      };\r\n      logToTerminal('🔧 UPDATING identificationResults:', newResults);\r\n      return newResults;\r\n    });\r\n\r\n    logToTerminal(`⚫ IDENTIFIED PIECES WITH DARK GRAY FACES`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  const handleButtonClick = (type, identifier) => {\r\n    if (isScrambling) return;\r\n\r\n    setActiveIdentification(`${type}-${identifier}`);\r\n\r\n    let result;\r\n    switch (type) {\r\n      case 'shape':\r\n        result = identifyIncorrectShapesByType(identifier);\r\n        break;\r\n      case 'color':\r\n        result = identifyIncorrectShapesByColor(identifier);\r\n        break;\r\n      case 'border':\r\n        result = identifyIncorrectBorderColors(identifier);\r\n        break;\r\n      case 'blackFaces':\r\n        result = identifyPiecesWithBlackFaces();\r\n        break;\r\n    }\r\n\r\n    // Reset active state after a short delay\r\n    setTimeout(() => {\r\n      setActiveIdentification(null);\r\n    }, 2000);\r\n  };\r\n\r\n  const handleFindAndFixGrayFaces = () => {\r\n    logToTerminal('🔧 FIND AND FIX GRAY FACES BUTTON CLICKED!');\r\n    logToTerminal('🔧 isScrambling:', isScrambling);\r\n    \r\n    if (isScrambling) {\r\n      logToTerminal('🔧 Button disabled - cube is scrambling');\r\n      return;\r\n    }\r\n\r\n    // First identify the pieces with black faces\r\n    const blackFacesResult = identifyPiecesWithBlackFaces();\r\n    \r\n    if (blackFacesResult.count === 0) {\r\n      logToTerminal('No gray faces to fix');\r\n      return;\r\n    }\r\n\r\n    logToTerminal('🔧 FOUND AND FIXING GRAY FACES:', blackFacesResult.incorrectPieces.length, 'pieces');\r\n    logToTerminal('🔧 Pieces to fix:', blackFacesResult.incorrectPieces.map(p => `${p.pieceId} at [${p.currentPosition.join(', ')}]`));\r\n\r\n    // Update the cube state to fix the colors\r\n    setCubeState(prevState => {\r\n      logToTerminal('🔧 setCubeState called with prevState length:', prevState.length);\r\n      const newState = [...prevState];\r\n      \r\n      blackFacesResult.incorrectPieces.forEach(incorrectPiece => {\r\n        logToTerminal(`🔧 Processing piece ${incorrectPiece.pieceId}...`);\r\n        const pieceIndex = newState.findIndex(p => p.pieceId === incorrectPiece.pieceId);\r\n        logToTerminal(`🔧 Found piece at index ${pieceIndex}`);\r\n        \r\n        if (pieceIndex !== -1) {\r\n          const piece = newState[pieceIndex];\r\n          const [x, y, z] = piece.position;\r\n          logToTerminal(`🔧 Piece ${piece.pieceId} at position [${x}, ${y}, ${z}]`);\r\n          logToTerminal(`🔧 Current colors:`, piece.colors);\r\n          \r\n          // Determine which faces should be visible based on current position\r\n          const visibleFaces = [];\r\n          if (x === 1) visibleFaces.push('right');\r\n          if (x === -1) visibleFaces.push('left');\r\n          if (y === 1) visibleFaces.push('top');\r\n          if (y === -1) visibleFaces.push('bottom');\r\n          if (z === 1) visibleFaces.push('front');\r\n          if (z === -1) visibleFaces.push('back');\r\n          \r\n          logToTerminal(`🔧 Visible faces:`, visibleFaces);\r\n          \r\n          // Fix the colors for visible faces that are currently black/gray\r\n          const updatedColors = { ...piece.colors };\r\n          let fixedAny = false;\r\n          \r\n          visibleFaces.forEach(face => {\r\n            logToTerminal(`🔧 Checking face ${face}: current color = ${updatedColors[face]}`);\r\n            if (updatedColors[face] === '#444444') {\r\n              // Set the correct color based on the face\r\n              switch (face) {\r\n                case 'front':\r\n                  updatedColors[face] = '#FFFFFF'; // White\r\n                  break;\r\n                case 'back':\r\n                  updatedColors[face] = '#FFD700'; // Yellow\r\n                  break;\r\n                case 'right':\r\n                  updatedColors[face] = '#DC143C'; // Red\r\n                  break;\r\n                case 'left':\r\n                  updatedColors[face] = '#FF8C00'; // Orange\r\n                  break;\r\n                case 'top':\r\n                  updatedColors[face] = '#0000FF'; // Blue\r\n                  break;\r\n                case 'bottom':\r\n                  updatedColors[face] = '#00FF00'; // Green\r\n                  break;\r\n              }\r\n              logToTerminal(`🔧 Fixed face ${face} to ${updatedColors[face]}`);\r\n              fixedAny = true;\r\n            }\r\n          });\r\n          \r\n          if (fixedAny) {\r\n            newState[pieceIndex] = {\r\n              ...piece,\r\n              colors: updatedColors\r\n            };\r\n            logToTerminal(`🔧 Updated piece ${piece.pieceId} with new colors:`, updatedColors);\r\n          } else {\r\n            logToTerminal(`🔧 No changes needed for piece ${piece.pieceId}`);\r\n          }\r\n        } else {\r\n          logToTerminal(`🔧 ERROR: Could not find piece ${incorrectPiece.pieceId} in cube state`);\r\n        }\r\n      });\r\n      \r\n      logToTerminal('✅ Gray faces find and fix completed!');\r\n      logToTerminal('🔧 New state length:', newState.length);\r\n      return newState;\r\n    });\r\n\r\n    // Clear the identification results since we've fixed the issue\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      blackFaces: null\r\n    }));\r\n\r\n    // Clear the highlighting by calling onIdentification with empty result\r\n    if (onIdentification) {\r\n      onIdentification({\r\n        type: 'blackFaces',\r\n        count: 0,\r\n        totalBlackFaces: 0,\r\n        incorrectPieces: []\r\n      });\r\n    }\r\n  };\r\n\r\n  const getButtonState = (type, identifier) => {\r\n    const key = `${type}-${identifier}`;\r\n    const result = identificationResults[key];\r\n    const isActive = activeIdentification === key;\r\n    \r\n    return {\r\n      isActive,\r\n      hasIncorrect: result && result.count > 0,\r\n      count: result ? result.count : 0\r\n    };\r\n  };\r\n\r\n  // Generate all possible combinations of shape+color+border\r\n  const generateCombinations = () => {\r\n    const shapeTypes = ['Square', 'Circle', 'Triangle', 'Diamond'];\r\n    const shapeColors = ['Red', 'Blue', 'Green', 'Orange', 'Purple', 'Yellow', 'Cyan', 'Magenta', 'Lime', 'Pink'];\r\n    const borderColors = [\r\n      { name: 'White', hex: '#FFFFFF', faceIndex: 0 },\r\n      { name: 'Orange', hex: '#FF8C00', faceIndex: 1 },\r\n      { name: 'Green', hex: '#00FF00', faceIndex: 2 },\r\n      { name: 'Red', hex: '#DC143C', faceIndex: 3 },\r\n      { name: 'Blue', hex: '#0000FF', faceIndex: 4 },\r\n      { name: 'Yellow', hex: '#FFD700', faceIndex: 5 }\r\n    ];\r\n\r\n    const combinations = [];\r\n    shapeTypes.forEach(shapeType => {\r\n      shapeColors.forEach(shapeColor => {\r\n        borderColors.forEach(borderColor => {\r\n          combinations.push({\r\n            id: `${shapeType}-${shapeColor}-${borderColor.name}`,\r\n            shapeType,\r\n            shapeColor,\r\n            borderColor: borderColor.name,\r\n            borderColorHex: borderColor.hex,\r\n            faceIndex: borderColor.faceIndex\r\n          });\r\n        });\r\n      });\r\n    });\r\n    return combinations;\r\n  };\r\n\r\n  // Identify incorrect pieces by combination\r\n  const identifyIncorrectCombination = (combination) => {\r\n    const incorrectPieces = pieces.filter(piece => {\r\n      const pieceId = piece.pieceId;\r\n      const actualShapeType = getShapeType(pieceId);\r\n      const actualShapeColor = getShapeColor(pieceId);\r\n      const isInCorrectPosition = isPieceInCorrectPosition(piece, pieceId);\r\n      \r\n      // Check if this piece matches the combination\r\n      const matchesShape = actualShapeType === combination.shapeType;\r\n      const matchesColor = actualShapeColor === combination.shapeColor;\r\n      \r\n      // Check if this piece should have this border color in its current position\r\n      const [x, y, z] = piece.position;\r\n      let shouldHaveBorderColor = false;\r\n      \r\n      switch (combination.faceIndex) {\r\n        case 0: // Front face (Z+) - White\r\n          shouldHaveBorderColor = z === 1;\r\n          break;\r\n        case 1: // Back face (Z-) - Orange\r\n          shouldHaveBorderColor = z === -1;\r\n          break;\r\n        case 2: // Right face (X+) - Green\r\n          shouldHaveBorderColor = x === 1;\r\n          break;\r\n        case 3: // Left face (X-) - Red\r\n          shouldHaveBorderColor = x === -1;\r\n          break;\r\n        case 4: // Top face (Y+) - Blue\r\n          shouldHaveBorderColor = y === 1;\r\n          break;\r\n        case 5: // Bottom face (Y-) - Yellow\r\n          shouldHaveBorderColor = y === -1;\r\n          break;\r\n      }\r\n      \r\n      // Piece is incorrect if it matches the combination but is not in correct position\r\n      return matchesShape && matchesColor && shouldHaveBorderColor && !isInCorrectPosition;\r\n    });\r\n\r\n    const result = {\r\n      type: 'combination',\r\n      combination,\r\n      incorrectPieces: incorrectPieces.map(piece => ({\r\n        pieceId: piece.pieceId,\r\n        shapeType: getShapeType(piece.pieceId),\r\n        shapeColor: getShapeColor(piece.pieceId),\r\n        currentPosition: piece.position,\r\n        expectedPosition: getExpectedPosition(piece.pieceId),\r\n        colors: piece.colors,\r\n        rotationHistory: piece.rotationHistory\r\n      })),\r\n      count: incorrectPieces.length\r\n    };\r\n\r\n    setIdentificationResults(prev => ({\r\n      ...prev,\r\n      [`combination-${combination.id}`]: result\r\n    }));\r\n\r\n    logToTerminal(`🎯 IDENTIFIED INCORRECT ${combination.shapeColor} ${combination.shapeType} with ${combination.borderColor} border`, result);\r\n    \r\n    if (onIdentification) {\r\n      onIdentification(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  const handleCombinationClick = (combination) => {\r\n    if (isScrambling) return;\r\n\r\n    setActiveIdentification(`combination-${combination.id}`);\r\n    const result = identifyIncorrectCombination(combination);\r\n\r\n    // Reset active state after a short delay\r\n    setTimeout(() => {\r\n      setActiveIdentification(null);\r\n    }, 2000);\r\n  };\r\n\r\n  const getCombinationButtonState = (combination) => {\r\n    const key = `combination-${combination.id}`;\r\n    const result = identificationResults[key];\r\n    const isActive = activeIdentification === key;\r\n    \r\n    return {\r\n      isActive,\r\n      hasIncorrect: result && result.count > 0,\r\n      count: result ? result.count : 0\r\n    };\r\n  const combinations = generateCombinations();\r\n\r\n  return (\r\n    <IdentifyContainer>\r\n      <SectionTitle>Identify Incorrect Shapes</SectionTitle>\r\n      <Instructions>\r\n        Click any button below to identify pieces with that specific combination of shape+color+border that are in incorrect positions.\r\n        Buttons show the count of incorrect pieces found for each combination.\r\n      </Instructions>\r\n\r\n      {/* Black Faces Identification */}\r\n      <div>\r\n        <h4 style={{ color: 'white', marginBottom: '10px', fontSize: '16px' }}>Special Issues</h4>\r\n        <ButtonGrid style={{ gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', marginBottom: '20px' }}>\r\n          <IdentifyButton\r\n            onClick={() => handleButtonClick('blackFaces', 'all')}\r\n            disabled={isScrambling}\r\n            $isActive={activeIdentification === 'blackFaces-all'}\r\n            $hasIncorrect={identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0}\r\n            style={{\r\n              background: 'rgba(255, 0, 0, 0.2)',\r\n              borderColor: '#ff0000',\r\n              borderWidth: '3px',\r\n              display: 'none' // Hide the button but keep functionality\r\n            }}\r\n          >\r\n            <ButtonContent>\r\n              <div style={{ fontSize: '24px', marginBottom: '8px' }}>⚫</div>\r\n              <ButtonTitle style={{ color: '#ff0000', fontWeight: 'bold' }}>\r\n                Dark Gray Faces\r\n              </ButtonTitle>\r\n              <ButtonSubtitle>\r\n                Find pieces with dark gray faces (highlighted in pink)\r\n              </ButtonSubtitle>\r\n              {identificationResults['blackFaces'] && identificationResults['blackFaces'].count > 0 && (\r\n                <CountBadge $hasIncorrect={true}>\r\n                  {identificationResults['blackFaces'].count} pieces\r\n                  <br />\r\n                  {identificationResults['blackFaces'].totalBlackFaces} faces\r\n                </CountBadge>\r\n              )}\r\n            </ButtonContent>\r\n          </IdentifyButton>\r\n          \r\n          {/* Find and Fix Gray Faces Button */}\r\n          <IdentifyButton\r\n            onClick={() => {\r\n              logToTerminal('🔧 BUTTON CLICKED - onClick handler triggered');\r\n              logToTerminal('🔧 isScrambling:', isScrambling);\r\n              handleFindAndFixGrayFaces();\r\n            }}\r\n            disabled={isScrambling}\r\n            $isActive={false}\r\n            $hasIncorrect={false}\r\n            style={{\r\n              borderColor: '#FF6B6B',\r\n              borderWidth: '3px',\r\n              background: 'rgba(255, 107, 107, 0.2)'\r\n            }}\r\n          >\r\n            <ButtonContent>\r\n              <div style={{ fontSize: '24px', marginBottom: '8px' }}>🔧</div>\r\n              <ButtonTitle style={{ color: '#FF6B6B', fontWeight: 'bold' }}>\r\n                Find & Fix Gray Faces\r\n              </ButtonTitle>\r\n              <ButtonSubtitle>\r\n                Identify and automatically correct dark gray faces to proper colors\r\n              </ButtonSubtitle>\r\n            </ButtonContent>\r\n          </IdentifyButton>\r\n        </ButtonGrid>\r\n      </div>\r\n\r\n      {/* Combination Identification */}\r\n      <div>\r\n        <h4 style={{ color: 'white', marginBottom: '15px', fontSize: '16px' }}>By Shape + Color + Border Combinations</h4>\r\n        <ButtonGrid style={{ gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))' }}>\r\n          {combinations.map(combination => {\r\n            const state = getCombinationButtonState(combination);\r\n            \r\n            return (\r\n              <IdentifyButton\r\n                key={`combination-${combination.id}`}\r\n                onClick={() => handleCombinationClick(combination)}\r\n                disabled={isScrambling}\r\n                $isActive={state.isActive}\r\n                $hasIncorrect={state.hasIncorrect}\r\n                style={{\r\n                  borderColor: state.hasIncorrect ? '#ff4757' : combination.borderColorHex,\r\n                  borderWidth: '3px'\r\n                }}\r\n              >\r\n                <ButtonContent>\r\n                  <ShapeContainer>\r\n                    {combination.shapeType === 'Triangle' ? (\r\n                      <svg width=\"50\" height=\"50\" viewBox=\"0 0 50 50\">\r\n                        <polygon \r\n                          points=\"25,5 45,40 5,40\" \r\n                          fill={getShapeColorHex(combination.shapeColor)}\r\n                          stroke={combination.borderColorHex}\r\n                          strokeWidth=\"3\"\r\n                        />\r\n                      </svg>\r\n                    ) : (\r\n                      <ShapeVisual\r\n                        $shapeType={combination.shapeType}\r\n                        $shapeColor={getShapeColorHex(combination.shapeColor)}\r\n                        $borderColor={combination.borderColorHex}\r\n                      />\r\n                    )}\r\n                    {state.count > 0 && (\r\n                      <CountBadge $hasIncorrect={state.hasIncorrect}>\r\n                        {state.count}\r\n                      </CountBadge>\r\n                    )}\r\n                  </ShapeContainer>\r\n                  <ButtonTitle>\r\n                    {combination.shapeColor} {combination.shapeType}\r\n                  </ButtonTitle>\r\n                </ButtonContent>\r\n              </IdentifyButton>\r\n            );\r\n          })}\r\n        </ButtonGrid>\r\n      </div>\r\n\r\n      {/* Status Message */}\r\n      {activeIdentification && (\r\n        <StatusMessage $type=\"success\">\r\n          Combination identification complete! Check the terminal for detailed results.\r\n        </StatusMessage>\r\n      )}\r\n    </IdentifyContainer>\r\n  );\r\n}\r\n\r\nexport default IdentifyIncorrectShapes;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}